連猴子都能懂的GIT入門指南(初階)
資料來源: https://backlog.com/git-tutorial/tw/

[入門篇]

  # Git 基本介紹
    1.Git解決多人編輯相同檔案出現覆蓋的問題
    2.利用Git管理檔案, 更新歷史會保留在Git, 故不需要複製備用檔案.
    
    =使用數據庫(Repository)管理歷史記錄=
      * Git的數據庫分為遠端數據庫和本地端數據庫。
        1. 遠端數據庫: 配有專用的伺服器，為了讓多人共享而建立的數據庫。
        2. 本地端數據庫：為了方便用戶個人使用，在自己的機器上配置的數據庫。

      * 建立數據庫, 建立本地端數據庫的方法有兩種:
        1. 重建本地端數據庫(Build)
        2. 複製遠端數據庫(Fork)

    =記錄修改的提交(commit)=
      * 執行提交後，數據庫裡會產生上次提交狀態與現在狀態的差異記錄（稱為Revision）
      # 重點提示 #
        1. 錯誤修復(Fix Bug)或功能添加(Add new Function)之類不同含義的更改，
           #!--要[分開提交]，方便事後從歷史記錄裡找出特定修改內容。
        
        2. 執行提交時，務必輸入 [提​​交訊息]
           提交訊息是查看其他人提交的修改內容或自己檢查歷史記錄時重要的資料。
           #!--要[用心填寫]，讓人容易理解的提交訊息。
        
        3. 標準[提​​交訊息]格式
           第1行: 提交時修改內容摘要
           第2行: 空行
           第3行後: 修改理由

    =工作目錄(Working Tree)與索引(Index)=
      * 工作目錄（Working Tree）是保存您目前正在處理檔案的目錄，Git 相關的操作都會在這個目錄下完成。
      * 索引(Index)位於工作目錄和數據庫之間，是為了向數據庫提交作準備的暫存區域。(又稱 [暫存區 Staging Changed])
      # 重點提示 #
        1. 沒有加入索引(放入暫存區變更Staged_Changes)(Index) or 未放入[暫存區 Staging Changed]的檔案無法被提交(commit)

  # 教學1 開始使用GIT
    =安裝GIT=
      * 安裝git(在主控台[CMD]下操作GIT) https://git-scm.com/
        1. 確認是否安裝成功. 
          # git --version
          output: git version 2.30.0.windows.1

    =初始設定=
      * Git的設定會被記錄在用戶的目錄首頁下的.gitconfig檔案裡
      * 安裝後
        1. 請設定用戶名稱和電子郵件地址.
          # git config --global user.name "使用者名稱" 註: 有輸入"使用者名稱"會覆蓋現值, 沒輸入則列出現值
          # git config --global user.email "電子信箱" 註: 有輸入"使用者名稱"會覆蓋現值, 沒輸入則列出現值
        
        2. 設定GIT輸出(output)結果顏色
          # git config --global color.ui auto
        
        3. 設定GIT命名別名, 例: checkout => co
          # git config --global alias.co checkout

        4. 排除中文檔名顯示亂碼"\346\226\260\350\246..."的異常
          # git config --global core.quotepath off
      
        5. 檢查設定值(所有有值的設定)
          # git config --list
        
        6. 檢視某個設定目前的值
          # git config user.name

      # 重點提示 #
        1. Windows使用主控台時不可以輸入中文
        2. 提交訊息時要使用中文的話，不要使用 -m 參數，要用<外部編輯器>來輸入.
        3. <外部編輯器>必須使用文字編碼為 "UTF-8"，並使用換行字元為 "LF"
          # git config --global core.editor "\"[外部編輯器的路徑]\""
          git config --global core.editor "'C:/Program Files/Microsoft VS Code/Code.exe' -multiInst -nosession"
          git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession"

    =新建數據庫(Repository)=
      * 在本地端建立新的數據庫。
        建立一個名稱為「tutorial」的空目錄，
        把它放在Git的管理之下。
          $ cd C:\Projects\Projects_Git
          $ mkdir tutorial
          $ cd tutorial
          $ git init # 新建數據庫(Repository) @tutorial 資料夾
            Initialized empty Git repository in C:/Projects/Projects_Git/tutorial/.git/

    =提交(commit)檔案=
      * 在「tutorial」目錄下, 新增文字檔 Sample.txt
      * 在Git管理目錄下, 確認狀態
        $ git status
          On branch master
          No commits yet
          Untracked files: (指出 Sample.txt 未被追蹤, 只要加入索引(放入暫存區變更Staged_Changes), 即列入追蹤)
            (use "git add <file>..." to include in what will be committed)
                  Sample.txt (字體為紅色)
          nothing added to commit but untracked files present (use "git add" to track)
      
      * 加入索引(放入暫存區變更Staged_Changes)指令
        $ git add <file>... # 單檔案.
        $ git add <file1> <file2> # 多檔以空白鍵隔開即可.

      # 重點提示 #
        $ git add . #表示把當前目錄下所有檔案加入索引(放入暫存區變更Staged_Changes).
        $ git status #確認檔案狀態, 新增的3個檔案都加入索引(放入暫存區變更Staged_Changes)(追蹤)
          On branch master
          No commits yet
          Changes to be committed:
            (use "git rm --cached <file>..." to unstage)
                  new file:   Sample.txt (字體為綠色)
                  new file:   Second.txt
                  new file:   Third.txt

      * 加入索引(放入暫存區變更Staged_Changes)後, 可正式提交(commit)
        $ git commit -m "<提交訊息, 說明本次提交變更>"
        $ git commit -m "first commit"
          [master (root-commit) a5b29bd] first commit
          3 files changed, 5 insertions(+)
          create mode 100644 Sample.txt
          create mode 100644 Second.txt
          create mode 100644 Third.txt
        $ git status #確認檔案狀態
          On branch master
          nothing to commit, working tree clean #毋須提交項目, 工作目錄是乾淨的

      * 檢視歷史提交紀錄
        $ git log
          commit a5b29bd35a731b773ebe63a99b6f984e5128e567 (HEAD -> master)
          Author: kl.cheng <kuanglian546@outlook.com>
          Date:   Thu Apr 13 09:51:33 2023 +0800

              first commit

      # 重點提示 #
        1. 檢視歷史提交紀錄的方式有兩個
          a. git log #在命令列中檢視
          b. gitk #使用GUI介面檢視
             $ gitk

  # 共享數據庫
    =Push到遠端數據庫=
      * 執行Push之後，本地端的修改歷史會被上傳到遠端數據庫。
      * 遠端數據庫的修改歷史就會和本地端數據庫的修改歷史保持同步。

    =複製(Clone)遠端數據庫 (第1次新增專案時)=
      * 遠端數據庫中有其他人的修改歷史，那麼把它完整地複製下來，您就可以接著進行工作了。
      * 執行複製(Clone)後，可以把遠端數據庫裡的內容全部下載下來，之後您可以在另一台機器的本地數據庫上進行操作。
      
      # 重點提示 #
        * 遠端數據庫修改歷史也會被複製到本地數據庫裡，
          所以和原本的數據庫一樣，可以查看歷史記錄和提交了。

    =從遠端數據庫執行Pull (與多人共同開發同一專案後)=
      * 若是共享遠端數據庫由多人同時作業，那麼作業完畢後所有人都會把修改歷史push到遠端數據庫。
      * 所以需要同步其他人push的修改內容到自己的本地端數據庫。
      * 欲同步遠端數據庫以更新本地端數據庫，請使用Pull(拉取)。
      * 執行pull後，會從遠端數據庫(下載最新的修改歷史)，將其(同步到本地端數據庫)。

      # 重點提示 #
        * Pull === 下載遠端數據庫(下載最新的修改歷史)，將其(同步到本地端數據庫)
        * Clone === 複製遠端數據庫, 作為本地端數據庫使用.

  # 教學2 共享數據庫
    =在貝格樂(backlog)上建立遠端數據庫=
      * 註冊貝格樂(backlog)免費空間 https://backlog.com/tw/pricing/
        貝格樂(backlog)
          ID:kuanglian546@outlook.com
          Password:0809Apple

        1. Your info(Name:KL, Email:kuanglian546@outlook.com,UserID:kuanglian546 Password:0809Apple)
        2. Your org's info(Organization:EquipmentDep, SpaceID(subdomain):kl546.backlog.com)
        3. Create Project(ProjectName:BackLOG_GIT, ProjectKey:BACKLOG_GIT)
      * 開啟GIT功能
        1. Dashboard > Projects > Projects Settings
        2. General Tab > Enable Git(勾選)
      * 新增遠端數據庫
        1. Back to "BackLOG_GIT" 專案首頁
        2. 點選左側 Git 選單, 新增數據庫(Repository)
        3. Repository Name:tutorial, Description:Git學習使用.
          [HTTP] https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
          [SSH] kl546@kl546.git.backlog.com:/BACKLOG_GIT/tutorial.git
        
        4. 註: 本地端數據庫路徑 C:\Projects\Projects_Git\tutorial

    =Push到遠端數據庫=
      * 將本地端數據庫 C:\Projects\Projects_Git\tutorial push 至遠端數據庫前, 建立之間的連接.
        $ git remote add <name> <url>

      * 為遠端數據庫取個適合的別名或暱稱，這樣以後push的時候
        就不需要每次都輸入冗長的遠端數據庫的地址了。
        在本次教學, 遠端數據庫名稱註冊為 "origin"
        
        $ git remote add origin https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
      
      # 重點提示(慣例) #
        * 在主控台, 執行push或pull命令時想省略遠端數據庫名稱的話，會使用 "origin" 名稱作為遠端數據庫。
        * 因此一般都會為遠端數據庫命名為 "origin"

      * Push到遠端數據庫
        $ git push <repository> <refspec>...
        ** <repository>指定要push的地址, <refspec>指定要push的分支 # 進階課程 #

        $ git push -u origin master
        ** origin 指定要push的地址, master 指定要push的分支

          Enumerating objects: 8, done.
          Counting objects: 100% (8/8), done.
          Delta compression using up to 4 threads
          Compressing objects: 100% (4/4), done.
          Writing objects: 100% (8/8), 599 bytes | 199.00 KiB/s, done.
          Total 8 (delta 1), reused 0 (delta 0), pack-reused 0
          To https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
          * [new branch]      master -> master
          Branch 'master' set up to track remote branch 'master' from 'origin'.

      # 重點提示 #
        * 執行提交時指定參數 -u 項目，之後就可省略指定分支名稱。
        * 但當push到空白的遠端數據庫時，您就必須指定遠端數據庫和分支的名稱，千萬不能省略

    =複製遠端數據庫(目前資料夾: "tutorial_UserB", 要Pull Remote Repository回來開發.)=
      * 假設自己是其他的用戶來複製遠端數據庫，請在別的目錄下複製「tutorial_UserB」
      * 使用clone命令來複製遠端數據庫，<repository>指定遠端數據庫的URL, <directory>指定要複製至本地端目錄名稱。
        $ git clone <repository> <directory>
      * 切換至本地端目錄的上一層
        $ cd C:\Projects\Projects_Git
        $ git clone https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git tutorial_UserB
          Cloning into 'tutorial_UserB'...
          remote: Enumerating objects: 8, done.
          remote: Counting objects: 100% (8/8), done.
          remote: Compressing objects: 100% (4/4), done.
          remote: Total 8 (delta 1), reused 0 (delta 0), pack-reused 0
          Unpacking objects: 100% (8/8), 756 bytes | 5.00 KiB/s, done.

    =(目前資料夾: "tutorial_UserB")在複製(Clone)的本地端數據庫執行Push=
      * 修改Clone至 "tutorial_UserB" 的 "Sample.txt" 檔案內容
        => 增加內容 "add 修改加入書籤"
        $ git add Sample.txt # 放入暫存區變更Staged_Changes
      
      * 提交至 "本地端數據庫"
        $ git commit -m "增加add說明"
          [master 2e6c255] 增加add說明
          1 file changed, 3 insertions(+), 1 deletion(-)

      * Push到遠端數據庫
        $ git push
          Enumerating objects: 5, done.
          Counting objects: 100% (5/5), done.
          Delta compression using up to 4 threads
          Compressing objects: 100% (3/3), done.
          Writing objects: 100% (3/3), 384 bytes | 128.00 KiB/s, done.
          Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
          To https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
            e8bc033..2e6c255  master -> master

      # 重點提示 #
        * 在複製(Clone)的本地端數據庫執行Push，可以省略數據庫和分支的名稱

    =(目前資料夾: "tutorial")從遠端數據庫執行Pull=
      * 現在遠端數據庫已經與 「tutorial_UserB」修改內容同步，我們來試試pull修改內容到「tutorial」
      
      # 重點提示 #
        * 使用pull命令時, 若省略 <repository> 數據庫名稱, 預設對 origin命名的 <repository> 數據庫執行pull.
        * $ git pull <repository> <refspec>...

      * (目前資料夾: "tutorial"), 切換至本地端工作目錄
        $ cd C:\Projects\Projects_Git\tutorial
        $ git pull origin master
          From https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
          * branch            master     -> FETCH_HEAD
          Updating e8bc033..000a00c
          Fast-forward
          Sample.txt | 6 ++++--
          1 file changed, 4 insertions(+), 2 deletions(-)

        $ git log #確認歷史紀錄

  # 合併修改紀錄
    =合併修改紀錄=
      * 您上次push到執行下一次push的期間，如果有其他人push更新了遠端數據庫，
        而您沒有更新本地端數據庫，那麼您的push會被拒絕.
      * 需要進行合併(Merge)導入其他人修改歷史，不然你的push都會被拒絕.
      * 若沒有先合併(Merge)直接覆蓋歷史記錄的話，其他人push修改內容（如圖提交C）會消失. # 很嚴重 #

      # 重點提示 #
        ** Git執行合併時, 可能會有 "自動合併" 的部分. (註: 變更非同一行時, 即可 "自動合併" 成功.)
        ** 變更同一行會出現衝突, 則無法 "自動合併". (註: Git不能自動判斷, 則會發生錯誤.)

    =解決衝突=
      # 重點提示 #
        ** 衝突會用 "<<<<<<<<" & ">>>>>>>>" 夾起來.
          <<<<<<<<
          我是衝突-新增(本地端數據庫)
          =========
          我被衝突-已存(遠端數據庫)
          >>>>>>>>
        ** 用"========="分隔
          上方是本地端數據庫的編輯內容，
          下方是遠端數據庫的編輯內容

      * 修改所有衝突的地方, 再執行Commit & Push到遠端數據庫
        例: 保留 "我被衝突-已存(遠端數據庫)" 內容

  # 教學3 合併修改紀錄
    =製造衝突=
      * 本地端數據庫(tutorial)下操作GIT
        1.修改Sample.txt內容 "commit 記錄索引的狀態"
        2.提交至本地端數據庫(tutorial), 訊息: "add commit 說明"
          $ git add Sample.txt
          $ git commit -m "add commit 說明"
      
      * 本地端數據庫(tutorial_UserB)下操作GIT
        1.修改Sample.txt內容 "pull 取得遠端數據庫內容"
        2.提交至本地端數據庫(tutorial_UserB), 訊息: "add pull 說明"
        3.Push到遠端數據庫(Success)
          $ git add Sample.txt
          $ git commit -m "add pull 說明"
          $ git push
      
      # 重點提示 #
        ** 遠端數據庫(BackLOG_GIT)
          1.確認歷史紀錄: "add pull 說明"
          2.現在，遠端數據庫的第三行即為「pull 取得遠端數據庫的內容」啦

      * 本地端數據庫(tutorial)下操作GIT
        1.#!-注意-!#, 遠端數據庫(BackLOG_GIT)內容已變更.
        2.Push到遠端數據庫(Failed, 超詳細提示內容, 告訴更新被拒絕, 因為目前分支是落後, 再次 git push 前先 git pull)
          $ git push
            ! [rejected]        master -> master (non-fast-forward)
            error: failed to push some refs to 'https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git'
            hint: Updates were rejected because the tip of your current branch is behind
            hint: its remote counterpart. Integrate the remote changes (e.g.
            hint: 'git pull ...') before pushing again.
            hint: See the 'Note about fast-forwards' in 'git push --help' for details.

    =解決衝突=
      * 本地端數據庫(tutorial)下操作GIT
        1.以遠端數據庫 對 本地端數據庫 執行合併
          (註: $ git pull <遠端數據庫 or 遠端數據庫別名> <分支名稱>)
          $ git pull origin master
            From https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
            * branch            master     -> FETCH_HEAD
            Auto-merging Sample.txt
            CONFLICT (content): Merge conflict in Sample.txt
            Automatic merge failed; fix conflicts and then commit the result.
        
        2.Sample.txt 檔案內容出現變化 (註: VSCode功能真的太強了, 還幫忙加註並比較)
          Accept Current Change | Accept Incoming Change | Accept Both Change | Compare Changes                
          <<<<<<< HEAD (Current Change)
          commit 記錄索引的狀態
          =======
          pull 取得遠端數據庫內容
          >>>>>>> e6d41613d273b938481714e066e711f4753d4a3f (Incoming Change)

        3.Accept Both Change 導入雙方變更
          Line 7 commit 記錄索引的狀態
          Line 8 pull 取得遠端數據庫內容
          $ git add Sample.txt
          $ git commit -m "合併tutorial & tutorial_UserB間衝突"
          $ git push

        4.檢視歷史提交紀錄, 以圖形方式
          $ git log --graph --oneline
            *   0f67ce6 (HEAD -> master, origin/master) 合併tutorial & tutorial_UserB間衝突
            |\
            | * e6d4161 add pull 說明
            * | 9a600ac add commit 說明
            |/
            * 000a00c 另存為UTF8編碼
            * 2e6c255 增加add說明
            * e8bc033 增加第2行
            * a5b29bd first commit

      * 本地端數據庫(tutorial_UserB)下操作GIT
        1.以遠端數據庫同步本地端數據庫(tutorial_UserB)
          $ git pull origin master
            From https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
            * branch            master     -> FETCH_HEAD
            Updating e6d4161..0f67ce6
            Fast-forward
            Sample.txt | 3 ++-
            1 file changed, 2 insertions(+), 1 deletion(-)
        
        2.檔案Sample.txt與遠端數據庫同步
            第1次加入的文字檔...

            連猴子都懂的Git命令

            add 修改加入書籤

            commit 記錄索引的狀態
            pull 取得遠端數據庫內容

        3.Push到遠端數據庫(什麼都沒有修改)
          $ git push
            Everything up-to-date

[進階篇] 

  # 分支
    =什麼是分支=
      * 為了同時滿足下列需求, 產生出分支功能.
        1.多人開發同一功能
        2.多人修復錯誤
        3.多個發佈版本的存在
        4.針對每個版本進行維護
      
      * 分支是為了將修改記錄的整體流程分開儲存，讓不同分支間獨立運作.
      * 分支可讓 同一個數據庫裡可以同時進行多個不同的修改.
        1.發佈版本的歷史紀錄
        2.追加功能的歷史紀錄
        3.修復錯誤的歷史紀錄
      
      * 分支 還可跟其他分支合併
        1.一般作法: 主要分支
        2.開發團隊成員從 [主要分支], 建立自己 [個別分支].
        3.成員完成工作後, 再將 [個別分支] 匯入 [主要分支].
        4.如此一來, 成員間不受他人進度影響, 每個提交歷史記錄都會被儲存.
        5.異常發生時, 更容易找到發生問題的地方.

      * [Master分支]
        1.在數據庫進行最初的提交後，Git會建立一個名為 [Master分支]。
        2.之後的提交在切換分支前, 都會匯入 [Master分支]裡。

    =分支的運用=
      * [Integration分支]
        1.保持 [Integration分支] 的穩定是很重要的，因為新的分支會建立在它的上面.
        2.[Integration分支] 是為了可以隨時建立發布版本的分支。
        3.如果要進行更改的話，最好先建立 [Topic分支] 並在上面做操作，像是使用Jenkins之類的CI工具進行自動建立或測驗時，也是會在 [Topic分支] 裡進行。

      * [Topic分支]
        1.[Topic分支]是為了"開發功能"或"修復錯誤"之類的任務所建立的分支。
        2.若同時進行多個任務時，您必須建立多個[Topic分支]。
        3.[Topic分支]是從穩定的[Integration分支]上建立的，完成作業後，要將[Topic分支]再合併到[Integration分支]。

    =分支的切換=
      * 切換分支
        1.若要切換分支，請使用 "checkout" 命令.
        2.執行"checkout"後，工作目錄裡的檔案會根據切換到不同的分支而呈現該分支最後提交的內容。
        3."checkout"後的提交，則屬於切換後的分支.

      * HEAD
        1.HEAD代表當前分支的最新提交名稱。
        2.在建立新的數據庫時，Git會 "預設" HEAD指向 [Master分支]。
        3.可以藉由 移動HEAD指向，更新正在使用的分支。

      # [看不太懂]重點提示: 指向提交時用~(Tilde)和^(caret)，指向某個提交的相對位置 #
        1.最常用的就是在HEAD後面加上~(Tilde）可以指向第幾代的父代；
        2.^(caret) 可以指向幾世代以前的父代。
        3.例: HEAD~2 or HEAD~1^1 ,指向相同父代.

      * Stash
        1.[GIT例行作法] 還未提交的修改內容或新增檔案，
            留在工作目錄尚未提交的情況下 "checkout" 到其他的分支時，
            修改內容會從原來的分支移動到切換後的分支。
        2.[問題情境] 如果在 (1)"切換後的分支中有相同檔案"，而且 (2)"有任何修改"的話，
            "checkout"會失敗。
        3.[解決"checkout"失敗作法] 
          解法(1)-不使用Stash: 先提交(Commit)修改內容, 再 "checkout" 分支. (註: 新分支有修改內容, 因為已提交完成)
          解法(2)-使用Stash: 將修改內容放入"stash暫存區"後, 再 "checkout" 分支. (註: 新分支沒有修改內容, 因為修改內容被移至暫存區)

        4.Stash是暫時儲存檔案修改內容的區域。
        5.Stash可以暫時儲存工作目錄還沒提交的修改內容，
          您可以在事後再取出暫時儲存的修改，應用到原先的分支或者其他的分支中。

    =分支的合併=
      * 合併分支
        1.完成作業的Topic分支，最終都會合併到Integration分支。
        2.合併分支有2種方法：使用「merge」或「rebase」。
        3.根據使用合併分支方法, 合併後的分支歷史記錄有很大的差別。

      * Merge
        1.使用 merge，可以合併多個歷史記錄。
        2.假設有兩個分支 Master分支 & Bugfix分支, Bugfix分支是由 Master分支 checkout 出來的.
          
          # 合併(Merge) Bugfix分支至Master分支時 #
          
          Case1 => Master分支狀態未更動, 只有Bugfix分支有修改, 毋須產生新的「合併提交」, 
            這種合併稱之為 "fast-forward", 直接把Bugfix分支接在Master分支後, 再把Master分支位置移至最末端即可.
          
          Case2 => Master分支及Bugfix分支都有新修改. 
            為了匯合兩分支的修改, "必須" 產生新的「合併提交」 
            這種合併稱之為 "non fast-forward", Master分支的位置移至新的「合併提交」上.

      # 重點提示(Merge) #
        1.執行合併時，使用 non fast-forward 參數選項，即使是可以 fast-forward 的合併也會建立新的「合併提交」喔。
        2.執行 non fast-forward 的合併後，分支會維持原狀，要調查在這個分支裡的操作就容易多了。

      * Rebase
        1.Rebase功能和 merge一樣可以合併多個歷史記錄。
        2.假設有兩個分支 Master分支 & Bugfix分支, Bugfix分支是由 Master分支 checkout 出來的.

          # (Rebase) Bugfix分支至Master分支時 #
            a.Bugfix分支的歷史記錄會增加在 Master分支後面。因此，如圖所示歷史記錄會被統一，形成簡單的一條線。
            b.Bugfix分支移動提交 X 和 Y 有可能會發生衝突，所以需要修改各自提交時發生衝突的部分.
            c.執行Rebase 時，master 的位置不變
            d.最後,待 Master分支 合併 Bugfix分支 後，Master分支 的HEAD會移動到 Bugfix分支 的HEAD這裡。

      # 重點提示(Merge 與 Rebase的比較) #
        1.Merge
          修改內容的歷史記錄會維持原狀，但是合併後的歷史紀錄會變得更複雜。
        2.Rebase
          修改內容的歷史記錄會接在要合併的分支後面，合併後的歷史記錄會比較清楚簡單，但是會比使用 merge 更容易發生衝突。
        3.要使用 Merge 或 Rebase 沒有標準答案, 視團隊需求而定.
        4.如想要簡化歷史記錄，可以試試以下操作:
          a.從integration分支導入最新變更時，可以在topic分支上使用 Rebase.
          b.合併topic分支上的變更到integration分支時，
            可先在topic分支上使用 rebase，再將topic分支上的變更合併到integration分支.

    =Topic分支 & Integration分支的運用實例=

  # 教學1 使用分支
    =事前準備=
    =建立分支=
    =切換分支=
    =合併分支=
    =刪除分支=
    =平行操作=
    =解決合併衝突=
    =用rebase合併=

  # 遠端數據庫
    =Pull=
    =Fetch=
    =Push=

  # 標籤
    =標籤=
  
  # 教學2 使用標籤
    =事前準備=
    =添加"輕量標籤"=
    =添加"標示標籤"=
    =刪除標籤=
  
  # 改寫提交
    =修改最近的提交=
    =取消過去的提交=
    =放棄提交=
    =提取提交=
    =改寫提交的記錄=
    =匯合分支上的提交一同合併=
  
  # 教學3 改寫提交
    =Commit --amend=
    =Revert=
    =Reset=
    =Cherry-pick=
    =使用 rebase -i 合併提交=
    =使用 rebase -i 修改提交=
    =Merge --squash=


30 天精通 Git 版本控管(進階)
資料來源: https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/README.md

CH1
    git add <file name>
        #暫存變更(增加索引index)
    git commit -m <確認用的註解> --author '<User name><User email>'
        #確認變更
    gitk
        #開啟GUI工具

CH2
    git config -l
    git config --system -l
    git config --global -l
        #查詢設定內容
    
    git config user.name '<user name>'
    git config user.mail '<user email>'
        #設定預設使用者名稱/使用者mail for commiting
    
    git config --unset user.name
        #移除設定內容
    
    git config alias.指令別名 '正式指令及選項'
        #指定設定指令別名，快速輸入用
    
    git config alias.con 'config -l'
        #例：git con = git config -l
    
    git config --unset alias.con
        #取消別名設定

    git diff 
        #程式碼比較
    
    git difftool 
        #呼叫設定的比較工具

如何移除LOCAL的儲存庫
  0. backup files to another folder
  1. 'git commit -a' , 將所有變更簽入.
  2. remove folder .git , 這時就能刪除 .git 儲存庫資料夾了.

如何移除本機端GIT儲存庫(responsity)
  1. 先備份檔案至別的資料夾
  2. 刪除該資料夾的檔案, .git會刪不掉
  3. git commit -a
  4. 最後, 就能把 .git 刪掉了

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Changes to be committed:
#	deleted:    AFile.txt.txt
#



就會將版本控制的檔案清除，這樣就回到最原始的乾淨的資料夾