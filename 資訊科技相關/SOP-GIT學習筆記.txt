連猴子都能懂的GIT入門指南(初階)
資料來源: https://backlog.com/git-tutorial/tw/

[入門篇]

  # Git 基本介紹
    1.Git解決多人編輯相同檔案出現覆蓋的問題
    2.利用Git管理檔案, 更新歷史會保留在Git, 故不需要複製備用檔案.
    
    =使用數據庫(Repository)管理歷史記錄=
      * Git的數據庫分為遠端數據庫和本地端數據庫。
        1. 遠端數據庫: 配有專用的伺服器，為了讓多人共享而建立的數據庫。
        2. 本地端數據庫：為了方便用戶個人使用，在自己的機器上配置的數據庫。

      * 建立數據庫, 建立本地端數據庫的方法有兩種:
        1. 重建本地端數據庫(Build)
        2. 複製遠端數據庫(Fork)

    =記錄修改的提交(commit)=
      * 執行提交後，數據庫裡會產生上次提交狀態與現在狀態的差異記錄（稱為Revision）
      # 重點提示 #
        1. 錯誤修復(Fix Bug)或功能添加(Add new Function)之類不同含義的更改，
           #!--要[分開提交]，方便事後從歷史記錄裡找出特定修改內容。
        
        2. 執行提交時，務必輸入 [提​​交訊息]
           提交訊息是查看其他人提交的修改內容或自己檢查歷史記錄時重要的資料。
           #!--要[用心填寫]，讓人容易理解的提交訊息。
        
        3. 標準[提​​交訊息]格式
           第1行: 提交時修改內容摘要
           第2行: 空行
           第3行後: 修改理由

    =工作目錄(Working Tree)與索引(Index)=
      * 工作目錄（Working Tree）是保存您目前正在處理檔案的目錄，Git 相關的操作都會在這個目錄下完成。
      * 索引(Index)位於工作目錄和數據庫之間，是為了向數據庫提交作準備的暫存區域。(又稱 [暫存區 Staging Changed])
      # 重點提示 #
        1. 沒有加入索引(放入暫存區變更Staged_Changes)(Index) or 未放入[暫存區 Staging Changed]的檔案無法被提交(commit)

  # 教學1 開始使用GIT
    =安裝GIT=
      * 安裝git(在主控台[CMD]下操作GIT) https://git-scm.com/
        1. 確認是否安裝成功. 
          # git --version
          output: git version 2.30.0.windows.1

    =初始設定=
      * Git的設定會被記錄在用戶的目錄首頁下的.gitconfig檔案裡
      * 安裝後
        1. 請設定用戶名稱和電子郵件地址.
          # git config --global user.name "使用者名稱" 註: 有輸入"使用者名稱"會覆蓋現值, 沒輸入則列出現值
          # git config --global user.email "電子信箱" 註: 有輸入"使用者名稱"會覆蓋現值, 沒輸入則列出現值
        
        2. 設定GIT輸出(output)結果顏色
          # git config --global color.ui auto
        
        3. 設定GIT命名別名, 例: checkout => co
          # git config --global alias.co checkout

        4. 排除中文檔名顯示亂碼"\346\226\260\350\246..."的異常
          # git config --global core.quotepath off
      
        5. 檢查設定值(所有有值的設定)
          # git config --list
        
        6. 檢視某個設定目前的值
          # git config user.name

      # 重點提示 #
        1. Windows使用主控台時不可以輸入中文
        2. 提交訊息時要使用中文的話，不要使用 -m 參數，要用<外部編輯器>來輸入.
        3. <外部編輯器>必須使用文字編碼為 "UTF-8"，並使用換行字元為 "LF"
          # git config --global core.editor "\"[外部編輯器的路徑]\""
          git config --global core.editor "'C:/Program Files/Microsoft VS Code/Code.exe' -multiInst -nosession"
          git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession"

    =新建數據庫(Repository)=
      * 在本地端建立新的數據庫。
        建立一個名稱為「tutorial」的空目錄，
        把它放在Git的管理之下。
          $ cd C:\Projects\Projects_Git
          $ mkdir tutorial
          $ cd tutorial
          $ git init # 新建數據庫(Repository) @tutorial 資料夾
            Initialized empty Git repository in C:/Projects/Projects_Git/tutorial/.git/

    =提交(commit)檔案=
      * 在「tutorial」目錄下, 新增文字檔 Sample.txt
      * 在Git管理目錄下, 確認狀態
        $ git status
          On branch master
          No commits yet
          Untracked files: (指出 Sample.txt 未被追蹤, 只要加入索引(放入暫存區變更Staged_Changes), 即列入追蹤)
            (use "git add <file>..." to include in what will be committed)
                  Sample.txt (字體為紅色)
          nothing added to commit but untracked files present (use "git add" to track)
      
      * 加入索引(放入暫存區變更Staged_Changes)指令
        $ git add <file>... # 單檔案.
        $ git add <file1> <file2> # 多檔以空白鍵隔開即可.

      # 重點提示 #
        $ git add . #表示把當前目錄下所有檔案加入索引(放入暫存區變更Staged_Changes).
        $ git status #確認檔案狀態, 新增的3個檔案都加入索引(放入暫存區變更Staged_Changes)(追蹤)
          On branch master
          No commits yet
          Changes to be committed:
            (use "git rm --cached <file>..." to unstage)
                  new file:   Sample.txt (字體為綠色)
                  new file:   Second.txt
                  new file:   Third.txt

      * 加入索引(放入暫存區變更Staged_Changes)後, 可正式提交(commit)
        $ git commit -m "<提交訊息, 說明本次提交變更>"
        $ git commit -m "first commit"
          [master (root-commit) a5b29bd] first commit
          3 files changed, 5 insertions(+)
          create mode 100644 Sample.txt
          create mode 100644 Second.txt
          create mode 100644 Third.txt
        $ git status #確認檔案狀態
          On branch master
          nothing to commit, working tree clean #毋須提交項目, 工作目錄是乾淨的

      * 檢視歷史提交紀錄
        $ git log
          commit a5b29bd35a731b773ebe63a99b6f984e5128e567 (HEAD -> master)
          Author: kl.cheng <kuanglian546@outlook.com>
          Date:   Thu Apr 13 09:51:33 2023 +0800

              first commit

      # 重點提示 #
        1. 檢視歷史提交紀錄的方式有兩個
          a. git log #在命令列中檢視
          b. gitk #使用GUI介面檢視
             $ gitk

  # 共享數據庫
    =Push到遠端數據庫=
      * 執行Push之後，本地端的修改歷史會被上傳到遠端數據庫。
      * 遠端數據庫的修改歷史就會和本地端數據庫的修改歷史保持同步。

    =複製(Clone)遠端數據庫 (第1次新增專案時)=
      * 遠端數據庫中有其他人的修改歷史，那麼把它完整地複製下來，您就可以接著進行工作了。
      * 執行複製(Clone)後，可以把遠端數據庫裡的內容全部下載下來，之後您可以在另一台機器的本地數據庫上進行操作。
      
      # 重點提示 #
        * 遠端數據庫修改歷史也會被複製到本地數據庫裡，
          所以和原本的數據庫一樣，可以查看歷史記錄和提交了。

    =從遠端數據庫執行Pull (與多人共同開發同一專案後)=
      * 若是共享遠端數據庫由多人同時作業，那麼作業完畢後所有人都會把修改歷史push到遠端數據庫。
      * 所以需要同步其他人push的修改內容到自己的本地端數據庫。
      * 欲同步遠端數據庫以更新本地端數據庫，請使用Pull(拉取)。
      * 執行pull後，會從遠端數據庫(下載最新的修改歷史)，將其(同步到本地端數據庫)。

      # 重點提示 #
        * Pull === 下載遠端數據庫(下載最新的修改歷史)，將其(同步到本地端數據庫)
        * Clone === 複製遠端數據庫, 作為本地端數據庫使用.

  # 教學2 共享數據庫
    =在貝格樂(backlog)上建立遠端數據庫=
      * 註冊貝格樂(backlog)免費空間 https://backlog.com/tw/pricing/
        貝格樂(backlog)
          ID:kuanglian546@outlook.com
          Password:0809Apple

        1. Your info(Name:KL, Email:kuanglian546@outlook.com,UserID:kuanglian546 Password:0809Apple)
        2. Your org's info(Organization:EquipmentDep, SpaceID(subdomain):kl546.backlog.com)
        3. Create Project(ProjectName:BackLOG_GIT, ProjectKey:BACKLOG_GIT)
      * 開啟GIT功能
        1. Dashboard > Projects > Projects Settings
        2. General Tab > Enable Git(勾選)
      * 新增遠端數據庫
        1. Back to "BackLOG_GIT" 專案首頁
        2. 點選左側 Git 選單, 新增數據庫(Repository)
        3. Repository Name:tutorial, Description:Git學習使用.
          [HTTP] https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
          [SSH] kl546@kl546.git.backlog.com:/BACKLOG_GIT/tutorial.git
        
        4. 註: 本地端數據庫路徑 C:\Projects\Projects_Git\tutorial

    =Push到遠端數據庫=
      * 將本地端數據庫 C:\Projects\Projects_Git\tutorial push 至遠端數據庫前, 建立之間的連接.
        $ git remote add <name> <url>

      * 為遠端數據庫取個適合的別名或暱稱，這樣以後push的時候
        就不需要每次都輸入冗長的遠端數據庫的地址了。
        在本次教學, 遠端數據庫名稱註冊為 "origin"
        
        $ git remote add origin https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
      
      # 重點提示(慣例) #
        * 在主控台, 執行push或pull命令時想省略遠端數據庫名稱的話，會使用 "origin" 名稱作為遠端數據庫。
        * 因此一般都會為遠端數據庫命名為 "origin"

      * Push到遠端數據庫
        $ git push <repository> <refspec>...
        ** <repository>指定要push的地址, <refspec>指定要push的分支 # 進階課程 #

        $ git push -u origin master
        ** origin 指定要push的地址, master 指定要push的分支

          Enumerating objects: 8, done.
          Counting objects: 100% (8/8), done.
          Delta compression using up to 4 threads
          Compressing objects: 100% (4/4), done.
          Writing objects: 100% (8/8), 599 bytes | 199.00 KiB/s, done.
          Total 8 (delta 1), reused 0 (delta 0), pack-reused 0
          To https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
          * [new branch]      master -> master
          Branch 'master' set up to track remote branch 'master' from 'origin'.

      # 重點提示 #
        * 執行提交時指定參數 -u 項目，之後就可省略指定分支名稱。
        * 但當push到空白的遠端數據庫時，您就必須指定遠端數據庫和分支的名稱，千萬不能省略

    =複製遠端數據庫(目前資料夾: "tutorial_UserB", 要Pull Remote Repository回來開發.)=
      * 假設自己是其他的用戶來複製遠端數據庫，請在別的目錄下複製「tutorial_UserB」
      * 使用clone命令來複製遠端數據庫，<repository>指定遠端數據庫的URL, <directory>指定要複製至本地端目錄名稱。
        $ git clone <repository> <directory>
      * 切換至本地端目錄的上一層
        $ cd C:\Projects\Projects_Git
        $ git clone https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git tutorial_UserB
          Cloning into 'tutorial_UserB'...
          remote: Enumerating objects: 8, done.
          remote: Counting objects: 100% (8/8), done.
          remote: Compressing objects: 100% (4/4), done.
          remote: Total 8 (delta 1), reused 0 (delta 0), pack-reused 0
          Unpacking objects: 100% (8/8), 756 bytes | 5.00 KiB/s, done.

    =(目前資料夾: "tutorial_UserB")在複製(Clone)的本地端數據庫執行Push=
      * 修改Clone至 "tutorial_UserB" 的 "Sample.txt" 檔案內容
        => 增加內容 "add 修改加入書籤"
        $ git add Sample.txt # 放入暫存區變更Staged_Changes
      
      * 提交至 "本地端數據庫"
        $ git commit -m "增加add說明"
          [master 2e6c255] 增加add說明
          1 file changed, 3 insertions(+), 1 deletion(-)

      * Push到遠端數據庫
        $ git push
          Enumerating objects: 5, done.
          Counting objects: 100% (5/5), done.
          Delta compression using up to 4 threads
          Compressing objects: 100% (3/3), done.
          Writing objects: 100% (3/3), 384 bytes | 128.00 KiB/s, done.
          Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
          To https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git
            e8bc033..2e6c255  master -> master

      # 重點提示 #
        * 在複製(Clone)的本地端數據庫執行Push，可以省略數據庫和分支的名稱

    =(目前資料夾: "tutorial")從遠端數據庫執行Pull=
      * 現在遠端數據庫已經與 「tutorial_UserB」修改內容同步，我們來試試pull修改內容到「tutorial」
      
      # 重點提示 #
        * 使用pull命令時, 若省略 <repository> 數據庫名稱, 預設對 origin命名的 <repository> 數據庫執行pull.
        * $ git pull <repository> <refspec>...

      * (目前資料夾: "tutorial"), 切換至本地端工作目錄
        $ cd C:\Projects\Projects_Git\tutorial
        $ git pull origin master
          From https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
          * branch            master     -> FETCH_HEAD
          Updating e8bc033..000a00c
          Fast-forward
          Sample.txt | 6 ++++--
          1 file changed, 4 insertions(+), 2 deletions(-)

        $ git log #確認歷史紀錄

  # 合併修改紀錄
    =合併修改紀錄=
      * 您上次push到執行下一次push的期間，如果有其他人push更新了遠端數據庫，
        而您沒有更新本地端數據庫，那麼您的push會被拒絕.
      * 需要進行合併(Merge)導入其他人修改歷史，不然你的push都會被拒絕.
      * 若沒有先合併(Merge)直接覆蓋歷史記錄的話，其他人push修改內容（如圖提交C）會消失. # 很嚴重 #

      # 重點提示 #
        ** Git執行合併時, 可能會有 "自動合併" 的部分. (註: 變更非同一行時, 即可 "自動合併" 成功.)
        ** 變更同一行會出現衝突, 則無法 "自動合併". (註: Git不能自動判斷, 則會發生錯誤.)

    =解決衝突=
      # 重點提示 #
        ** 衝突會用 "<<<<<<<<" & ">>>>>>>>" 夾起來.
          <<<<<<<<
          我是衝突-新增(本地端數據庫)
          =========
          我被衝突-已存(遠端數據庫)
          >>>>>>>>
        ** 用"========="分隔
          上方是本地端數據庫的編輯內容，
          下方是遠端數據庫的編輯內容

      * 修改所有衝突的地方, 再執行Commit & Push到遠端數據庫
        例: 保留 "我被衝突-已存(遠端數據庫)" 內容

  # 教學3 合併修改紀錄
    =製造衝突=
      * 本地端數據庫(tutorial)下操作GIT
        1.修改Sample.txt內容 "commit 記錄索引的狀態"
        2.提交至本地端數據庫(tutorial), 訊息: "add commit 說明"
          $ git add Sample.txt
          $ git commit -m "add commit 說明"
      
      * 本地端數據庫(tutorial_UserB)下操作GIT
        1.修改Sample.txt內容 "pull 取得遠端數據庫內容"
        2.提交至本地端數據庫(tutorial_UserB), 訊息: "add pull 說明"
        3.Push到遠端數據庫(Success)
          $ git add Sample.txt
          $ git commit -m "add pull 說明"
          $ git push
      
      # 重點提示 #
        ** 遠端數據庫(BackLOG_GIT)
          1.確認歷史紀錄: "add pull 說明"
          2.現在，遠端數據庫的第三行即為「pull 取得遠端數據庫的內容」啦

      * 本地端數據庫(tutorial)下操作GIT
        1.#!-注意-!#, 遠端數據庫(BackLOG_GIT)內容已變更.
        2.Push到遠端數據庫(Failed, 超詳細提示內容, 告訴更新被拒絕, 因為目前分支是落後, 再次 git push 前先 git pull)
          $ git push
            ! [rejected]        master -> master (non-fast-forward)
            error: failed to push some refs to 'https://kl546.backlog.com/git/BACKLOG_GIT/tutorial.git'
            hint: Updates were rejected because the tip of your current branch is behind
            hint: its remote counterpart. Integrate the remote changes (e.g.
            hint: 'git pull ...') before pushing again.
            hint: See the 'Note about fast-forwards' in 'git push --help' for details.

    =解決衝突=
      * 本地端數據庫(tutorial)下操作GIT
        1.以遠端數據庫 對 本地端數據庫 執行合併
          (註: $ git pull <遠端數據庫 or 遠端數據庫別名> <分支名稱>)
          $ git pull origin master
            From https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
            * branch            master     -> FETCH_HEAD
            Auto-merging Sample.txt
            CONFLICT (content): Merge conflict in Sample.txt
            Automatic merge failed; fix conflicts and then commit the result.
        
        2.Sample.txt 檔案內容出現變化 (註: VSCode功能真的太強了, 還幫忙加註並比較)
          Accept Current Change | Accept Incoming Change | Accept Both Change | Compare Changes                
          <<<<<<< HEAD (Current Change)
          commit 記錄索引的狀態
          =======
          pull 取得遠端數據庫內容
          >>>>>>> e6d41613d273b938481714e066e711f4753d4a3f (Incoming Change)

        3.Accept Both Change 導入雙方變更
          Line 7 commit 記錄索引的狀態
          Line 8 pull 取得遠端數據庫內容
          $ git add Sample.txt
          $ git commit -m "合併tutorial & tutorial_UserB間衝突"
          $ git push

        4.檢視歷史提交紀錄, 以圖形方式
          $ git log --graph --oneline
            *   0f67ce6 (HEAD -> master, origin/master) 合併tutorial & tutorial_UserB間衝突
            |\
            | * e6d4161 add pull 說明
            * | 9a600ac add commit 說明
            |/
            * 000a00c 另存為UTF8編碼
            * 2e6c255 增加add說明
            * e8bc033 增加第2行
            * a5b29bd first commit

      * 本地端數據庫(tutorial_UserB)下操作GIT
        1.以遠端數據庫同步本地端數據庫(tutorial_UserB)
          $ git pull origin master
            From https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
            * branch            master     -> FETCH_HEAD
            Updating e6d4161..0f67ce6
            Fast-forward
            Sample.txt | 3 ++-
            1 file changed, 2 insertions(+), 1 deletion(-)
        
        2.檔案Sample.txt與遠端數據庫同步
            第1次加入的文字檔...

            連猴子都懂的Git命令

            add 修改加入書籤

            commit 記錄索引的狀態
            pull 取得遠端數據庫內容

        3.Push到遠端數據庫(什麼都沒有修改)
          $ git push
            Everything up-to-date

[進階篇] 

  # 分支
    =什麼是分支=
      * 為了同時滿足下列需求, 產生出分支功能.
        1.多人開發同一功能
        2.多人修復錯誤
        3.多個發佈版本的存在
        4.針對每個版本進行維護
      
      * 分支是為了將修改記錄的整體流程分開儲存，讓不同分支間獨立運作.
      * 分支可讓 同一個數據庫裡可以同時進行多個不同的修改.
        1.發佈版本的歷史紀錄
        2.追加功能的歷史紀錄
        3.修復錯誤的歷史紀錄
      
      * 分支 還可跟其他分支合併
        1.一般作法: 主要分支
        2.開發團隊成員從 [主要分支], 建立自己 [個別分支].
        3.成員完成工作後, 再將 [個別分支] 匯入 [主要分支].
        4.如此一來, 成員間不受他人進度影響, 每個提交歷史記錄都會被儲存.
        5.異常發生時, 更容易找到發生問題的地方.

      * [Master分支]
        1.在數據庫進行最初的提交後，Git會建立一個名為 [Master分支]。
        2.之後的提交在切換分支前, 都會匯入 [Master分支]裡。

    =分支的運用=
      * [Integration分支]
        1.保持 [Integration分支] 的穩定是很重要的，因為新的分支會建立在它的上面.
        2.[Integration分支] 是為了可以隨時建立發布版本的分支。
        3.如果要進行更改的話，最好先建立 [Topic分支] 並在上面做操作，像是使用Jenkins之類的CI工具進行自動建立或測驗時，也是會在 [Topic分支] 裡進行。

      * [Topic分支]
        1.[Topic分支]是為了"開發功能"或"修復錯誤"之類的任務所建立的分支。
        2.若同時進行多個任務時，您必須建立多個[Topic分支]。
        3.[Topic分支]是從穩定的[Integration分支]上建立的，完成作業後，要將[Topic分支]再合併到[Integration分支]。

    =分支的切換=
      * 切換分支
        1.若要切換分支，請使用 "checkout" 命令.
        2.執行"checkout"後，工作目錄裡的檔案會根據切換到不同的分支而呈現該分支最後提交的內容。
        3."checkout"後的提交，則屬於切換後的分支.

      * HEAD
        1.HEAD代表當前分支的最新提交名稱。
        2.在建立新的數據庫時，Git會 "預設" HEAD指向 [Master分支]。
        3.可以藉由 移動HEAD指向，更新正在使用的分支。

      # [看不太懂]重點提示: 指向提交時用~(Tilde)和^(caret)，指向某個提交的相對位置 #
        1.最常用的就是在HEAD後面加上~(Tilde）可以指向第幾代的父代；
        2.^(caret) 可以指向幾世代以前的父代。
        3.例: HEAD~2 or HEAD~1^1 ,指向相同父代.

      * Stash
        1.[GIT例行作法] 還未提交的修改內容或新增檔案，
            留在工作目錄尚未提交的情況下 "checkout" 到其他的分支時，
            修改內容會從原來的分支移動到切換後的分支。
        2.[問題情境] 如果在 (1)"切換後的分支中有相同檔案"，而且 (2)"有任何修改"的話，
            "checkout"會失敗。
        3.[解決"checkout"失敗作法] 
          解法(1)-不使用Stash: 先提交(Commit)修改內容, 再 "checkout" 分支. (註: 新分支有修改內容, 因為已提交完成)
          解法(2)-使用Stash: 將修改內容放入"stash暫存區"後, 再 "checkout" 分支. (註: 新分支沒有修改內容, 因為修改內容被移至暫存區)

        4.Stash是暫時儲存檔案修改內容的區域。
        5.Stash可以暫時儲存工作目錄還沒提交的修改內容，
          您可以在事後再取出暫時儲存的修改，應用到原先的分支或者其他的分支中。

    =分支的合併=
      * 合併分支
        1.完成作業的Topic分支，最終都會合併到Integration分支。
        2.合併分支有2種方法：使用「merge」或「rebase」。
        3.根據使用合併分支方法, 合併後的分支歷史記錄有很大的差別。

      * Merge
        1.使用 merge，可以合併多個歷史記錄。
        2.假設有兩個分支 Master分支 & Bugfix分支, Bugfix分支是由 Master分支 checkout 出來的.
          
          # 合併(Merge) Bugfix分支至Master分支時 #
          
          Case1 => Master分支狀態未更動, 只有Bugfix分支有修改, 毋須產生新的「合併提交」, 
            這種合併稱之為 "fast-forward", 直接把Bugfix分支接在Master分支後, 再把Master分支位置移至最末端即可.
          
          Case2 => Master分支及Bugfix分支都有新修改. 
            為了匯合兩分支的修改, "必須" 產生新的「合併提交」 
            這種合併稱之為 "non fast-forward", Master分支的位置移至新的「合併提交」上.

      # 重點提示(Merge) #
        1.執行合併時，使用 non fast-forward 參數選項，即使是可以 fast-forward 的合併也會建立新的「合併提交」喔。
        2.執行 non fast-forward 的合併後，分支會維持原狀，要調查在這個分支裡的操作就容易多了。

      * Rebase
        1.Rebase功能和 merge一樣可以合併多個歷史記錄。
        2.假設有兩個分支 Master分支 & Bugfix分支, Bugfix分支是由 Master分支 checkout 出來的.

          # (Rebase) Bugfix分支至Master分支時 #
            a.Bugfix分支的歷史記錄會增加在 Master分支後面。因此，如圖所示歷史記錄會被統一，形成簡單的一條線。
            b.Bugfix分支移動提交 X 和 Y 有可能會發生衝突，所以需要修改各自提交時發生衝突的部分.
            c.執行Rebase 時，master 的位置不變
            d.最後,待 Master分支 合併 Bugfix分支 後，Master分支 的HEAD會移動到 Bugfix分支 的HEAD這裡。

      # 重點提示(Merge 與 Rebase的比較) #
        1.Merge
          修改內容的歷史記錄會維持原狀，但是合併後的歷史紀錄會變得更複雜。
        2.Rebase
          修改內容的歷史記錄會接在要合併的分支後面，合併後的歷史記錄會比較清楚簡單，但是會比使用 merge 更容易發生衝突。
        3.要使用 Merge 或 Rebase 沒有標準答案, 視團隊需求而定.
        4.如想要簡化歷史記錄，可以試試以下操作:
          a.從integration分支導入最新變更時，可以在topic分支上使用 Rebase.
          b.合併topic分支上的變更到integration分支時，
            可先在topic分支上使用 rebase，再將topic分支上的變更合併到integration分支.

    =Topic分支 & Integration分支的運用實例=
      * 講解關於topic分支和integration分支的操作方法
        1.案例: 在[開發功能的topic分支]操作的途中，需要進行錯誤的修改
        2.這時，integration分支還是處於開發功能之前的狀態。
        3.在[integration分支]新建[修改錯誤用的topic分支]，就可以從開發功能的作業獨立出來，以便開始新的操作。
        4.完成修復錯誤工作後，再將[修改錯誤用的topic分支]導入到原本[integration分支]後, 就可以發佈。
        5.回到原本的[開發功能的topic分支]繼續進行開發功能的操作。
        6.繼續進行開發功能的操作時, 
          發現如果需要之前錯誤修復內容和提交 X 的內容[修改錯誤用的topic分支]，
          就要導入提交 X 的內容，可用 [直接 merge] 或 [rebase 導入提交 X] 的合併分支的方法。
        7.使用[rebase 導入提交 X 的合併分支]方法, 
          [開發功能的topic分支]會與[修改錯誤用的topic分支]匯入[integration分支]後的提交,
          產生新的「合併提交」
      
      # 重點提示 #
        1.只要有效地運用分支，就可以同時進行不同作業了呦。
        2.(GIT使用慣例)強烈建議您閱讀「A successful Git branching model」一文。它列出了現在最常用來管理Git分支的方法。
          A successful Git branching model 英文原文網址: http://nvie.com/posts/a-successful-git-branching-model/
          分支可分為4類, 根據不同用途及角色:
          (1)Main分支(Master分支+Develop分支)
          (2)Feature分支(Topic分支)
          (3)Release分支
          (4)HotFix分支

          ** (1)Main分支(Master分支 + Develop分支(Integration分支))
              ~ Master分支
                Master分支只負責管理發布的狀態。
                當準備好發佈指定版本時，最後的提交會給予一個發布版本標籤。
              ~ Develop分支(Integration分支)
                Develop分支(Integration分支)是針對日常開發用的分支。
                所有新功能開發最終都會合併到這裡，
                類似剛才已經講解過的integration分支的功用。

          ** (2)Feature分支(Topic分支)
              ~ Feature分支就是Topic分支
                Feature分支在於 [功能開發] 或 [問題修復]時, 從 Develop 分支 (Integration分支) 分出來的.
                  Feature分支通常不會分享(團隊成員開發用), 所以不會在遠端數據庫建立分支,
                  開發完成後, 必須合併回 Develop分支(Integration分支) 後再發佈(Release).

          ** (3)Release分支
              ~ Release分支名稱最前面會加上"release-"
                Release分支主要目的是做發佈(Release)前, 最後錯誤修復所建立的分支。
                  成員可以在Release分支裡進行最後的調整，
                  而其他成員依舊在 "Develop分支(Integration分支) > Topic分支" 上進行功能開發，
                  不會相互干擾而影響最後發布.
              
              # 重點提示 => [確認發佈時] #
                1.將[Release分支]合併到[Master分支]，並在合併提交裡添加release版本號標籤.
                2.將[Release分支]合併到[Develop分支(Integration分支)]，
                  以確保 [Master分支] & [Develop分支(Integration分支)] 擁有[Release分支]最新錯誤修復/變更.

          ** (4)HotFix分支
              ~ HotFix分支名稱最前面會加上"hotfix-"
                HotFix分支是在發佈產品作緊急修改時，從 [Master分支] 建立的分支.
                  例: [Develop分支(Integration分支)]的開發進度還不完整, 需作緊急修改,
                    從[Develop分支(Integration分支)]建立可發佈版本還需一段時間,
                    最快方式從 [Master分支] 建立分支進行修改, 再合併回[Develop分支(Integration分支)]

              # 重點提示 => [緊急修改並修正後] #
                1.[HotFix分支]要合併回[Develop分支(Integration分支)]
                2.[HotFix分支]毋須合併回[Master分支], 因為[HotFix分支]是從[Master分支] 建立的分支, 所以 [Master分支] 已是最新狀態.
                3.[HotFix分支] 和 [Release分支] 是兩條獨立分支, 互不相干, 因為功能不同.
                  但相同的是都要和 [Main分支(Master分支 + Develop分支(Integration分支))] 保持一致.

  # 教學1 使用分支
    =事前準備=
      $ mkdir tutorial_branch
      $ cd tutorial_branch
      $ git init
      create a new file "myFile.txt" in tutorial_branch
      file content "連猴子都能懂的Git命令"
      $ git add myFile.txt
      $ git commit -m "first commit"

    =建立分支(git branch <branch_name>)=
      $ git branch <branch_name> # 透過branch命令來建立分支
      $ git branch # 不給任何參數直接執行 branch 命令的話，可以顯示分支列表。前面有 * 的就是現在的分支。
      
      $ git branch issue1 # 建立 issue1 分支
      $ git branch # 檢查新增結果
          issue1
        * master (目前分支, HEAD指向這裡)

    =切換分支(git checkout <branch_name>)=
      $ git checkout <branch_name> # 切換分支
      $ git checkout issue1 # 切換至 issue1分支 or VSCode左下角有顯示目前Branch, 也可以從這裡切換分支.
        Switched to branch 'issue1'
      $ git branch # 檢查切換結果
        * issue1 (目前分支, HEAD指向這裡)
          master

      * 切換到 issue1分支的狀態下提交，歷史記錄會被記錄到 issue1分支。
        1.編輯 "myFile.txt" 
          新增內容 "切換到 issue1分支的狀態下提交，歷史記錄會被記錄到 issue1 分支".

        2.用 add 命令增加 myfile.txt 檔案後再提交。
          $ git add myFile.txt
          $ git commit -m "切換到issue1分支下, 編輯 "myFile.txt"內容後提交"

        3.提交後, 
          > Master分支會落後 issue1分支 1代.
          > HEAD指向目前分支 issue1分支.
          $ git log --graph --oneline 
            # 檢查歷史紀錄, 由下列看出 HEAD 目前指在 issue1分支上, issue2分支 & Master分支是落後1代的.
            * ac6c101 (HEAD -> issue1) 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba (master, issue2) first commit

    # 重點提示 => [同時建立分支和切換] #
      $ git checkout -b <branch_name> #同時建立分支和切換

    =合併分支(git merge <branch_name>)=
      * 案例: 將 issue1 分支的修改合併到 master 分支
        $ git merge <branch_name> # 執行 merge 命令以合併分支

        1.切換到master分支(HEAD指向master分支)
          $ git checkout master
        
        2.確認myFile.txt檔案內容
          Line1 "連猴子都能懂的Git命令"
        
        3.合併issue1分支
          $ git merge issue1
        
        4.確認myFile.txt檔案內容
          Line1 "連猴子都能懂的Git命令"
          Line2 "切換到 issue1分支的狀態下提交，歷史記錄會被記錄到 issue1 分支"

        5.檢查歷史紀錄, 由下列看出 HEAD 目前指在 master及issue1分支上, 
          只剩 issue2分支 落後1代.
          這種合併稱之為 "fast-forward(快轉)"
          $ git log --graph --oneline 
            * ac6c101 (HEAD -> master, issue1) 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba (issue2) first commit
        
      # 重點提示 #
        1.合併分支, 會將指定分支合併至當前使用的分支(HEAD指向目前分支)

    =刪除分支(git branch -d <branch_name>)=
      * 案例: issue1分支的內容已合併到master分支，我們就可以刪除 issue1分支.
        $ git branch -d <branch_name> # 欲刪除分支，請執行branch -d 命令。

        1.刪除 issue1 分支
          $ git branch -d issue1
          Deleted branch issue1 (was ac6c101).
        
        2.用"git branch"命令來確認分支是否已被刪除
          $ git branch
            issue2
          * master
        
        3.檢查歷史紀錄
          $ git log --graph --oneline 
            * ac6c101 (HEAD -> master) 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba (issue2) first commit

        4.刪除 issue2 分支
          $ git branch -d issue2
          Deleted branch issue2 (was 56ce8ba).

        5.檢查歷史紀錄
          $ git log --graph --oneline
            * ac6c101 (HEAD -> master) 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba first commit

      # 重點提示 #
        1.刪除分支, 只有分支本身被刪除.
        2.刪除分支, 歷史紀錄會保留.

    =平行操作=
      * 案例:建立2個分支(issue2 & issue3)來嘗試平行操作.
        1.建立 issue2 分支和 issue3 分支，並切換到 issue2 分支
          $ git branch issue3 # create branch issue3
          $ git checkout -b issue2 # create branch issue2 & switch to branch-issue2
        
        2.檢查切換結果
          $ git branch
            * issue2
              issue3
              master

        3.[在issue2分支]myFile.txt新增內容後提交
          新增內容: "案例:建立2個分支(issue2 & issue3)來嘗試平行操作."
          $ git add myFile.txt
          $ git commit -m "切換到issue2分支下, 編輯 myFile.txt內容後提交"

        4.[在issue3分支]myFile.txt新增內容後提交
          新增內容: "[在issue3分支]myFile.txt新增內容後提交"
          $ git checkout issue3
          $ git add myFile.txt
          $ git commit -m "切換到[issue3分支]下, 編輯 myFile.txt內容後提交"

      * 案例:修改最近的提交(最近1次的提交內容或註解)
        > 方式1: 要先關檔
          $ git commit --amend
        > 方式: 不用關檔(直接修改最近1次提交註解)
          $ git commit --amend -m "更正註解"
        
    =解決合併衝突(使用merge合併)=
      * 案例: 把 issue2 分支和 issue3 分支的修改合併到 master分支.
        1.myFile.txt內容
          > [master分支]
            連猴子都能懂的Git命令
            切換到 issue1分支的狀態下提交，歷史記錄會被記錄到 issue1 分支

          > [issue2分支]
            連猴子都能懂的Git命令
            切換到 issue1分支的狀態下提交，歷史記錄會被記錄到 issue1 分支
            案例:建立2個分支(issue2 & issue3)來嘗試平行操作.

          > [issue3分支]
            連猴子都能懂的Git命令
            切換到 issue1分支的狀態下提交，歷史記錄會被記錄到 issue1 分支
            [在issue3分支]myFile.txt新增內容後提交

        2.切換到[master分支], 合併[issue2分支], # 不會有衝突, GIT會自動執行fast-forward合併 #
          $ git checkout master
          $ git merge issue2 # 不會有衝突, GIT會自動執行fast-forward合併 #
              Updating ac6c101..65a8134
              Fast-forward
              myFile.txt | 3 ++-
              1 file changed, 2 insertions(+), 1 deletion(-)

        3.接著再合併[issue3分支], # 會發生衝突 #
          $ git branch # 確認在 [master分支]
                issue2
                issue3
              * master
          $ git merge issue3 # 會發生衝突 #
              Auto-merging myFile.txt
              CONFLICT (content): Merge conflict in myFile.txt
              Automatic merge failed; fix conflicts and then commit the result.
        
        4.衝突處理
          > VSCode檔案上會出現下列提示
            Accept Current Change | Accept Incoming Change | Accept Both Change | Compare Changes
            <<<<<<< HEAD (Current Change)
            案例:建立2個分支(issue2 & issue3)來嘗試平行操作.
            =======
            [在issue3分支]myFile.txt新增內容後提交
            >>>>>>> issue3 (Incoming Change)
          
          > 點選"Accept Both Change"功能後, 
            a.檔案內容合併
            b.VSCode 自動將檔案加入 "Merge Changes" 區
            c.VSCode 自動填入 "Merge branch 'issue3'" message
            
          > 再次提交
            $ git add myFile.txt
            $ git commit -m "Merge branch 'issue3'"

          > 檢查歷史紀錄
            這次合併產生衝突，必須修改衝突的部分，所以會建立新的提交記錄表示修改的[合併提交-354b8e5]。
            然而, HEAD指向 => [合併提交-354b8e5]
            發生衝突的合併非fast-forward合併，而是non fast-forward合併
            
            $ git log --graph --oneline
              *   354b8e5 (HEAD -> master) Merge branch 'issue3'
              |\
              | * 0933de2 (issue3) 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
              * | 65a8134 (issue2) 切換到issue2分支下, 編輯 myFile.txt內容後提交
              |/
              * ac6c101 切換到issue1分支下, 編輯 myFile.txt內容後提交
              * 56ce8ba first commit

    =用rebase合併=
      * 案例: 使用rebase合併, 讓歷史紀錄單純/簡單點
        0.目前在[Master分支]
          $ git branch
            issue2
            issue3
          * master
        
        1.取消之前的"Merge branch 'issue3'"
          $ git reset --hard HEAD~ # 回到前1代
            HEAD is now at 65a8134 切換到issue2分支下, 編輯 myFile.txt內容後提交
        
        2.檢查檔案內容(myFile.txt)
          原本合併 [issue3分支]的內容被刪除了.
        
        3.檢查歷史紀錄([issue2分支]已合併, [issue3分支]未合併)
          $ git log --graph --oneline
            * 65a8134 (HEAD -> master, issue2) 切換到issue2分支下, 編輯 myFile.txt內容後提交
            * ac6c101 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba first commit

        4.切換到 [issue3分支] 後，對 [master分支] 執行 rebase
          $ git checkout issue3
          $ git rebase master
            error: could not apply 0933de2... 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
            Resolve all conflicts manually, mark them as resolved with
            "git add/rm <conflicted_files>", then run "git rebase --continue".
            You can instead skip this commit: run "git rebase --skip".
            To abort and get back to the state before "git rebase", run "git rebase --abort".
            Could not apply 0933de2... 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
            Auto-merging myFile.txt
            CONFLICT (content): Merge conflict in myFile.txt

            # 利用 rebase 合併發生衝突後的三種作法:
              1. 手動解決所有衝突 -> "git add/rm <conflicted_files>" -> "git rebase --continue"
              2. 跳過這次提交 -> "git rebase --skip"
              3. 取消這次 rebase 合併並返回 -> "git rebase --abort" #

        5.發生衝突, 點選"Accept Both Change"功能後, 
          a.檔案內容合併
          b.VSCode 自動將檔案加入 "Merge Changes" 區
          c.VSCode 自動填入 "Merge branch 'issue3'" message
            
        6.Rebase 再次提交
          $ git add myFile.txt
          $ git commit -m "Merge branch 'issue3'" # Error: 這裡會出錯.
          $ git rebase --continue # Success: 必須使用這個指令
            [detached HEAD d5ebbdc] 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
            1 file changed, 2 insertions(+), 1 deletion(-)
            Successfully rebased and updated refs/heads/issue3.

        7.檢查歷史紀錄(目前指在[issue3分支])
          $ git log --graph --oneline
            * d5ebbdc (HEAD -> issue3) 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
            * 65a8134 (master, issue2) 切換到issue2分支下, 編輯 myFile.txt內容後提交
            * ac6c101 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba first commit

        8.接著在 [master分支] 下, 就可以對 [issue3分支]作 fast-forward 合併.
          $ git checkout master
          $ git merge issue3
            Updating 65a8134..d5ebbdc
            Fast-forward
            myFile.txt | 3 ++-
            1 file changed, 2 insertions(+), 1 deletion(-)

        9.檢查歷史紀錄(目前指在[master分支])
          $ git log --graph --oneline
            * d5ebbdc (HEAD -> master, issue3) 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
            * 65a8134 (issue2) 切換到issue2分支下, 編輯 myFile.txt內容後提交
            * ac6c101 切換到issue1分支下, 編輯 myFile.txt內容後提交
            * 56ce8ba first commit
          
          註1: myfile.txt 的最終內容 rebase 和 merge 是一樣的
          註2: 但是歷史紀錄比較簡單
            [Merge合併]
              *   354b8e5 (HEAD -> master) Merge branch 'issue3'
              |\
              | * 0933de2 (issue3) 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
              * | 65a8134 (issue2) 切換到issue2分支下, 編輯 myFile.txt內容後提交
              |/
              * ac6c101 切換到issue1分支下, 編輯 myFile.txt內容後提交
              * 56ce8ba first commit

            [Rebase合併]
              * d5ebbdc (HEAD -> master, issue3) 切換到[issue3分支]下, 編輯 myFile.txt內容後提交
              * 65a8134 (issue2) 切換到issue2分支下, 編輯 myFile.txt內容後提交
              * ac6c101 切換到issue1分支下, 編輯 myFile.txt內容後提交
              * 56ce8ba first commit

    # 重點提示 => 說明 Merge合併 及 Rebase合併 兩種合併方式的執行步驟..#
      1.Merge合併, 會切換到 [Master分支] 把 <其他分支> 合併進來
      2.Rebase合併, 
        要先切換到 <其他分支> 對 [Master分支] 作Rebase合併, 
        再切回 [Master分支] 對 <其他分支> 作Merge合併.
      3.註: [Rebase合併]方式, 作起來感覺超麻煩..

  # 遠端數據庫
    =Pull(取得遠端數據庫的歷史記錄, 並合併至本地數據庫)=
      * 執行 pull 命令可以取得遠端數據庫的歷史記錄
        1.遠端數據庫的提交紀錄比本地端數據庫還前面，且遠端數據庫包含本地端數據庫的歷史紀錄.
          @遠端數據庫 A -> B -> X -> Y(origin/master)
          @本地數據庫 A -> B(master)
        
        2.Case1: @本地數據庫-[master分支]沒有新的歷史紀錄，@遠端數據庫-[origin/master分支] 未被更新
          a. @遠端數據庫 A -> B -> X -> Y(origin/master)
          b. @本地數據庫 A -> B(master)  # {無} 新的歷史紀錄
          c. 在 "@本地數據庫" 執行pull後，會從遠端數據庫(下載最新的修改歷史)，將其(同步到本地端數據庫).
             沒衝突, 則會使用 (fast-forward 合併).
          d. @遠端數據庫 A -> B -> X -> Y(origin/master)
          e. @本地數據庫 A -> B -> X -> Y(master)
          
        3.Case2: @本地數據庫-[master分支] 有了新的歷史紀錄，@遠端數據庫-[origin/master分支] 未被更新
          a. @遠端數據庫 A -> B -> X -> Y(origin/master) # 未被更新
          b. @本地數據庫 A -> B -> C -> D(master) # {有} 新的歷史紀錄
          c. 在 "@本地數據庫" 執行pull後，會從遠端數據庫(下載最新的修改歷史)，將其(同步到本地端數據庫).
             沒衝突, 則會 (自動建立合併提交),
             有衝突, 須手動解決衝突, 再 (手動提交).
          d. @遠端數據庫 A -> B -> X -> Y(origin/master) # 未被更新
          e. @本地數據庫 A -> B -> C -> D -> E(master) # E(合併提交) 已合併, 且包含遠端數據庫的變更. 
    
    =Fetch(僅查閱遠端數據庫的歷史記錄, 不合併)=
      * 執行 pull，遠端數據庫的內容會自動合併
      * 執行 Fetch
        1.目的: 只想確認遠端數據庫內容, 卻不想合併
        2.後果: 可以取得遠端數據庫的最新歷史記錄。
          取得的提交會導入在自動建立的分支中，
          並可以切換這個名為 "FETCH_HEAD" 的分支。
        3.執行後, 發現歷史記錄原本指向 遠端數據庫origin/master 卻消失了??
      * 執行 pull，遠端數據庫的內容會自動合併
    
    # 重點提示(FETCH_HEAD) #
      * FETCH_HEAD 合併後，歷史記錄會和執行pull操作的結果相同。
      * 實際上，pull的內容就是fetch + merge的內容所組成的。
      * FETCH效果, 目前作不出來??

    =Push(將本地數據庫歷史紀錄 & 變更, 提交至遠端數據庫)=
      * 從本地端數據庫 push 到遠端數據庫時，Git會把 push 的分支與遠端數據庫以 fast-forward 合併
      * push被拒絕的兩種情況:
        1.本地端與遠端發生衝突
        2.push 要以 non-fast-forward 合併遠端數據庫時, Git也會拒絕您的push，以防止覆蓋以前的提交.
      * push被拒絕的解決: 
        1.先pull最新的遠端變更 (註: git pull )
        2.解決本地端與遠端衝突
        3.再push一次
      
      * 實例驗證:
        ** 檢查歷史紀錄
          $ git log --graph --oneline
          *   ca07d27 (HEAD -> master, origin/master) Merge branch 'master' of https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
          |\
          | * 089215e 測試PUSH功能, 發生衝突時, 先pull最新的遠端變更
          , 再進行一次push
          * | 8012088 遠端GIT資料已變更, 必須修正衝突
          |/
          * 155f603 測試FETCH功能, 查看遠端資料變更
          * 7691c2c 提交後,上傳至Backlog
          *   0f67ce6 合併tutorial & tutorial_UserB間衝突
          |\
          | * e6d4161 add pull 說明
          * | 9a600ac add commit 說明
          |/
          * 000a00c 另存為UTF8編碼
          * 2e6c255 增加add說明
          * e8bc033 增加第2行
          * a5b29bd first commit

        ** tutorial_UserB 製造衝突後上傳至BACK_LOG(遠端數據庫)
          * 85ade8c (HEAD -> master, origin/master, origin/HEAD) 在U
          serB製造第2次衝突
          *   ca07d27 Merge branch 'master' of https://kl546.backlog.com/git/BACKLOG_GIT/tutorial
          |\
          | * 089215e 測試PUSH功能, 發生衝突時, 先pull最新的遠端變更
          , 再進行一次push
          * | 8012088 遠端GIT資料已變更, 必須修正衝突
          |/
          * 155f603 測試FETCH功能, 查看遠端資料變更
          * 7691c2c 提交後,上傳至Backlog
          *   0f67ce6 合併tutorial & tutorial_UserB間衝突
          |\
          | * e6d4161 add pull 說明
          * | 9a600ac add commit 說明
          |/
          * 000a00c 另存為UTF8編碼
          * 2e6c255 增加add說明
          * e8bc033 增加第2行

    # 重點提示(Push) #
      * 遠端數據庫共享的提交，基本上是不能修改的。
      * 如果修改的話，和遠端數據庫同步的其他數據庫的歷史記錄會變得很奇怪。

  # 標籤
    =標籤=
      * 標籤是用於標記特定的點/提交的歷史，通常用來標記發布版本的名稱/號碼（如：v1.0）。
      * 標籤有點類似分支，但打上標籤的提交是[固定的]，[不能隨意的變更位置]。
      * 標籤有兩種類型：輕量標籤(lightweight tag)和標示標籤(annotated tag)
        1.輕量標籤(lightweight tag)
          > 不可變更的暫時標籤
          > 可以添加名稱
        2.標示標籤(annotated tag)
          > 可以添加打標簽者的名稱、email及日期
          > 可以添加名稱
          > 可以添加註解
          > 可以添加簽名
      * [標籤]一般作法
        1.輕量標籤(lightweight tag)
          常用在本地端作為<暫時性使用>或<一次性使用>。
        2.標示標籤(annotated tag)
          會用在<較重要提交>，如<發布提交>上可以使用標示標籤來增加註解或簽名。
    
    # 重點提示(tag) #
      * 標籤可以與 checkout(切換分支) 及 reset(取消分支合併) 命令搭配使用（詳細於稍候說明），可以簡單的使用標籤指向特定的提交

  # 教學2 使用標籤
    =事前準備= 
      1.建立一個空白名為 tutorial 的目錄, 在裡面建立新的數據庫
        $ mkdir tutorial_tag
        $ cd tutorial_tag
        $ git init
      2.在 tutorial 目錄建立 myFile.txt 為名的檔案
      3."連猴子都懂的Git命令" >> myFile.txt
      4.提交 myFile.txt
        $ git add myFile.txt
        $ git commit -m "第1次提交"
      5.檢查歷史紀錄
        $ git log

    =添加"輕量標籤"=
      * 使用tag命令來添加標籤，在 <tagname> 給予標籤的名稱.
        在 HEAD 指向的提交上, 增加名為 <tagname> 的標籤
        $ git tag <tagname> # 添加"輕量標籤"

      * 在 HEAD 指向的提交上, 增加名為 "apple" 的標籤
        $ git tag apple

      * 顯示包含標籤資料的歷史記錄
        $ git log --decorate

    =添加"標示標籤"=
      * 添加"標示標籤":
        $ git tag -a <tagname> # 添加"標示標籤", 利用編輯器增加註解

      * 在 HEAD 指向的提交上, 增加名為 "banana" 的"標示標籤", 一併增加註解
        $ git tag -am "我是標籤註解" banana

    =刪除標籤=
      * 刪除標籤:
        $ git tag -d <tagname>
  
    # 重點提示(標籤通用指令) #
      * 顯示標籤列表
        $ git tag

      * 顯示標籤列表 & 註解
        $ git tag -n

  # 改寫提交
    =修改最近的(最近1次)提交(--amend)=
      * 欲修改同一個分支最近的(最近1次)提交內容或註解，
        可以在提交命令時加上 "--amend" 參數執行

      * 主要使用的場合
        1.增加最近(最近1次)提交時漏掉的檔案
        2.修改最近(最近1次)提交內容或註解

    =取消過去的提交(Revert)=
      * 取消過去的提交的三種方式:
        1.使用 Revert 指令
        2.rebase -i
        3.reset # 取消或放棄
      
      * 已發佈的提交, 原則上不能隨便取消.
      
      * 主要使用的場合
        1.安全取消過去發佈的提交
        
    =放棄提交(Reset)=
      * 放棄不需要的提交: reset
      * 須根據影響範圍指定不同模式, 決定是否復原索引或工作目錄內容.
                      HEAD位置指向  索引              工作目錄
                      (Commit)     (Staged_Changes)  (Working folder)
        1.soft        '更動'       '不改變'           '不改變'
        2.mixed(預設) '更動'        '更動'            '不改變'
        3.hard        '更動'       '更動'             '更動'

      * 主要使用的場合
        1.soft: 只取消提交(Commit)
        2.mixed(預設): 復原修改後的索引狀態
        3.hard: 徹底取消最近1次提交(Commit)

    =提取提交(Cherry-pick)=
      * 提取其他分支指定提交, 導入目前分支: Cherry-pick

      * 主要使用的場合
        1.把弄錯的提交, 移至正確位置
        2.把其他分支的提交, 也加入目前分支

    =改寫提交的記錄=

    =匯合分支上的提交一同合併=
  
  # 教學3 改寫提交
    =Commit --amend=
    =Revert=
    =Reset=
    =Cherry-pick=
    =使用 rebase -i 合併提交=
    =使用 rebase -i 修改提交=
    =Merge --squash=


30 天精通 Git 版本控管(進階)
資料來源: https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/README.md

CH1
    git add <file name>
        #暫存變更(增加索引index)
    git commit -m <確認用的註解> --author '<User name><User email>'
        #確認變更
    gitk
        #開啟GUI工具

CH2
    git config -l
    git config --system -l
    git config --global -l
        #查詢設定內容
    
    git config user.name '<user name>'
    git config user.mail '<user email>'
        #設定預設使用者名稱/使用者mail for commiting
    
    git config --unset user.name
        #移除設定內容
    
    git config alias.指令別名 '正式指令及選項'
        #指定設定指令別名，快速輸入用
    
    git config alias.con 'config -l'
        #例：git con = git config -l
    
    git config --unset alias.con
        #取消別名設定

    git diff 
        #程式碼比較
    
    git difftool 
        #呼叫設定的比較工具

如何移除LOCAL的儲存庫
  0. backup files to another folder
  1. 'git commit -a' , 將所有變更簽入.
  2. remove folder .git , 這時就能刪除 .git 儲存庫資料夾了.

如何移除本機端GIT儲存庫(responsity)
  1. 先備份檔案至別的資料夾
  2. 刪除該資料夾的檔案, .git會刪不掉
  3. git commit -a
  4. 最後, 就能把 .git 刪掉了

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Changes to be committed:
#	deleted:    AFile.txt.txt
#

就會將版本控制的檔案清除，這樣就回到最原始的乾淨的資料夾