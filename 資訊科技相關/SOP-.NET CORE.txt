.NET Core BazorPage {沒有內建驗證功能} 
  2023/05/31 
  準備去新公司報到前, 發現 .NET Core BazorPage {竟然沒有內建驗證功能} !!
  太扯了吧, 從05/09從台半離開到05/31現在, 都在花時間學習 {.NET Core}.
  氣死我了, 以後不玩了啦...

{延後}

    Introduction to Identity on ASP.NET Core(登入驗證功能) => ProjectName: MvcIdentity (2021/07/12)
    dotnet new mvc --auth Individual
    https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&tabs=visual-studio

      * 新增登入驗證功能的MVC專案
        dotnet new mvc --auth Individual

      * 套用移轉, 產生資料庫DB
        dotnet tool install --global dotnet-ef
        dotnet ef database update
      
      * 註冊身分驗證服務 @Startup.cs
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext<ApplicationDbContext>(options =>
                options.UseSqlite(
                    Configuration.GetConnectionString("DefaultConnection")));
            services.AddDatabaseDeveloperPageExceptionFilter();

            services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
                .AddEntityFrameworkStores<ApplicationDbContext>();
            services.AddControllersWithViews();

            // 設定身分驗證服務
            services.Configure<IdentityOptions>(options =>
            {
                  // Password settings.
                options.Password.RequireDigit = true;
                options.Password.RequireLowercase = true;
                options.Password.RequireNonAlphanumeric = true;
                options.Password.RequireUppercase = true;
                options.Password.RequiredLength = 6;
                options.Password.RequiredUniqueChars = 1;

                // Lockout settings.
                options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5);
                options.Lockout.MaxFailedAccessAttempts = 5;
                options.Lockout.AllowedForNewUsers = true;

                // User settings.
                options.User.AllowedUserNameCharacters =
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+";
                options.User.RequireUniqueEmail = false;
            });

      * 啟用身分驗證服務 @Startup.cs
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
                app.UseMigrationsEndPoint();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthentication();
            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
                endpoints.MapRazorPages();
            });
        }

      * 測試身分驗證功能 @XXController.cs

        using Microsoft.AspNetCore.Authorization; //重點

        namespace MvcIdentity.Controllers
        {
            public class HomeController : Controller
            {
                private readonly ILogger<HomeController> _logger;

                public HomeController(ILogger<HomeController> logger)
                {
                    _logger = logger;
                }

                public IActionResult Index()
                {
                    return View();
                }

                [Authorize] //重點: 登入後才能瀏覽.
                public IActionResult Privacy()
                {
                    return View();
                }

                [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
                public IActionResult Error()
                {
                    return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
                }
            }
        }

    Introduction to Identity on ASP.NET Core(登入驗證功能) <== 尚未學到.
    https://docs.microsoft.com/zh-tw/aspnet/core/security/authentication/identity?view=aspnetcore-6.0&tabs=netcore-cli

    Persist and retrieve relational data with Entity Framework Core (加強資料庫工具應用 => 使用 Azure 環境, 不好實作, 先不作了 2021/07/13)
    https://docs.microsoft.com/en-us/learn/modules/persist-data-ef-core/?view=aspnetcore-5.0

    Secure an ASP.NET Core web app with the Identity framework (登入驗證功能實作 => 使用 Azure 環境, 不好實作, 先不作了 2021/07/13)
    https://docs.microsoft.com/en-us/learn/modules/secure-aspnet-core-identity/?view=aspnetcore-5.0

/* ASP.NET 的新東西 */
  
  @Html.Raw("htmlContent") <= ASP.NET會編譯為 HTML/JavaScript.., 而不是 字串.

    * 少用 @Html.Raw("htmlContent"), 會被 XSS 插入攻擊
    * 可用 @Html.AntiXssRaw(htmlFromDb), 可避免被 XSS 插入攻擊
    淺談 ASP.NET WebForm / MVC 內嵌 HTML 時的 XSS 防護
    https://blog.darkthread.net/blog/antixss-in-aspnet/

  .AsNoTracking()
    ^ 只能用於OnGetAsync() //查詢或顯示頁面用.
    ^ .AsNoTracking() 用在 OnPostAsync(), 抓出來的Entity會沒有EntityState
      導致 await _context.SaveChangesAsync() Update DB時會失敗
      因為EFCore無法依EntityState, 判斷要insert or update.

  {Many-TO-Many 關係異動}
    * 參考用程式碼:
      ^ (新增) C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Create.cshtml.cs
      ^ (刪除) C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Delete.cshtml.cs
    
    ^ Instructor & Course 是多對多關係, EFCore會產生DB時, 會生出一個{Join Table}, 以記錄之間的關聯性.
    ^ 刪除任何一邊實體時, 必須使用 eager loading (.include)把另一邊JOIN進來, 不然關聯性會遺留在{Join Table}內.
    
      public class Course
      {
          ...
          public ICollection<Instructor> Instructors {get;set;} //navigation property(可以是NULL, 所以未加入FK)
          ...
      }
      public class Instructor
      {
        ...
        public ICollection<Course> Courses {get;set;} //1名老師可上多門課
        ...
      }
    
  {資料檢查}
    > 後端 {ComponentModel.DataAnnotations} 與 前端{asp-validation-for} 必須相互配合
      ^ 以 後端 {ComponentModel.DataAnnotations} 為主.
      ^ 換句話說, 有加檢查 前端{asp-validation-for}欄位, 但後端 {ComponentModel.DataAnnotations} 非必填欄位也沒用.

      Case1.後端 DataModel Property 無[Required]
          , 前端加上 {asp-validation-for}
          , 結果 => 前端檢查不生效力.
      Case2.後端 DataModel Property 有[Required]/ 無[Display(Name="入職日")]
          , 前端加上 {asp-validation-for}
          , 結果 => 檢查生效, 異常訊息顯示 Property Name.
      Case2.後端 DataModel Property 有[Required]/ 有[Display(Name="入職日")]
          , 前端加上 {asp-validation-for}
          , 結果 => 檢查生效, 異常訊息顯示 "入職日".

  {Entity Framework Core tool 使用重點}
    
    > 10.Apply the migration or drop and re-create (EFCore - 正式環境用: 產生改版移轉, 再重新產生DB)
    > 11.Drop and re-create the database (EFCore - 測試環境用: 直接砍DB, 重新產生初版移轉, 再重新產生DB)

"開發環境"程式啟動設定檔(launchSettings.json) => "檔案位置: 專案資料夾/Properties/launchSettings.json"
  0. 適用於本機電腦開發環境
  1. 啟動網站設定 (網址埠號, 網站伺服器設定, 登入驗證方式)
  2. 在 ASP.NET Core 中使用多個環境的設定(開發, 測試, 正式環境)
    https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/environments?view=aspnetcore-6.0
  3. 關於多個環境設定(開發, 測試, 正式環境)的參數為 "ASPNETCORE_ENVIRONMENT"
    例: "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }

環境設定檔(appsettings.json) => "檔案位置: 專案資料夾/appsettings.Development.json or 專案資料夾/appsettings.json"
  1.儲存環境變數的地方，例: 資料庫連接字串.
  2.從檔名得知, "appsettings.Development.json" 給{開發環境}用.
  3."appsettings.json" 給{正式環境}用.

程式主要設定檔(Program.cs) => "檔案位置: 專案資料夾/Program.cs"
  1.Program.cs：程式的起始點
    > #! 從 .NET 6.0 開始, Startup.cs 被合併至 Program.cs !#
  
  2.Startup.cs：程式的組態檔，服務需要從這邊註冊(DI), 此檔在.NET 6.0後就消失了...
  
<使用 "EF Core" 還是 "EF6 = Entity Framework 6.0" >
  The recommendation is to use {EF Core} if:
    The app needs the capabilities of .NET.
    EF Core supports all of the features that the app requires.
  
  Consider using EF6 if both of the following conditions are true:
    The app will run on Windows and .NET Framework 4.0 or later.(EF6可相容到 .NET Framework 4.0 or later)
    EF6 supports all of the features that the app requires.  

<!#--將模型新增至 ASP.NET Core MVC 應用程式 [2023/04/05 ~ 2023/04/05]--#>
  <VIP> 極重要章節
  https://learn.microsoft.com/zh-tw/aspnet/core/tutorials/first-mvc-app/adding-model?view=aspnetcore-7.0&tabs=visual-studio-code
  
  0. 使用 "程式碼產生工具 <codegenerator>" 的前置作業, 新增全域工具, 必要套件加入專案等設定步驟.
  1. 如何把 "<Model> + <Controller> + <View>" 串起來.
  2. 程式碼異動後, 如何將 "變更移轉到資料庫結構(Code First)".

/*== .NET CORE 常用指令(Only for Command Line, 命令列工具)==*/

  dotnet new sln -o <方案名稱>
    新增方案檔

  dotnet new console -o <專案名稱>
    新增console專案

  dotnet new clslib -o <類別專案名稱>
    新增Class專案

  dotnet new xunit -o <測試專案名稱.Tests>
    新增Test專案

  dotnet add <測試專案名稱.Tests>/<測試專案名稱.Tests>.csproj reference <類別專案名稱>/<類別專案名稱>.csproj
  dotnet add <測試專案名稱.Tests> reference <類別專案名稱>
    在<測試專案>中, 新增參考至<被測試專案>, 否則無法呼叫類別方法.

  dotnet sln add <專案名稱>/<專案名稱>.csproj
    將<專案>加入<方案>中

  dotnet tool install -g {toolName}
    安裝共用工具(-g)
    dotnet tool install -g Microsoft.dotnet-httprepl 安裝共用工具至專案中, Microsoft.dotnet-httprepl => 測試WEBAPI用

  dotnet watch run
    原始碼修改後存檔, 程式重新編譯再啟動, 不會自行重啟.

  dotnet run    
    Locates the project file at the current directory.(在目前資料夾找專案檔)
    Retrieves and installs any required project dependencies for this project.(依據專案檔, 存取並安裝所需的套件)
    Compiles the project code.(編譯專案程式)
    Hosts the web API with the ASP.NET Core Kestrel web server at both an HTTP and HTTPS endpoint.
      (在ASP.NET Core Kestrel web server平台上, 開啟HTTP & HTTPS的存取點)

      <dotnet run 出現下列異常>
        Unhandled exception. System.InvalidOperationException: Unable to configure HTTPS endpoint. No server certificate was specified, 
        and the default developer certificate could not be found or is out of date.
        To generate a developer certificate run 'dotnet dev-certs https'. To trust the certificate (Windows and macOS only) run 'dotnet dev-certs https --trust'.
        For more information on configuring HTTPS see https://go.microsoft.com/fwlink/?linkid=848054.

        <解決方法: 重新產生 #產生測試環境簽章(https用)>
          dotnet dev-certs https #產生測試環境簽章(https用), message => The HTTPS developer certificate was generated successfully.
          dotnet dev-certs https --trust #信任測試環境簽章(https用) message => A valid HTTPS certificate is already present.
  
  dotnet new mvc -o {ProjectName}  # 新增MVC架構網站(預設會使用最新版.core SDK)#
  dotnet new mvc -f net5.0 # 強制使用5.0 SDK

  dotnet new webapp -o {ProjectName} # Razor Pages Site #
  dotnet new webapi -f net6.0 # 新增webapi專案(強制使用6.0 SDK)

  dotnet --list-sdks
    檢查已安裝SDK版本, 預設會使用最新版.(6)
    3.1.100 [C:\program files\dotnet\sdk]
    5.0.100 [C:\program files\dotnet\sdk]
    6.0.100 [C:\program files\dotnet\sdk]

  dotnet --list-runtimes
    檢查目前執行環境.
    Microsoft.AspNetCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
    Microsoft.NETCore.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
    Microsoft.WindowsDesktop.App 6.0.4 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

  # Entity Framework Core 指令碼使用手冊 #
    https://learn.microsoft.com/en-us/ef/core/cli/dotnet

    例: dotnet ef migrations <add UpdateProduct_CreateCategory> (註: 依照慣例, 第1次移轉的取名為 InitialCreate; 之後可以改為 add Column_Desc..)
    例: dotnet ef database update (註: 使用最近1次移轉, 執行移轉內的 Up 方法, 來新增資料庫.)
    例: dotnet ef dbcontext script --output <FilePath> (註: Generates a SQL script from the DbContext. Bypasses any migrations.)

  ## <命令列環境>下使用 <dotnet aspnet-codegenerator> 工具的前置作業 ##
    https://learn.microsoft.com/zh-tw/aspnet/core/tutorials/first-mvc-app/adding-model?view=aspnetcore-7.0&tabs=visual-studio-code
    重點在這裡 # 新增 NuGet 套件 #

      # 注意: <.NET SDK> 與 <tool> 版本必須相符 #
      dotnet --version #確認目前版本(6.0), 套件與版本有對應關係, 否則會報錯.

      (開發用電腦安裝1次即可)
        # 安裝 <程式架構(Scaffold)自動產生> 工具  #
        dotnet tool uninstall --global dotnet-aspnet-codegenerator
        dotnet tool install --global dotnet-aspnet-codegenerator --version 6.0.10

        # 安裝 <資料庫移轉/異動(Migration)> 工具  #
        # 資料庫初始化 & 往後資料庫結構異動 都要靠它.. #
        dotnet tool uninstall --global dotnet-ef
        dotnet tool install --global dotnet-ef --version 6.0.10

      (每個專案都要安裝1次)
        # <程式碼自動產生> 套件 加入專案內 #
        dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 6.0.10
        
        # <資料庫結構(Schema)自動產生> 套件 加入專案內 #
        dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.10
		dotnet add package Microsoft.EntityFrameworkCore.Tools --version 6.0.10
        dotnet add package Microsoft.EntityFrameworkCore.SQLite --version 6.0.10
        dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 6.0.10
        dotnet add package Oracle.EntityFrameworkCore --version 7.21.9 # 連結Oracle資料庫套件 #

  dotnet aspnet-codegenerator 自動產生程式碼範本用
    詳細作法參閱連結: https://learn.microsoft.com/zh-tw/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator?view=aspnetcore-7.0

    - 執行 ASP.NET Core Scaffolding 引擎(註: 自動產生程式碼範本用)
    - Only for <命令列環境開發>
    - This tool is no need for <Visual Studio環境>
    - 從命令列進行 Scaffolding 時才需要 dotnet aspnet-codegenerator，
    - 在 Visual Studio 中不需要進行 Scaffolding。

    <dotnet tool install -g dotnet-aspnet-codegenerator>
      dotnet aspnet-codegenerator 是必須安裝的全域工具。 
      上列命令會安裝 dotnet aspnet-codegenerator 工具的最新穩定版本：

    <dotnet tool update -g dotnet-aspnet-codegenerator>
      上列命令會將 dotnet aspnet-codegenerator 更新到可從已安裝之 .NET Core SDK 中取得的最新穩定版本

    <dotnet tool uninstall -g dotnet-aspnet-codegenerator
     dotnet tool install -g dotnet-aspnet-codegenerator>
      可能需要卸載 aspnet-codegenerator 以解決問題。 例如，如果您已安裝 的 aspnet-codegenerator 預覽版本，請先將其卸載，再安裝發行的版本。
      上列命令會卸載 dotnet aspnet-codegenerator 工具，並安裝最新的穩定版本：

/* Razor Pages with Entity Framework Core {EFCore} in ASP.NET Core <= Razor Pages - EFCore DB 中階班 => */ 
(完成第1次-2023/05/11-2023/05/29；課程重點: 說明 {EFCore} 重要觀念及如何使用)
  > 學習網址: https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/intro?view=aspnetcore-7.0&tabs=visual-studio
  > ProjectPath => C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage
  
  Part 0, Razor Pages UI 與 CS 間如何傳值與溝通

    UI:
      <a asp-page="./Index" asp-route-sortOrder="@Model.NameSort">
      <input type="text" name="SearchString" value="@Model.CurrentFilter">
    
    CS:
      public async Task OnGetAsync(string sortOrder, string searchString)

    註: Request 傳至後至 IIS後, 
      ASP.NET Core 會把 asp-route-'sortOrder' or name="SearchString" 與 OnGetAsync 或 OnPostAsync 的傳入參數自動對應.

  Part 0, @Html.DisplayNameFor(顯示名稱) & @Html.DisplayFor(顯示值) 的差異在哪裡?

    UI: Delete.cshtml
      @Html.DisplayNameFor(model => model.Course.DepartmentID) //DisplayNameFor, 要求前端顯示 "開課科系"
      @Html.DisplayFor(model => model.Course.Department.Name) //DisplayFor, 要求前端顯示 Course 關聯實體 Department.Name 的值.

    CS: Delete.cshtml.cs
      DeleteModel 用到 Course 類別如下: 
      
      public class Course
      {
          ...
          [Display(Name ="開課科系")]
          public int DepartmentID {get;set;} //FK
          public Department Department {get;set;} //navigation property(不能為NULL, 所以須加入FK DepartmentID)
          ...
      }

  Part 1, Razor Pages with Entity Framework Core in ASP.NET Core - Tutorial 1 of 8 (2023/05/11 Completed)

    1.By default, EF Core interprets a property that's named {ID} or {classnameID} as the primary key. 
      So the alternative automatically recognized name for the Student class primary key is {StudentID}. 
      For more information, see EF Core - Keys
      
      (註: 預設, EFCore 會使用 {ID} or {classnameID} 作為主鍵. 
        例: Student 類別中, 如果沒有 {ID} 屬性, 就要有 {StudentID} 屬性.)

    2.The {Enrollments} property is a {navigation property}. 
      {Navigation properties} hold other entities that are related to this entity.
      
      (註: Student 類別中, public ICollection<Enrollment> Enrollments{get;set;} 就是瀏覽屬性
        在瀏覽屬性中, 會保存與這個實體關聯的其他實體.)
    
    3.When ICollection<Enrollment> is used, EF Core creates a {HashSet<Enrollment>} collection by default.

      (註: ICollection<Enrollment> 可以是 List<Enrollment> or HashSet<Enrollment>.
        預設, EFCore 會使用 HashSet<Enrollment>.)

    4.EFCore interprets a property as a # 外部鍵 #
      foreign key if it's named {<navigation property name><primary key property name>}. # 第1種 #
        For example,StudentID is the foreign key for the Student navigation property, 
        since the Student entity's primary key is ID. 
      Foreign key properties can also be named {<primary key property name>}. # 第2種 #
        For example, CourseID since the Course entity's primary key is CourseID.

      (註: EFCore 轉譯外部鍵{FK} 方式有兩種 => 
        例: 在 Enrollment 類別裡, {StudentID} & {CourseID} 有兩個 {FK}
          (1)Student 類別裡, PK is ID # 第1種-解譯法 #
          (2)Course 類別裡, PK is CourseID. # 第2種-解譯法 #)

    5.EFCore 不要自動給定PK值的設定
      using System.ComponentModel.DataAnnotations.Schema;
      namespace EFCore_RazorPage.Models
      {
        public class Course
        {    
          [DatabaseGenerated(DatabaseGeneratedOption.None)] //新增資料時, 不要自動遞增或給值.
          public int CourseID{ get; set;}
        }
      }

    6.EFCore 給定欄位值範圍 & 未給值顯示訊息的設定
      using System.ComponentModel.DataAnnotations;
      namespace EFCore_RazorPage.Models
      {
        public enum Grade
        {
          A, B, C, D, F
        }

        public class Enrollment
        {
          public int EnrollmentID{ get; set;}
          public int StudentID {get;set;}
          public int CourseID {get;set;}
          
          [DisplayFormat(NullDisplayText = "No Grade")]
          public Grade? Grade {get;set;}

          // 選課紀錄可對應學生實體
          public Student Student{get;set;}
          // 選課紀錄可對應課程實體
          public Course Course{get;set;}
        }  
      }

    7.出現 {warning CS8618: 退出建構函式時，不可為 Null 的 屬性} 時, 如何處理?
      https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/compiler-messages/nullable-warnings

      a.To eliminate the warnings from nullable reference types, 
        remove the following line from the {ContosoUniversity.csproj} file: <Nullable>enable</Nullable>
        
        (註: 移除專案檔中, {<Nullable>enable</Nullable>} 的設定)
      
      b.The scaffolding engine currently does not support nullable reference types, 
        therefore the models used in scaffold can't either.
        Remove the ? nullable reference type annotation from public string? RequestId { get; set; } in Pages/Error.cshtml.cs 
        so the project builds without compiler warnings.

        {修改前}
        public class ErrorModel : PageModel
        {
          public string? RequestId { get; set; }

        {修改後}
        public class ErrorModel : PageModel
        {
          public string RequestId { get; set; }
    
      public DbSet<MvcShopping.Models.Category>? Category { get; set; };

      public DbSet<MvcShopping.Models.Category> Category { get; set; } = null!;

      方式三: 若此為新程式碼，請考慮變更公用介面
        public class Person
        {
            public Person(string first, string last)
            {
                FirstName = first;
                LastName = last;
            }

            public string FirstName { get; set; }
            public string LastName { get; set; }
        }

      方式四: 若需要在設定名稱前建立 Person 物件，您可使用預設的非 Null 值來初始化屬性
        public class Person
        {
            public string FirstName { get; set; } = string.Empty;
            public string LastName { get; set; } = string.Empty;
        }

    8.Scaffold Student pages(利用Scaffold工具自動產生對應 {異動資料庫實體的 "Pages" } & {作為Pages和DB中介的 "DbContext" })
      
      a.新增 Scaffold工具 所需套件 (版本必須與 .NET 相符)
          dotnet add package Microsoft.EntityFrameworkCore.SQLite
          dotnet add package Microsoft.EntityFrameworkCore.SqlServer
          dotnet add package Microsoft.EntityFrameworkCore.Design
          dotnet add package Microsoft.EntityFrameworkCore.Tools
          dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 6.0.10
          dotnet add package Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore --version 6.0.10

          (註: The {Microsoft.VisualStudio.Web.CodeGeneration.Design} package is required for scaffolding. 
            Although the app won't use SQL Server, the scaffolding tool needs the {SQL Server} package.)

      b.新增 Pages\Students 資料夾(此步驟可省略)
          mkdir Students

      c.安裝 Scaffold 工具 (版本必須與 .NET 相符)
          dotnet tool uninstall -g dotnet-aspnet-codegenerator
          dotnet tool install -g dotnet-aspnet-codegenerator --version 6.0.10 //指定安裝6.0.10版

      d.透過 aspnet-codegenerator, 新增Pages-新增DbContext-新增DbContext相依性插入(DI)於 {Program.cs}-新增DB connectionString於 {appsettings.json}
          
          dotnet aspnet-codegenerator razorpage -m Student -dc EFCore_RazorPage.Data.SchoolContext -udl -outDir Pages\Students -scripts -sqlite
          dotnet aspnet-codegenerator razorpage -m Course -dc EFCore_RazorPage.Data.SchoolContext -udl -outDir Pages\Courses -scripts -sqlite
          dotnet aspnet-codegenerator razorpage -m Enrollment -dc EFCore_RazorPage.Data.SchoolContext -udl -outDir Pages\Enrollments -scripts -sqlite
          
          上面指令作了什麼事？
            1.新增Pages
              Added DbContext : '\Data\SchoolContext.cs'
              Added Razor Page : \Pages\Students\Create.cshtml
              Added PageModel : \Pages\Students\Create.cshtml.cs
              Added Razor Page : \Pages\Students\Edit.cshtml
              Added PageModel : \Pages\Students\Edit.cshtml.cs
              Added Razor Page : \Pages\Students\Details.cshtml
              Added PageModel : \Pages\Students\Details.cshtml.cs
              Added Razor Page : \Pages\Students\Delete.cshtml
              Added PageModel : \Pages\Students\Delete.cshtml.cs
              Added Razor Page : \Pages\Students\Index.cshtml
              Added PageModel : \Pages\Students\Index.cshtml.cs
            2.新增DbContext
              using System;
              using System.Collections.Generic;
              using System.Linq;
              using System.Threading.Tasks;
              using Microsoft.EntityFrameworkCore;
              using EFCore_RazorPage.Models;

              namespace EFCore_RazorPage.Data
              {
                  public class SchoolContext : DbContext
                  {
                      public SchoolContext (DbContextOptions<SchoolContext> options)
                          : base(options)
                      {
                      }

                      public DbSet<EFCore_RazorPage.Models.Student> Student { get; set; } = default!;
                  }
              }
            3.新增DbContext相依性插入(DI)於 {Program.cs}
              builder.Services.AddDbContext<SchoolContext>(options =>
                  options.UseSqlite(builder.Configuration.GetConnectionString("SchoolContext") ?? throw new InvalidOperationException("Connection string 'SchoolContext' not found.")));
            4.新增DB connectionString於 {appsettings.json}
                "ConnectionStrings": {
                  "SchoolContext": "Data Source=EFCore_RazorPage.Data.db"
                }            

      e.微調 ConnectionStrings SqliteDB名稱於 (註: 目前DB尚未產生, 預設值很長.)
        
        {appsettings.json} <= 正式環境
          變更前:
            "ConnectionStrings": {
              "SchoolContext": "Data Source=EFCore_RazorPage.Data.db"
            }
          
          變更後:
            "ConnectionStrings": {
              "SchoolContextSQLite": "Data Source=CU-Production.db"
            }

        {appsettings.Development.json} <= 測試環境
          新增:
            "ConnectionStrings": {
              "SchoolContextSQLite": "Data Source=CU-Development.db"
            }
          
      e.更新 DbContext class 內容
        1.The {main class} that coordinates EF Core functionality for a given {data model} is the database context class. 
          (註: {DbContext class} 就是作為 {data model} 與 {DB} 間溝通最重要的媒介)
        2.The context is derived from {Microsoft.EntityFrameworkCore.DbContext}. 
        3.The context specifies which entities are included in the {data model}.

        {修改前}
          using EFCore_RazorPage.Models;

          namespace EFCore_RazorPage.Data
          {
              public class SchoolContext : DbContext
              {
                  public SchoolContext (DbContextOptions<SchoolContext> options)
                      : base(options)
                  {
                  }

                  public DbSet<EFCore_RazorPage.Models.Student> Student { get; set; } = default!; //不能給預設值
              }
          }

        {修改後}
          using EFCore_RazorPage.Models;
          
          namespace EFCore_RazorPage.Data
          {
              public class SchoolContext : DbContext
              {
                  public SchoolContext (DbContextOptions<SchoolContext> options)
                      : base(options)
                  {
                  }

                  public DbSet<Student> Students { get; set; } = default!; //不能給預設值
                  public DbSet<Course> Courses { get; set; } = default!; //不能給預設值
                  public DbSet<Enrollment> Enrollments { get; set; } = default!; //不能給預設值

                  protected override void OnModelCreating(ModelBuilder modelBuilder) //資料庫初始化時, 使用.
                  {
                    modelBuilder.Entity<Student>().ToTable("Student");
                    modelBuilder.Entity<Course>().ToTable("Course");
                    modelBuilder.Entity<Enrollment>().ToTable("Enrollment");
                  }
              }
          }

        4.The preceding code changes from the singular {DbSet<Student> Student} to the plural {DbSet<Student> Students}. 
          To make the Razor Pages code match the new DBSet name, 
          make a global change from: {_context.Student.} to: {_context.Students}.
          (註: DbSet<modelClassName> 通常會包含多個實體entities, 程式設計人員習慣將其命名為複數, ex: Students)

        5.{Line 334}: 上面程式碼說明了
          a.Creates a DbSet<TEntity> property for each entity set. In EF Core terminology:
            > An entity set typically corresponds to a database table.
              (註: DbSet<TEntity> 會對應特定資料表.)
            > An entity corresponds to a row in the table.
              (註: 實體則對資料表內的一筆記錄.)
          b.Calls OnModelCreating. OnModelCreating:
            > Is called when SchoolContext has been initialized, 
              but before the model has been locked down and used to initialize the context.
            > Is required because later in the tutorial the Student entity will have references to the other entities.

      f.Program.cs 服務註冊處 (註冊Database服務 & 異常處理方式 & 新增資料庫,若它不存在的話{EnsureCreated} )
        1.ASP.NET Core is built with dependency injection{DI}.
          (註:ASP.NET Core 是建構DI基礎上的)
        
        2.The scaffolding tool automatically registered the context class with the dependency injection container.
          (註:使用database服務, 同樣要註冊才能使用.)
        
        3.The name of the {connection string} is passed in to the context by calling a method on a {DbContextOptions} object. 
          For local development, the ASP.NET Core configuration system reads the connection string 
          from the {appsettings.json} or the {appsettings.Development.json}file.
          (註:連接字串設定值來源.)
        
          {scaffolding tool 自動加入的CODE}
            using Microsoft.EntityFrameworkCore;
            using EFCore_RazorPage.Data;

            // Add services to the container.
            builder.Services.AddDbContext<SchoolContext>(options =>
                options.UseSqlite(builder.Configuration.GetConnectionString("SchoolContextSQLite") ?? 
                  throw new InvalidOperationException("Connection string 'SchoolContextSQLite' not found.")));

          {程式碼: 測試環境DB 與 正式環境DB 如何切換? / 如何切換不同環境}

            builder.Services.AddRazorPages();

            if (builder.Environment.IsDevelopment())
            {   //測試環境: 使用Sqlite
                builder.Services.AddDbContext<SchoolContext>(options =>
                    options.UseSqlite(builder.Configuration.GetConnectionString("SchoolContextSQLite-Development")));
            }
            else
            {   //正式環境: 使用SqlServer
                builder.Services.AddDbContext<SchoolContext>(options =>
                    options.UseSqlServer(builder.Configuration.GetConnectionString("SchoolContextSQLite-Production")));
            }

            var app = builder.Build();

        4.Add the database exception filter
          
          # 請先加入套件 {Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore} 後再服用, 否則會出現下列錯誤.
          error CS1061: 'IServiceCollection' 未包含 'AddDatabaseDeveloperPageExceptionFilter' 的定義
          error CS1061: 'WebApplication' 未包含 'UseMigrationsEndPoint' 的定義

          # 指令碼: dotnet add package Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore --version 6.0.10

          Add {AddDatabaseDeveloperPageExceptionFilter} and {UseMigrationsEndPoint}

          (註1:資料庫異常篩選, 測試環境可顯示, 但正式環境千萬不行)
          (註2:The {Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore} NuGet package 
            provides ASP.NET Core middleware for Entity Framework Core error pages. 
            This middleware helps to detect and diagnose errors with {Entity Framework Core migrations}.
          (註3:The {AddDatabaseDeveloperPageExceptionFilter} provides helpful error information 
            in the development environment for {EF migrations errors}.))

          {程式碼: builder新增服務 + app使用服務內容}

            builder.Services.AddDatabaseDeveloperPageExceptionFilter();

            if(!app.Environment.IsDevelopment())
            {
              ...//正式環境
            }
            else
            {
              //測試環境
              app.UseDeveloperExceptionPage();
              app.UseMigrationsEndPoint();
            }

        5.Cretae Database by EnsureCreated() //常用於開發階段

          程式碼:
            using(var scope = app.Services.CreateScope())
            {
              var services = scope.ServiceProvider;
              var context = services.GetRequiredService<SchoolContext>();
              context.Database.EnsureCreated();
              // DbInitializer.Initialize(context);
            }

            //以上是新增程式碼.
            app.UseHttpsRedirection();
            app.UseStaticFiles();

          > The {EnsureCreated} method takes no action if a database for the context exists. 
            If no database exists, it creates the database and schema.
            
            (註: 如果資料庫已存在, 不管Model內的欄位怎麼異動, 都不會異動database and schema and data.)
            (X)If the database has existed, no matter how columns in model changed, the database and schema and data won't be changed.
            (O)If the database already exists, no matter how the fields in the model change, the database and schema and data will not be changed.

          > EnsureCreated() enables the following workflow for handling data model changes:
            1 Delete the database. Any existing data is lost.
            2 Change the data model. For example, add an EmailAddress field.
            3 Run the app.
            4 EnsureCreated creates a database with the new schema.

          > Later in the tutorial series, 
            the database is deleted that was created by EnsureCreated and migrations is used. 
            A database that is created by EnsureCreated can't be updated by using migrations.
            (註: 在本教程系列的後面部分，
            將刪除由 EnsureCreated 創建的資料庫並使用遷移。
            無法使用遷移更新由 EnsureCreated 建立的資料庫。)
          
          > EnsureCreated 快速產生樣本網站使用, 不會保留任何資料.
            網站穩定後, 資料必須被妥善保存, 要使用 migrations 作資料庫異動

      g.塞入虛擬資料 (觸發時點: 程式啟動時, 所以要去 Program.cs 服務處 註冊)
        程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\DBInitializer.cs

    9.Asynchronous EF methods in ASP.NET Core web apps (非同步程式是 ASP.NET Core and EF Core 預設模式)
      a.Asynchronous programming is the default mode for ASP.NET Core and EF Core.
      b.Asynchronous code does introduce a small amount of overhead at run time. (非同步程式是有成本的)
      c.For low traffic situations, the performance hit is negligible, (低流量時, 效能影響可忽略不計, 甚微)
        while for high traffic situations, the potential performance improvement is substantial. (高流量時, 潛在效能改善是實質可計)

      非同步程式碼樣式:
        public async Task OnGetAsync()
        {
          Students = await _context.Students.ToListAsync();
        }
      
        > The {async} keyword tells the compiler to:
          Generate callbacks for parts of the method body.
          Create the Task object that's returned.
        > The {Task} return type represents ongoing work.
        > The {await} keyword causes the compiler to split the method into two parts. 
          1.The first part ends with the operation that's started asynchronously. 
          2.The second part is put into a callback method that's called when the operation completes.
        > {ToListAsync} is the asynchronous version of the ToList extension method.

      #重點在這: {使用 EFCore 撰寫非同步程式}#
      d.使用 EFCore 撰寫非同步程式
        > 只要會送至資料庫執行的statements, 以非同步方式執行即可.
          例: ToListAsync(取回清單), SingleOrDefaultAsync(取回單筆), FirstOrDefaultAsync(取回第1筆), SaveChangesAsync(儲存變更)
        
        > 並不包括單純改變 IQueryable 的statements.
          例: var students = context.Students.Where(s => s.LastName == "Joy");
        
        > An EF Core context isn't thread safe: don't try to do multiple operations in parallel.
          (註: EFCore context 非執行緒安全, 不要試著平行執行多個作業)
        
        > To take advantage of the performance benefits of async code, 
          verify that library packages (such as for paging) use async 
          if they call EFCore methods that send queries to the database.
          (註: 利用非同步程式帶來的效能優點, 例如換頁時使用非同步)

    10.Performance considerations (效能考量)
      a.通常，網頁不應載入任意數量的行。查詢應使用{分頁}或{限制}方法。
        例如，下列查詢可以使用Take來限制返回的行：
      
      b.程式碼(使用非同步函式, 再限制返回10筆)
        public async Task OnGetAsync()
        {
            Student = await _context.Students.Take(10).ToListAsync();
        }
      
      c.Enumerating a large table in a view could return a partially constructed {HTTP 200} response 
        if a database exception occurs part way through the enumeration.
        (註: 如果在枚舉過程中發生資料庫異常，則枚舉視圖中的大型表可能會返回部分構造的 HTTP 200 回應。)

  Part 2, Razor Pages with EF Core in ASP.NET Core - CRUD (2023/05/12 Completed)
    https://learn.microsoft.com/en-us/aspnet/core/data/ef-rp/crud?view=aspnetcore-7.0

    1.{No repository} 在這個教學中, 沒有使用中介層在UI(Razor Pages) 和 Data access Layer. 
      > 如果有就是MVC.
      > 這個範例著重在 EFCore 的教學, 所以它把 Model 掛在UI{page model classes}下面使用. 跟之前的 WebForm 類似.
    
    2.(OK)Update the Details page, 把 {Enrollment資料} 加到 Students\Details頁面.

      var student = await _context.Students
            .Include(s => s.Enrollments)
            .ThenInclude(e => e.Course)
            .AsNoTracking()
            .FirstOrDefaultAsync(m => m.ID == id);

      > The {Include} and {ThenInclude} methods cause the context to load the Student.Enrollments 
        navigation property, 
        and within each enrollment the {Enrollment.Course} navigation property.
        註1: {Include} 載入 Student.Enrollments 瀏覽屬性(navigation property) 
        註2: {ThenInclude} 載入 Student.Enrollments 中 Enrollment.Course 瀏覽屬性(navigation property)

      > The {AsNoTracking} method improves performance in scenarios 
        where the entities returned are not updated in the current context.
        註: {AsNoTracking} 改善效率, 針對毋須更新的實體停止追蹤狀態
  
      > Ways to read one entity {讀取1筆實體的方式}
          
          {FirstOrDefaultAsync} 讀取1筆實體 & {關聯資料} 的最好方式
          {FindAsync} 讀取1筆實體 & {毋須關聯資料} 的最好方式

        1.{FirstOrDefaultAsync} 找不到回傳 {null}, 找到多筆回傳 {第1筆}
          This method returns {null} if nothing is found; 
          otherwise, it returns {the first row} found that satisfies the query filter criteria

        2.{SingleOrDefaultAsync} 找到多筆回傳 {異常}, 而且它會試著存取多筆資料, 這些額外工作是不需要的
          Throws an exception if there's more than one entity that satisfies the query filter. 
          To determine if more than one row could be returned by the query, 
          SingleOrDefaultAsync tries to fetch multiple rows. 
          This extra work is unnecessary if the query can only return one entity, 
          as when it searches on a {unique key}.

        3.{FindAsync} 沒有讀取 navigation properties 需求時, {FindAsync}是最有效率.
          Finds an entity with the {primary key} (PK). 
          If an entity with the PK is being tracked by the context, 
          it's returned without a request to the database. 
          This method is optimized to look up a single entity, but {you can't call Include with FindAsync}
      
      > Route data vs. query string
      https://localhost:7164/Students/Details?id=1 預設使用 query string, 在 XX.cshtml @page 後面是空白的.
      https://localhost:7164/Students/Details/1 使用 Route data, 在 XX.cshtml @page 後面 => 加上 "{id:int?}" 即可

    3.(OK)Update the Create page 

      var emptyStudent = new Student();
      if(await TryUpdateModelAsync<Student>(
          emptyStudent,
          "student", //不分大小寫
          s => s.FirstName, s => s.LastName, s => s.EnrollmentDate))
      {
          _context.Students.Add(emptyStudent);
          await _context.SaveChangesAsync();
          return RedirectToPage("./Index");    
      }

      > The {TryUpdateModelAsync} method:
        * Uses the posted form values from the PageContext property in the PageModel.
        * Updates only the properties listed (s => s.FirstMidName, s => s.LastName, s => s.EnrollmentDate).
        * Looks for form fields with a "student" prefix. 
          For example, Student.FirstMidName. {It's not case sensitive}.
          註: 尋找 "student" 開頭的指定欄位值

        * Uses the {model binding} system to convert form values from strings to the types in the Student model. 
          For example, EnrollmentDate is converted to DateTime.
          註: 再利用 {model binding} system 將 指定欄位值(字串) 轉為 Student 欄位型態後, 
            再塞入 emptyStudent

    4.(OK)避免OVERPOSTING攻擊的方式(To protect from overposting attacks) (註: 防禦 OVERPOSTING攻擊 的方式 {TryUpdateModelAsync} or {View model})
      see https://aka.ms/RazorPagesCRUD

      > 方式一: Using {TryUpdateModelAsync} to update fields with posted values is a {security best practice} because it prevents overposting
        範例程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Students\Create.cshtml.cs 的 OnPostAsync() 函式.

      > 方式二: Using {View model}, The view model contains only the properties needed for the UI page.
        範例程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\StudentVM.cs
        範例程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Students\Create.cshtml.cs 的 OnPostAsync2() 函式.

      > 兩相比較下
        方式二: Using {View model} 比較直覺, 直接把 ViewModel 抓回來的值塞入 context 即可, 語法相對單純.
        方式一: Using {TryUpdateModelAsync} 看太不懂, 存檔時要逐一指定屬性值 
          TryUpdateModelAsync<TModel>(TModel, String, IValueProvider)
          
      > {TryUpdateModelAsync} 並沒有存檔DB哦 !!
        註1: 使用 valueProvider 和 prefix 更新指定的 model 實例
        註2: 白話來說, 就是把頁面拿到的值放入 model 實例中, 再使用 {_context.SaveChangesAsync()} 塞回DB.
        註3: 放入 model 實例後, _context再根據 {id是否有值 & Entity States}, 決定它要作新增、修改或刪除.

        例: TryUpdateModelAsync<Student>(emptyStudent,"student",
              s => s.FirstName, s => s.LastName, s=> s.EnrollmentDate, s => s.Phone //指定要寫入DB的頁面屬性.)
            _context.Student.Add(emptyStudent);
            await _context.SaveChangesAsync();

    5.(OK)Update the Edit page, 
      > OnPostAsync() <= 這種寫法不能放在Edit頁面, 會出現編輯頁可新增的靈異現象
      > OnPostAsync(int id) <= 正常寫法

      > OnGetAsync(int? id) 的存取效率
        * FirstOrDefaultAsync(m => m.ID == id), 有必要 include 相關資料時, 只能用這種(預設)
        * FindAsync(id), 不用 include 相關資料, 用 FindAsync(id) 更有效率.

    6.(OK)Entity States(實體狀態)
      > The database context keeps track of whether entities in memory are in sync with their corresponding rows in the database. 
        This tracking information{Entity States(實體狀態)} determines what happens 
        when {SaveChangesAsync} is called.
      
      > An entity may be in one of the following states:
        * {Added}: The entity doesn't yet exist in the database. 
          The SaveChanges method issues an {INSERT statement}.
        
        * {Unchanged}: No changes need to be saved with this entity. 
          An entity has this status when it's read from the database.

        * {Modified}: Some or all of the entity's property values have been modified. 
          The SaveChanges method issues an {UPDATE statement}.

        * {Deleted}: The entity has been marked for deletion. 
          The SaveChanges method issues a {DELETE statement}.

        * {Detached}: The entity isn't being tracked by the database context.

      > (對桌面應用程式而言)In a desktop app, state changes are typically set automatically. 
        An entity is read, changes are made, and the entity state is automatically changed to Modified. 
        Calling {SaveChanges} generates a SQL {UPDATE statement} that updates only the changed properties.

      > (對網頁應用程式而言)In a web app, the DbContext that reads an entity 
        and displays the data is disposed after a page is rendered. 
        
        When a page's {OnPostAsync method} is called, 
        a new web request is made and with a new instance of the DbContext. 
        Rereading the entity in that new context simulates desktop processing.

    7.(OK)Update the Delete page(增加 Logging & {saveChangesError}參數, 防止刪除失敗時{OnPostAsync}, 重回初始畫面{OnGetAsync})
      程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Students\Delete.cshtml.cs
      程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Students\Delete.cshtml

      > Adds Logging.
      > Adds the optional parameter {saveChangesError} to the OnGetAsync method signature. 
        {saveChangesError} indicates whether the method was called after a failure to delete the student object.
      
      > The delete operation might fail because of transient network problems. 
      > Transient network errors are more likely {when the database is in the cloud}. 
      > The {saveChangesError} parameter is false 
        when the Delete page OnGetAsync is called from the UI. 
      > When OnGetAsync is called by OnPostAsync because the delete operation failed, 
        the saveChangesError parameter is true.

    8.(OK)RedirectToPage vs RedirectToAction 的差異
      > RedirectToPage, 切換頁面
        例: return RedirectToPage("./Index");

      > RedirectToAction, 切換頁面外, 還會加上參數, 讓頁面執行Action
        例: return RedirectToAction("./Delete", new {id, saveChangesError = true});

  Part 3, Razor Pages with EF Core in ASP.NET Core - Sort, Filter, Paging
    程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Students\Index.cshtml.cs
    程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Students\Index.cshtml

    1.Add sorting (點選標題欄可切換{由小至大}或{由大至小}的資料排序, 修改異動學生實體的 Index.cshtml & Index.cshtml.cs)
    
      > The method uses {LINQ to Entities} to specify the column to sort by.     

      > When an IQueryable is created or modified, no query is sent to the database. 
      > The query isn't executed until the IQueryable object is converted into a collection. 
        IQueryable are converted to a collection by calling a method such as {ToListAsync}. 

        程式碼:
          IQueryable<Student> studentsIQ = from s in _context.Students select s;
          studentsIQ = studentsIQ.OrderByDescending(s => s.LastName); {這時候查詢還未送至 DB}

          public IList<Student> Students { get;set; } = default!;
          Students = await studentsIQ.AsNoTracking().ToListAsync(); {真正觸發DB查詢的時點}

      > Add column heading hyperlinks to the Student Index page {網頁加上連接}
      
    2.Add filtering
      > A {text box} and a {submit button} is added to the Razor Page. 
      > The text box supplies a {search string} on {the first or last name}.
      > The {page model is updated} to use the text box value.

    3.IQueryable(不分大小寫) vs. IEnumerable(區分大小寫)
      > When Contains is called on an {IQueryable} object, the {database implementation} is used.
          In SQL Server, 
          Contains case-sensitivity is determined by the collation setting of the SQL Server instance. 
          SQL Server defaults to {case-insensitive}.

      > When Contains is called on an {IEnumerable} collection, the {.NET Core implementation} is used. 
          the .NET Framework implementation of Contains performs a {case-sensitive} comparison by default
          SQLite defaults to {case-sensitive}. 
          (註: C# & SQLite 預設都是區分大小寫, 而使用 {IEnumerable}, 它會採 {.NET Core implementation})

      > 如何使用 IEnumerable(區分大小寫) 或 SQLite 下, 達成(不分大小寫)的目的呢？
          Where(s => s.LastName.ToUpper().Contains(searchString.ToUpper()));

          不過, 呼叫 ToUpper() 會有成本損耗.
          There's a performance penalty for calling ToUpper. 
          The ToUpper code adds a function in the WHERE clause of the TSQL SELECT statement. 
          The added function prevents the optimizer from using an index. 
          Given that SQL is installed as case-insensitive, 
          {it's best to avoid the ToUpper call when it's not needed}.

      GET or POST

        > The following preceding code uses the <form> tag helper to add the search text box and button. 
          By default, the <form> tag helper submits form data with a POST. 
          With POST, the parameters are passed in the HTTP message body and not in the URL. 
        > When HTTP GET is used, the form data is passed in the URL as query strings. 
        > Passing the data with query strings enables users to bookmark the URL. 
        > The W3C guidelines recommend that GET should be used when the action doesn't result in an update.
          註: 
            1.預設, the <form> tag helper submits form data with a POST. 
            2.使用 POST, 參數會包在 HTTP message body and not in the URL 作傳遞
            3.使用 GET, 參數會利用 URL內的 query strings 作傳遞
            4.W3C建議沒有更新時, 使用 GET.
        
        程式碼: 
        <form asp-page="./Index.cshtml" method="get">
            <div class="form-actions no-color">
                <p>
                    Find by name:
                    <input type="text" name="SearchString" value="@Model.CurrentFilter">
                    <input type="submit" value="Search" class="btn btn-primary">
                    <a asp-page="./Index.cshtml">Back to full list</a>
                </p>
            </div>
        </form>

    3.1 IQueryable 基於效能, 篩選作業發生DB端, 再回傳結果 (效能較佳)
    3.2 IEnumerable 則是所有資料從DB端回傳後, 再作處理.

    4.Add paging
      程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\PaginatedList.cs
      > The {CreateAsync} method is used to create the PaginatedList<T>. 
      > A constructor can't create the PaginatedList<T> object; 
      > constructors can't run asynchronous code.
      註: 從程式碼中, 看出只有 {CreateAsync} method 可新增 {PaginatedList<T>}

    4.1 新增 PaginatedList 類別, 實作分頁功能. 它會利用 "Skip" & "Take" 作業篩選DB資料, 再回傳結果.
    4.2 新增 {上一頁} & {下一頁} 兩個按鈕.
    4.3 PaginatedList 類別中, 每頁筆數記錄在 configuration 中, 方便調整. {appsettings.json}
      > 使用 Microsoft.Extensions.Configuration 讀取 configuration

    5.Grouping (新增 about 頁面 & ViewModel, 呈現 Grouping 資料)
      > Create a view model for the data used by the About page.
      > Update the About page to use the view model.

      > 程式碼: 
        C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\SchoolViewModels\EnrollmentDateGroup.cs
        C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\About.cshtml
        C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\About.cshtml.cs

  Part 4, Razor Pages with EF Core in ASP.NET Core - migrations(正式資料庫移轉, 資料庫綱要異動)

    > The {EF Core Migrations} feature solves this problem 
      by enabling EF Core to update the DB schema
      instead of creating a new database. //利用{EF Core Migrations}更新DBSchema, 而不是新增DB

    > Rather than dropping and recreating the database when the data model changes, 
      migrations updates the schema and retains existing data.

    > Sqlite在{EF Core Migrations}上的限制
      If a migration is created to remove a column, //移除欄位不支援
      the {ef migrations add} command succeeds //成功
      but the {ef database update} command fails. //失敗

    > 因應Sqlite在{EF Core Migrations}上的限制, 遭遇下列情況時, 針對 Up and Down 函式作程式改寫      
      * Creating a new table.
      * Copying data from the old table to the new table.
      * Dropping the old table.
      * Renaming the new table.

    1.Drop the database

      dotnet tool install --global dotnet-ef //安裝 EFCore 工具

      dotnet ef database drop --force //刪除資料庫
        Dropping database 'main' on server 'CU-Development.db'.
        Database 'main' did not exist, no action was taken.

    2.Create an initial migration

      > dotnet ef migrations add InitialCreate //第1次建置
      > dotnet ef database update
          利用migrations移轉來新增DB
          1.多一個資料表 "__EFMigrationsHistory", 除了Model應對應的資料表外.
          2.多一個資料庫 "EFCore_RazorPage.Data.db", 內容卻是空的??

      > Remove {EnsureCreated}
        EnsureCreated doesn't create a {migrations history table} and so can't be used with migrations. 
        It's designed for testing or rapid prototyping where the database is dropped and re-created frequently.

        @Program.cs
          // context.Database.EnsureCreated();

    3.Up and Down methods
      > The EF Core {migrations add} command generated code to create the database. 
      > This migrations code is in the {Migrations\<timestamp>_InitialCreate.cs} file. 
      > The {Up} method of the {InitialCreate} class creates the database tables that correspond to the data model entity sets. 
      > The {Down} method deletes them, as shown in the following example:

        指令碼: dotnet ef migrations add InitialCreate //自動產生程式碼, Create Table or Drop Table用
        指令碼: dotnet ef database update //執行上一個指令碼產生的程式碼內容.

      > dotnet ef migrations add "<自行命名本次DB移轉的目的>"
        例: dotnet ef migrations add AddDepartmentTable //新增部門資料表

    4.The migrations history table
        
      > TableName: __EFMigrationsHistory
        * 用途: 記錄移轉歷史

    5.The data model snapshot
      > 用途: 記錄當下的data model, 以備還原移轉時使用
      > 位置: Migrations/SchoolContextModelSnapshot.cs
        * 例: Migrations/<ContextName>ModelSnapshot.cs
        
      > Because the snapshot file tracks the state of the data model, 
          a migration cannot be deleted by deleting the <timestamp>_<migrationname>.cs file. 
        To back out the most recent migration, use the {migrations remove} command. 
        {migrations remove} deletes the migration and ensures the snapshot is correctly reset.
            
        * 例: dotnet ef migrations remove AddDepartmentTable

      > See {Resetting all migrations} to remove all migrations.
        https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/managing?tabs=dotnet-core-cli#resetting-all-migrations

    6.Applying migrations in production
      > We recommend that production apps not call {Database.Migrate} at application startup.
        //Migrate 不適用於正式環境
        
      > Database migration should be done as part of deployment, and in a controlled way. 
      > Production database migration approaches include:
        * Using migrations to create SQL scripts and using the SQL scripts in deployment.
        * Running dotnet ef database update from a controlled environment.
          //正式環境DB資料異動, 應該在可控環境下, 產生 SQL scripts 的方式來執行.

        https://learn.microsoft.com/en-us/ef/core/cli/dotnet#dotnet-ef-migrations-script

  Part 5, Razor Pages with EF Core in ASP.NET Core - Data Model(更接近現實世界的資料關係)

    In this tutorial:
      > More entities and relationships are added.
        * OfficeAssignment(辦公室地點配置)-新增
        * Department(部門)-新增
        * Instructor(職員)-新增
        * Course(課程)-異動
      > The data model is customized by 
        specifying formatting, //指定格式
        validation, //驗證
        and database mapping rules. //對應關係

      1.The Student entity

      The {DisplayFormat} attribute can be used by itself. 
      It's generally a good idea to use the {DataType} attribute with the DisplayFormat attribute. 
      The {DataType} attribute conveys the semantics of the data as opposed to how to render it on a screen. 
      The {DataType} attribute provides the following benefits that are not available in DisplayFormat:
        * The browser can enable HTML5 features. For example, show a calendar control, the locale-appropriate currency symbol, email links, and client-side input validation.
        * By default, the browser renders data using the correct format based on the locale.
      註: 
        1.{DisplayFormat} & {DataType} 可合併使用
        2.{DisplayFormat} 重點在於如何呈現, 例:日期格式會依伺服器的時區設定, 自動切換

      2.The Instructor Entity

      寫成多行
      [DataType(DataType.Date)] //指定Table欄位更具體的型態, 例: DataType.EmailAddress
      [DisplayFormat(DataFormatString ="{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)] //指定顯示資料格式
      [Display(Name = "入學日")]

      寫成單行, 也可以
      [DataType(DataType.Date),
      DisplayFormat(DataFormatString ="{0:yyyy-MM-dd}", ApplyFormatInEditMode = true),
      Display(Name = "入學日")]

      3.The OfficeAssignment entity

      > The Key attribute
      [Key]
      The [Key] attribute is used to identify a property as the primary key (PK) 
      when the property name is something other than {classnameID} or {ID}.

      [Key]
      public int InstructorID { get; set; } //因為 OfficeAssignment entity 的 (PK)是 InstructorID, 不符預設規範, 所以要指定[Key]

      > The Instructor navigation property
        * The {Instructor.OfficeAssignment} navigation property can be null 
          because there might not be an OfficeAssignment row for a given instructor. 
          An instructor might not have an office assignment.
          
          註: Instructor類別內的OfficeAssignment navigation property 可以是null

        * The {OfficeAssignment.Instructor} navigation property will always have an instructor entity 
          because the {foreign key} InstructorID type is int, a non-nullable value type. 
          An office assignment can't exist without an instructor.

          註: OfficeAssignment類別內的 Instructor navigation property 不能是null,
            InstructorID 是INT, 不能為null, 
            所以每筆 OfficeAssignment 實體必須要有 instructor才能存在.

          public class OfficeAssignment
          {
            [Key]
            public int InstructorID {get;set;}
            public Instructor Instructor {get;set;}
          }

      4.The Course Entity

      > EF Core doesn't require a foreign key(FK) property for a data model 
        when the model has a navigation property for a related entity. 
      > EF Core automatically creates FKs in the database wherever they're needed. //如果有需要, 會自動產生FK
      > EF Core creates {shadow properties} for automatically created FKs. //利用{shadow properties}, 自動產生FK
        However, explicitly including the FK in the data model 
        can make updates simpler and more efficient. //明確加上FK的好處: 使update 更簡單, 有效率.
      > For example, consider a model where the FK property {DepartmentID is not included}. 
        When a course entity is fetched to edit:

          * The Department property is null if it's not explicitly loaded.
          * To update the course entity, the Department entity must first be fetched.

        When the FK property DepartmentID is included in the data model, 
          there's no need to fetch the Department entity before an update.

        // 當有更新 "Course" 實體需求時,
          * FK property {DepartmentID is not included}, //利用{shadow properties}, 自動產生FK, 再抓
            the Department entity must first be fetched.
          * FK property {DepartmentID is included}, //直接使用 FK property {DepartmentID} 就能判斷
            there's no need to fetch the Department entity before an update.

      > The DatabaseGenerated attribute
        * The [DatabaseGenerated(DatabaseGeneratedOption.None)] attribute specifies 
          that the PK is provided by the application rather than generated by the database.

        * 程式碼:
          [DatabaseGenerated(DatabaseGeneratedOption.None)]
          [Display(Name = "Number")]
          public int CourseID { get; set; }

        * The DatabaseGenerated attribute can also be used to {generate default values}. //也能用來產生預設值
          For example, the database can automatically generate a date field to record the date a row was created or updated. 
          For more information, see {Generated Properties}.

        * 程式碼:
          [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
          public DateTime Inserted { get; set; }

          [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
          public DateTime LastUpdated { get; set; }

      > Foreign key and navigation properties

        * A course is assigned to one department, //one - one關係, 1門課程只能屬於1個系
          so there's a DepartmentID FK and a Department navigation property.

        * 程式碼:
          public int DepartmentID { get; set; } //DepartmentID FK
          public Department Department { get; set; } //Department navigation property.

        * A course can have any number of students enrolled in it, //one - many 關係, 1門課可以被多名學生選擇
          so the Enrollments navigation property is a collection:

        * 程式碼:
          public ICollection<Enrollment> Enrollments { get; set; }

        * A course may be taught by multiple instructors, //one - many 關係, 1門課可以由多名老師授課
          so the Instructors navigation property is a collection:

        * 程式碼:
          public ICollection<Instructor> Instructors { get; set; }

      5.The Department entity

      > The Column attribute
        * change column name mapping //指定欄位名稱
        * change SQL data type mapping //指定欄位型態
        * {Column mapping is generally not required}. //一般而言, {Column mapping}是不需要的, EFCore會自動挑選最合適的.
          EF Core chooses the appropriate SQL Server data type 
          based on the CLR type for the property. 
        * The CLR {decimal} type maps to a SQL Server {decimal} type.
          Budget is for currency, and the {money} data type is more appropriate for currency.
        
        * 程式碼:
          [Column(TypeName="money")]
          public decimal Budget { get; set; }

      > Foreign key and navigation properties
        * A department may or may not have an administrator. //所以用 nullable, FK
        * An administrator is always an instructor. //所以用 Instructor 作為 Administrator的型別, navigation properties
          Therefore the InstructorID property is included as the FK to the Instructor entity.

        * 程式碼:
          public int? InstructorID { get; set; } //{允許空值 FK}, 就不會有 {cascade delete} 的問題
          public Instructor Administrator { get; set; }

        * A department may have many courses, so there's a Courses navigation property:
        * 程式碼:
          public ICollection<Course> Courses { get; set; }

        =={cascade delete}===============================================================
        * 注意1: By convention, EF Core enables {cascade delete} 
          for {non-nullable FKs} and {for many-to-many relationships}. 
          //EFCore 預設會採取 {遞迴刪除} 作法, 針對 {非允許空值 FK} & {多對多關係} 的情況.

        * 注意2: This default behavior can result in {circular cascade delete rules}. 
          Circular cascade delete rules cause an exception when a migration is added.
          //採取 {遞迴刪除} 作法, 當移轉加入時會產生例外.

        * 例: 
          public int InstructorID { get; set; } //{非允許空值 FK}, EFCore 預設會採取 {遞迴刪除} 作法
          public Instructor Administrator { get; set; }
          
          In that case, the department would be deleted 
          when the instructor assigned as its administrator is deleted.
          //在這個情況下, 當指派為管理員的講師被刪除, 則部門會一併刪除.

        * 如何限制 {遞迴刪除} 引發不合常理的情況發生？
          protected override void OnModelCreating(ModelBuilder modelBuilder)
          {
            modelBuilder.Entity<Department>()
              .HasOne(d => d.Administrator)
              .WithMany()
              .OnDelete(DeleteBehavior.Restrict)
          }

      > The Enrollment foreign key and navigation properties
        * An enrollment record is for one course taken by one student.

        * 程式碼: 
          public class Enrollment
          {
            public int EnrollmentID { get; set; } //PK
            
            [DisplayFormat(NullDisplayText = "No grade")]
            public Grade Grade { get; set; }

            public int CourseID { get; set; } //FK
            public Course Course { get; set; } //navigation properties
            
            public int StudentID { get; set; } //FK
            public Student Student { get; set; }//navigation properties
          }
          
      6.Many-to-Many Relationships

      > There's a {many-to-many relationship} between the {Student} and {Course} entities.
        * {Student} entities 內, 沒有與 {Course} entities 建立關聯
        * {Course} entities 內, 沒有與 {Student} entities 建立關聯
        * 透過 {Enrollment} entities , 將 {Student} and {Course} entities 建立出 {many-to-many relationship}
        * {With payload} means that the Enrollment table contains additional data besides FKs for the joined tables.
          
          //{With payload} 表示除了建立{many-to-many relationship}所需的{FK}外, 
            還包含了額外的資料, 以{Enrollment} entities為例, 就是 Grade 欄位.

        * If the Enrollment table didn't include grade information, 
          it would only need to contain the two FKs, CourseID and StudentID. 
          A many-to-many join table without payload is sometimes called a {pure join table} (PJT).

        * The {Instructor} and {Course} entities have a many-to-many relationship using a (PJT).
          a.{Instructor} entities 內有 ICollection<Course>
          b.{Course} entities 內有 ICollection<Instructor>
          c.並且在 DBContext OnModelCreating 內, 建立{many-to-many relationship}

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
              modelBuilder.Entity<Course>().ToTable(nameof(Course))
                .HasMany(c => c.Instructors)
                .WithMany(i => i.Courses);
            }
            
      7.Update the database context {dotnet ef migrations add Add_Three_Entity & dotnet ef database update, 不要忘記作, 否則DB不會動.}

      > Update Data/SchoolContext.cs with the following code:
        * 程式碼: 
          using ContosoUniversity.Models;
          using Microsoft.EntityFrameworkCore;

          namespace ContosoUniversity.Data
          {
              public class SchoolContext : DbContext
              {
                  public SchoolContext(DbContextOptions<SchoolContext> options) : base(options)
                  {
                  }

                  public DbSet<Course> Courses { get; set; }
                  public DbSet<Enrollment> Enrollments { get; set; }
                  public DbSet<Student> Students { get; set; }
                  public DbSet<Department> Departments { get; set; }
                  public DbSet<Instructor> Instructors { get; set; }
                  public DbSet<OfficeAssignment> OfficeAssignments { get; set; }

                  protected override void OnModelCreating(ModelBuilder modelBuilder)
                  {
                      modelBuilder.Entity<Course>().ToTable(nameof(Course))
                          .HasMany(c => c.Instructors)
                          .WithMany(i => i.Courses);
                      modelBuilder.Entity<Student>().ToTable(nameof(Student));
                      modelBuilder.Entity<Instructor>().ToTable(nameof(Instructor));
                  }
              }
          }

        * dotnet run 重新執行, 發現 DB 根本沒變.
        * delete CU-Development.db, 再 dotnet run 重新執行, 出現下列錯誤: 
          Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1: 'no such table: Student'.

        * 發現更新資料庫Schema, 不能直接砍DB, 而要用先執行移轉, 再更新資料庫Schema & 保留資料

          a.先執行 "dotnet ef database update" , 把最近1次的移轉Schema救回來. (OK, 成功)
          b.dotnet run, 再塞入少量資料. (Error, Data Model已變更, 前一版可以生DB, 但跑不起來) 

          c.dotnet ef migrations add Add_Three_Entity (OK, 使用新的 database context, 產生{更新 DB 所需的程式碼})
          d.dotnet ef database update (OK, 利用{更新 DB 所需的程式碼}, 實際更新DB結構)

          e.配合新的Table Schema, 調整 DbInitializer.Initialize(context)內容; 
            //塞入少量資料, 因為 資料庫Schema 改變了, 塞入欄位數量及值也要跟著調整, 不然會新增失敗.

      8.Fluent API alternative to attributes

        > 相較於 the attribute of Data Model, Fluent API是另一種替代作法.
          * Fluent API 之所以稱為 "fluent", 因為它經常把方法寫成單一敘述句.

        > The OnModelCreating method in the preceding code uses the {fluent API} to configure EF Core behavior. 
          The API is called "fluent" because it's often used by stringing a series of method calls together 
          into a single statement. The following code is an example of the fluent API:

          * 程式碼寫在 DBContext內, 併用 Fluent API:
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Entity<Blog>()
                    .Property(b => b.Url)
                    .IsRequired();
            }

          * 程式碼寫在 data model內, 變成
            public class Blog
            {
              [Required]
              public string URL {get;set;}
            }

        > However, the fluent API can specify most of the {formatting}, {validation}, and {mapping rules} 
          that can be done with attributes.
          * Attributes and the fluent API can be mixed //Attributes and the fluent API設定方式, 兩者可以混用
          * 但某些設定只能在其中一類內完成:
            ex. 指定複合鍵(composite PK), 只能用 fluent API.
            ex. 指定欄位最小長度(MinimumLength),只能用 Attributes.

        > 使用 Attributes 或 the fluent API 的建議方式
          * 挑選其中一種方法
          * 盡可能一致地使用所選方法。

      9.Seed the database

        > 配合全新的Table Schema, 調整DbInitilizer.cs, 以塞入少量資料
          * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\DbInitializer.cs

      10.Apply the migration or drop and re-create (EFCore - 正式環境用: 產生改版移轉, 再重新產生DB)
      
        # 注意: How to deal with database schema changed by Entity Framework Core #
        > 總結: 使用 {Entity Framework Core 工具} 時, 當資料庫綱要(Schema)異動後, 如何處理？
          * 資料庫綱要異動, 一定會修改 database context
          * {dotnet ef migrations add "自訂本次異動摘要"} , 自動產生DB異動用程式碼
          * {dotnet ef database update}, 實際更新DB結構, 
              未執行{dotnet ef database update}, DB結構不會有任何異動.
        
        > Apply the migration(複雜, 適用於正式環境, 保留Table Schema & Data)
          * dotnet ef migrations add Add_Three_Entity (OK, 使用新的 Data Model, 產生{更新 DB 所需的程式碼})
          * dotnet ef database update (OK, 利用{更新 DB 所需的程式碼}, 實際更新DB結構)
          * 配合新的Table Schema, 調整 DbInitializer.Initialize(context)內容; 
            //塞入少量資料, 因為 資料庫Schema 改變了, 塞入欄位數量及值也要跟著調整, 不然會新增失敗.

      11.Drop and re-create the database (EFCore - 測試環境用: 直接砍DB, 重新產生初版移轉, 再重新產生DB)

        > drop and re-create(快速, 適用於開發環境, 直上Table Schema & 最新Data)
          * Delete the Migrations folder. 
          * dotnet ef database drop --force
            dotnet ef migrations add InitialCreate
            dotnet ef database update

  Part 6, Razor Pages with EF Core in ASP.NET Core - Read Related Data
    
    > This tutorial shows how to read and display related data. //相關資料
    > Related data is data that EF Core loads into navigation properties. //EFCore 透過 navigation properties 載入 相關資料

    1.Eager, explicit, and lazy loading    
      
      https://learn.microsoft.com/en-us/ef/core/querying/related-data/

      > {Eager loading} means that the related data is loaded from the database as part of the initial query.
          Entity Framework Core will {automatically fix-up navigation properties to any other entities} 
          that were previously loaded into the context instance. 
          So even if you don't explicitly include the data for a navigation property, the property may still be populated 
          if some or all of the related entities were previously loaded.
          //機制: 自動鎖定navigation properties到之前已載入的context instance,
            因此, 儘管沒有明確 include navigation property資料, property資料依舊會被塞入.
            如果, 相關實體之前已被載入.

      > {Explicit loading} means that the related data is explicitly loaded from the database at a later time.
          //表示稍後從資料庫中顯式載入相關數據。

      > {Lazy loading} means that the related data is transparently loaded from the database 
          when the navigation property is accessed.
          //表示訪問navigation property資料時, 再從資料庫中透明地載入相關數據, 
          //注意: 可能會有效能上的負擔.

    2.Create Course pages

      > To display the name of the assigned department for a course:
        * Load the related Department entity into the {Course.Department} navigation property.
        * Get the name from the {Department entity's Name} property.

      > Scaffold Course pages
        * 指令碼: "dotnet aspnet-codegenerator razorpage -m Course -dc SchoolContext -udl -outDir Pages\Courses --referenceScriptLibraries"
        * 使用上述指令碼, 自動產生頁面 & 相關程式碼
        * Open Pages/Courses/Index.cshtml.cs and examine the OnGetAsync method.
          
          public async Task OnGetAsync()
          {
              if (_context.Courses != null)
              {
                  Course = await _context.Courses
                  .Include(c => c.Department).ToListAsync(); //其中 Include 指定 {Eager loading}
              }
          }

      > Display the department name
        
        * Update Pages/Courses/Index.cshtml.cs with the following code:
        * .AsNoTracking() //No-tracking queries are useful when the results are used in a read-only scenario
          //資料唯讀時, 加上 .AsNoTracking() , 執行會更有效率.
          //調整公開變數名稱, 從 Course 改為 Courses.

          {修改前}:
            public IList<Course> Course { get;set; } = default!; //object 的 default = null, 則 default! = 給定預設值
            public async Task OnGetAsync()
            {
                if (_context.Courses != null)
                {
                    Course = await _context.Courses
                    .Include(c => c.Department).ToListAsync();
                }
            }
          
          {修改後}:
            public IList<Course> Courses { get;set; }
            public async Task OnGetAsync()
            {
                Course = await _context.Courses
                    .AsNoTracking() //No-tracking queries are useful when the results are used in a read-only scenario
                    .Include(c => c.Department)
                    .ToListAsync();
            }

        * Update Pages/Courses/Index.cshtml with the following code:
          //配合後端公開變數名稱調整{從 Course 改為 Courses.}, 前端直接套用後端變數處也要更動.
          //By default, primary keys aren't scaffolded because normally they're meaningless to end users. 
            However, in this case the primary key is meaningful.

      > Loading related data with {Select} (Include & Select 都是載入相關資料的方法)
        * The OnGetAsync method loads related data with the {Include} method.
        * The {Select} method is an alternative that loads only the related data needed.
          //For {single items}, like the Department.Name it uses a {SQL INNER JOIN}.
            @* 
              1.對單一項目而言, 可以在同一個Connection內, inner join 所需資料進來
              2.The preceding code doesn't return any entity types, therefore no tracking is done.
            *@
          //For {collections}, it uses another database access, but so does the {Include} operator on collections
            @* 對集合資料而言, 必須開另一個Connection內, 方式和 {Include} 相同 *@
        
        * 實作方式:
          {後端: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\SchoolViewModels\CourseViewModel.cs}
          //新增CourseViewModel
            @* 程式碼 *@
            public class CourseViewModel
            {
                public int CourseID { get; set; }
                public string Title { get; set; }
                public int Credits { get; set; }
                public string DepartmentName { get; set; }
            }

          {後端: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Index.cshtml.cs}
            @* 程式碼微調 *@
            public IList<CourseViewModel> CourseVM { get; set; } //

            public async Task OnGetAsync()
            {
                if (_context.Courses != null)
                {
                    //方式一: 使用.Include
                    Courses = await _context.Courses
                    .AsNoTracking()
                    .Include(c => c.Department)
                    .ToListAsync();

                    //方式二: 使用.Select未回傳任何entity型態, 沒有作追蹤, 也就毋須加上 .AsNoTracking()
                    CourseVM = await _context.Courses
                    .Select(p => new EZCore_RazorPage.Models.SchoolViewModels.CourseViewModel
                    {
                        CourseID = p.CourseID,
                        Title = p.Title,
                        Credits = p.Credits,
                        DepartmentName = p.Department.Name //單筆時, 使用INNER JOIN IN SAME DB Connection.
                    }).ToListAsync();
                }    
            }
          
          {前端: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Index.cshtml}
          //所有 {Courses} 須改為 {CourseViewModel}

    3.Create Instructor pages (更複雜的顯示, 講師清單[Instructor] => 指定講師授課清單[Course] => 指定選課學生及成績清單)
    
      > 資料間的關聯性
        * The list of instructors displays related data from the {OfficeAssignment} entity (Office in the preceding image). 
          The Instructor and OfficeAssignment entities are in a {one-to-zero-or-one relationship}. //1對0關聯性
          {Eager loading} is used for the OfficeAssignment entities. 
          {Eager loading} is typically {more efficient} when {the related data needs to be displayed}. 
            //相關資料必須被呈現, 以{Eager loading}方式較有效率的.
          In this case, office assignments for the instructors are displayed.

        * When the user selects an {instructor}, related {Course} entities are displayed. 
          The {Instructor} and {Course} entities are in a {many-to-many relationship}. 
          Eager loading is used for the Course entities and their related Department entities. 
          In this case, {separate queries might be more efficient} 
            because only courses for the selected instructor are needed. 
            //限定呈現指定講師的課程, 屬1對多關聯性, 以{separate queries}方式較有效率的.
          This example shows how to use eager loading for navigation properties in entities 
            that are in navigation properties.

        * When the user selects a course, related data from the Enrollments entity is displayed. 
          In the preceding image, student name and grade are displayed. 
          The Course and Enrollment entities are in a {one-to-many relationship}.

      > Create a View Model(Single query)
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\SchoolViewModels\InstructorIndexData.cs
        * Instructors
        * Courses
        * Enrollments

      > Scaffold Instructor pages
        * 指令碼: dotnet aspnet-codegenerator razorpage -m Instructor -dc SchoolContext -udl -outDir Pages\Instructors --referenceScriptLibraries

      > Get Instructor's Related Data into InstructorIndexData
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Index.cshtml.cs

        {修改前}
          public IList<Instructor> Instructor { get;set; } = default!;
          public async Task OnGetAsync()
          {
              if (_context.Instructors != null)
              {
                  Instructor = await _context.Instructors.ToListAsync();
              }
          }

        {修改後}
          public InstructorIndexData InstructorData {get;set;} //單筆資料
          public int InstructorID {get;set;}
          public int CourseID {get;set;}

          public async Task OnGetAsync(int? id, int? courseID)
          {
              
              // The code specifies {eager loading} for the following {navigation properties}:
              //     Instructor.OfficeAssignment
              //     Instructor.Courses
              //         Course.Department
              
              InstructorData = new InstructorIndexData();
              InstructorData.Instructors = await _context.Instructors
                  .Include(i => i.OfficeAssignment) //     Instructor.OfficeAssignment
                  .Include(i => i.Courses) //     Instructor.Courses
                      .ThenInclude(c => c.Department) //         Course.Department
                  .OrderBy(i => i.LastName)
                  .ToListAsync();

              
              // The selected instructor is retrieved from the list of instructors in the view model. 
              // The view model's Courses property is loaded with the Course entities from the selected instructor's Courses navigation property.
              // The Where method returns a collection. 
              // In this case, the filter select a single entity, so the Single method is called to convert the collection into a single Instructor entity. 
              // The Instructor entity provides access to the Course navigation property.

              if(id != null)
              {
                  InstructorID = id.Value;
                  Instructor instructor = InstructorData.Instructors
                      .Where(i => i.ID == id.Value).Single();
                  InstructorData.Courses = instructor.Courses; //將講師相關課程, 放入navigation properties
              }

              // The following code populates the view model's Enrollments property when a course is selected:
              
              if(courseID != null)
              {
                  CourseID = courseID.Value;
                  IEnumerable<Enrollment> enrollments = await _context.Enrollments
                      .Where(x => x.CourseID == CourseID)
                      .Include(i => i.Student)
                      .ToListAsync();
                  InstructorData.Enrollments = enrollments;
              }
          }

      > Update the instructors Index page
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Index.cshtml

        * 上面程式碼作了下列變更:
          a.Updates the page directive to @page "{id:int?}". 
            "{id:int?}" is a route template. 
            The route template changes integer query strings in the URL to route data. 
              only the <@page> directive => https://localhost:5001/Instructors?id=2
              but <@page "{id:int?}"> directive => https://localhost:5001/Instructors/2

          b.Adds an Office column that displays item.OfficeAssignment.Location 
            only if item.OfficeAssignment isn't null. 
            Because this is a one-to-zero-or-one relationship, 
            there might not be a related OfficeAssignment entity.

              @if (item.OfficeAssignment != null)
              {
                  @item.OfficeAssignment.Location
              }

          c.Adds a Courses column that displays courses taught by each instructor.
            Line: 87-120

          d.Adds code that dynamically adds class="table-success" to the tr element of the selected instructor and course. 
            This sets a background color for the selected row using a Bootstrap class.
            Line: 28-33
            Line: 99-104

          e.Adds a new hyperlink labeled Select. 
            This link sends the selected instructor's ID to the Index method and sets a background color.
            
            <a asp-action="Index" asp-route-id="@item.ID">Select</a> |
            Line: 28-33 //sets a background color

          f.Adds a table of courses for the selected Instructor.

          g.Adds a table of student enrollments for the selected course.

  Part 7, Razor Pages with EF Core in ASP.NET Core - Update Related Data

    1.Update the Course Create and Edit pages
      * The drop-down should show the Department name, 
        so both of these pages need a list of department names. 
        To provide that list, use a base class for the Create and Edit pages.

      > Create a base class for Course Create and Edit
        * 程式碼: Pages/Courses/DepartmentNamePageModel.cs

      > Update the Course Create page model
        * A Course is assigned to a Department. 
          The base class for the Create and Edit pages provides a SelectList for selecting the department. 
          The drop-down list that uses the SelectList sets the Course.DepartmentID foreign key (FK) property. 
          {EF Core uses the Course.DepartmentID FK to load the Department navigation property}.
        
        * 程式碼: Pages/Courses/Create.cshtml.cs

        * 上面程式碼作了下列變更
          a.Derives from {DepartmentNamePageModel} other than default {PageModel}
          b.Uses {TryUpdateModelAsync} to prevent overposting.
          c.Removes ViewData["DepartmentID"]. 
          d.The {DepartmentNameSL} SelectList is a strongly typed model and will be used by the Razor page. 
            Strongly typed models are preferred over weakly typed. 
            For more information, see Weakly typed data (ViewData and ViewBag).

      > Update the Course Create Razor page
        * 程式碼: Pages/Courses/Create.cshtml

        * 上面程式碼作了下列變更
          a.Changes the caption from DepartmentID to Department.
          b.Replaces "ViewBag.DepartmentID" with DepartmentNameSL (from the base class).
          c.Adds the "Select Department" option. 
            This change renders "Select Department" in the drop-down when no department has been selected yet, 
            rather than the first department.
          d.Adds a validation message when the department isn't selected.

      > Update the Course Edit page model
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Edit.cshtml.cs
        
        * 上面程式碼作了下列變更
          a.The changes are similar to those made in the Create page model. (Line: 1530-1536)
          b.{PopulateDepartmentsDropDownList} passes in the department ID, 
            which selects that department in the drop-down list.
      
      > Update the Course Edit Razor page
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Edit.cshtml

        * 上面程式碼作了下列變更        
          a.Displays the course ID. 
            Generally the Primary Key (PK) of an entity isn't displayed. 
            PKs are usually meaningless to users. 
            In this case, the PK is the course number.
          b.Changes the caption for the Department drop-down from DepartmentID to Department.
            
            <label asp-for="Course.DepartmentID" class="control-label"></label>
            [Display(Name ="開課科系")]
            public int DepartmentID {get;set;} //FK

            //Label 顯示結果是 "開課科系"

          c.Replaces "ViewBag.DepartmentID" with DepartmentNameSL, which is in the base class.

          d.The page contains a hidden field (<input type="hidden">) for the course number. 
            Adding a <label> tag helper with asp-for="Course.CourseID" doesn't eliminate the need for the hidden field. 
            <input type="hidden"> is required for the course number to be included in the posted data 
            when the user selects Save.

            //資料POST至後端時, 抓的是 <input>值, 而不是 <label>值, 儘管它們擁有相同asp-for值="Course.CourseID"
              <input type="hidden" asp-for="Course.CourseID" />
              <label asp-for="Course.CourseID" class="control-label"></label>

            //瀏覽器的原始碼: {注意 <label> 的ID 消失了, 不會跟 <input> 重覆}
            <input type="hidden" data-val="true" data-val-required="The 課程編號 field is required." id="Course_CourseID" name="Course.CourseID" value="1045" />
            <div class="form-group">
                <label class="control-label" for="Course_CourseID">課程編號</label>
                <div>1045</div>
            </div>

    2.Update the Course page models 
    (連同 Delete.cshtml.cs & Details.cshtml.cs 都加上 AsNoTracking, 改善查詢效率, 因為這些頁面毋須追蹤狀態)
      * Update {Pages/Courses/Delete.cshtml.cs} and {Pages/Courses/Details.cshtml.cs} 
        by adding {AsNoTracking} to the {OnGetAsync} methods:

      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Details.cshtml.cs
      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Delete.cshtml.cs

    3.Test the Course pages

    4.Update the instructor Create and Edit pages
    {異動多對多關聯的方式}
      * Instructors may teach any number of courses.
      * 新增或修改講師名單時, 利用 checkbox 挑選多個授課類別.(check or uncheck)
      * 如果課程數量更多時, 使用別於 checkbox UI 會是更佳選擇. 
        @* 在此, 異動多對多關聯的方式 是不變的 *@

      * 新增或刪除關聯, 必須操縱 JOIN 實體.
      * Note: The approach taken here to edit instructor course data works well 
        when there's a limited number of courses. 
        For collections that are much larger, a different UI and a different updating method 
        would be more useable and efficient.
      * _context.Instructors.Add(newInstructor) creates a new Instructor 
        using many-to-many relationships without explicitly mapping the join table. 
        Many-to-many was added in {EF 5.0}.

      > Create a class for assigned courses data
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\SchoolViewModels\AssignedCourseData.cs
        * The AssignedCourseData class contains data 
          to create the checkboxes for courses assigned to an instructor.

      > Create an Instructor page model base class
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\InstructorCoursesPageModel.cs
        * The InstructorCoursesPageModel is the base class for the Edit and Create page models. 
          PopulateAssignedCourseData reads all Course entities to populate AssignedCourseDataList. 
          For each course, the code sets the CourseID, title, and whether or not the instructor is assigned to the course. 
        * A HashSet is used for efficient lookups. 
          //HashSet 常用於【有效率的查閱上】

      > Handle office location
        * Another relationship the edit page has to handle is the one-to-zero-or-one relationship 
          that the Instructor entity has with the OfficeAssignment entity.
        
        * The instructor edit code must handle the following scenarios: 
          //講師編輯頁面邏輯, 必須處理下列情境, 以符合上述{one-to-zero-or-one}關聯
          
          a.If the user clears the office assignment, delete the OfficeAssignment entity.
            //如果清除 講師 office assignment, 刪除 OfficeAssignment 實體.
          b.If the user enters an office assignment and it was empty, create a new OfficeAssignment entity.
            //如果輸入 講師 office assignment & OfficeAssignment 實體 不存在, 新增 OfficeAssignment 實體.
          c.If the user changes the office assignment, update the OfficeAssignment entity.
            //如果變更 講師 office assignment & OfficeAssignment 實體 存在, 更新 OfficeAssignment 實體.

    5.Update the Instructor Edit page model
      
      > Update the Instructor Edit Razor page
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Edit.cshtml.cs
          a. 上面程式碼作了下列變更
            ^ Gets the current Instructor entity from the database 
              using eager loading for the OfficeAssignment and Courses navigation properties.
              //使用 .Include 函式, 實作eager loading
            ^ Updates the retrieved Instructor entity with values from the model binder. 
              {TryUpdateModelAsync} prevents overposting.
            ^ If the office location is blank, sets Instructor.OfficeAssignment to null. 
              {When Instructor.OfficeAssignment is null}, 
              the related row in the OfficeAssignment table is deleted.
              //EFCore 預設會採取 {遞迴刪除} 作法, 針對 {非允許空值 FK} & {多對多關係} 的情況.
              //設定為 NULL, 則會 {遞迴刪除}.
            ^ Calls {PopulateAssignedCourseData} in OnGetAsync to provide information for the checkboxes using the AssignedCourseData view model class.
            ^ Calls {UpdateInstructorCourses} in OnPostAsync to apply information from the checkboxes to the Instructor entity being edited.
            ^ Calls PopulateAssignedCourseData and UpdateInstructorCourses in OnPostAsync 
              if TryUpdateModelAsync fails. 
              These method calls restore the assigned course data entered on the page 
              when it is redisplayed with an error message.
          b. 為什麼要另外寫 UpdateInstructorCourses 函式？
            Since the Razor page doesn't have a collection of Course entities, 
            the model binder can't automatically update the Courses navigation property. 

            Instead of using the model binder to update the Courses navigation property, 
            that's done in the new {UpdateInstructorCourses} method. 

            Therefore you need to exclude(排除) the Courses property from model binding. 

            This doesn't require any change to the code that calls {TryUpdateModelAsync}
            because you're using the overload with declared properties and Courses isn't in the include list.
            //{TryUpdateModelAsync} 只針對 Instructor 實體屬性異動, 
            // Instructor 關聯屬性(Courses)異動, 就交由 {UpdateInstructorCourses} 處理

        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Edit.cshtml
          a. 上面程式碼作了什麼
            ^ The preceding code creates an HTML table that has three columns. 
            ^ Each column has a checkbox and a caption containing the course number and title. 
            ^ The checkboxes all have the same name ("selectedCourses"). 
            ^ Using the same name informs the model binder to treat them as a group. 
            ^ The value attribute of each checkbox is set to CourseID. 
            ^ When the page is posted, 
              the model binder passes an array that consists of the CourseID values for only the checkboxes that are selected.

      > Update the Instructor Create page
        * Update the Instructor Create page model and with code similar to the Edit page:
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Create.cshtml.cs
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Create.cshtml

          a. 上面程式碼作了下列變更(Create.cshtml.cs)
            ^ Adds logging for warning and error messages.
            ^ Calls {Load}, which fetches all the Courses in one database call. 
              For small collections this is an optimization when using {FindAsync}. 
              FindAsync returns the tracked entity without a request to the database.          

              // 大量資料用 _context.Courses.Load(); //回DB重撈
              // 使用 .Load() 功能, 必須 using Microsoft.EntityFrameworkCore;
              // 小量資料用 _context.Courses.FindAsync(courseID); //直接抓追蹤中的資料

            ^ _context.Instructors.Add(newInstructor) creates a new Instructor 
              using many-to-many relationships without explicitly mapping the join table. 
              Many-to-many was added in EF 5.0.

          b. 上面程式碼作了下列變更(Create.cshtml)
            ^ 參考Edit.cshtml, 加入 OfficeAssignment輸入欄位 & selectedCourses勾選欄位

      > Update the Instructor Delete page
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Instructors\Delete.cshtml.cs

          Instructor instructor = await _context.Instructors
              .Include(i => i.Courses) //重點1:講師關聯課程必須JOIN進來, 作為講師的完整資訊.
              .SingleAsync(i => i.ID == id);
          if (instructor == null)
          {
              return RedirectToPage("./Index");
          }
          _context.Instructors.Remove(instructor); //重點1:講師被刪除時, 課程才會被一併刪除
          
          var departments = await _context.Departments
              .Where(d => d.InstructorID == id)
              .ToListAsync();
          departments.ForEach(d => d.InstructorID = null); //重點2:如果被刪除講師被指定為任何部門管理員時, 也要從這些部門移除講師指派關係.
          
          await _context.SaveChangesAsync();

        ^ Uses eager loading for the Courses navigation property. 
          Courses must be included or they aren't deleted when the instructor is deleted.
          //講師關聯課程必須JOIN進來, 作為講師的完整資訊. 
          //講師被刪除時, 課程才會被一併刪除.
          //在此的 {多對多關係} 關係, 就會採取 {遞迴刪除} 作法, 把課程實體一併刪除.
          //EFCore 預設會採取 {遞迴刪除} 作法, 針對 {非允許空值 FK} & {多對多關係} 的情況.
          
          To avoid needing to read them, configure {cascade delete} in the database.
          //為避免需要讀取它們，請在資料庫中配置級聯刪除

        ^ If the instructor to be deleted is assigned as administrator of any departments, 
          removes the instructor assignment from those departments.
          //如果被刪除講師被指定為任何部門管理員時, 也要從這些部門移除講師指派關係.

        =={cascade delete}===============================================================
        * 注意1: By convention, EF Core enables {cascade delete} 
          for {non-nullable FKs} and {for many-to-many relationships}. 
          //EFCore 預設會採取 {遞迴刪除} 作法, 針對 {非允許空值 FK} & {多對多關係} 的情況.

  Part 8, Razor Pages with EF Core in ASP.NET Core - Concurrency(如何處理DB同筆資料,同步更新的問題)
    >
      *
        ^
    
    > Concurrency conflicts(並行衝突)
      * A concurrency conflict occurs when:
        ^ A user navigates to the edit page for an entity.
        ^ Another user updates the same entity 
          before the first user's change is written to the database.

      * Pessimistic concurrency(悲觀並行 == 資料庫鎖定)
        ^ One way to prevent concurrency conflicts is to use database locks.(資料庫鎖定)
          This is called {pessimistic concurrency}. 
          Before the app reads a database row that it intends to update, it requests a lock. 
          Once a row is locked for update access, no other users are allowed to lock the row 
          until the first lock is released.
        ^ Managing locks has disadvantages.(缺點)
          It can be complex to program and can cause performance problems 
          as the number of users increases. 
        ^ Entity Framework Core provides no built-in support for pessimistic concurrency.
          (EFCore 未提供內建的悲觀並行機制)

      * Optimistic concurrency(樂觀並行)
        ^ Optimistic concurrency allows concurrency conflicts to happen, 
          and then reacts appropriately when they do. 
        ^ For example, 
          1.Jane visits the Department edit page and changes the {budget}
            for the English department from $350,000.00 to $0.00.
          2.Before Jane clicks Save, John visits the same page and changes the {Start Date} field 
            from 9/1/2007 to 9/1/2013.
          3.Jane clicks Save first and sees her change take effect, 
            since the browser displays the Index page with zero as the Budget amount.
          4.John clicks Save on an Edit page that still shows a budget of $350,000.00.
            (the {budget} field has been changed to $0.00 by Jane)
        
        ^ What happens next is determined by {how you handle concurrency conflicts}
          (Jane & John 更新不同欄位, 但John是否頁面未更新的舊值是否會覆蓋DB內的新值呢??)

          方式1: {Keep track of which property a user has modified} and update only the corresponding columns in the database.
            (追蹤使用者修改屬性, 只更新資料庫內的對應欄位)

            In the scenario, no data would be lost. 
            Different properties were updated by the two users. 
            The next time someone browses the English department, they will see both Jane's and John's changes. 
            
            This method of updating can reduce the number of conflicts that could result in data loss. 
            This approach has some disadvantages:(此方式缺點)
              1.Can't avoid data loss if competing changes are made to the same property.
              2.Is generally not practical in a web app. It requires maintaining significant state in order to keep track of all fetched values and new values. Maintaining large amounts of state can affect app performance.
              3.Can increase app complexity compared to concurrency detection on an entity.

          方式2: Let John's change overwrite Jane's change.
            (後者全贏, 完全沒作並行控制, 以最新1次更新為準)

            The next time someone browses the English department, 
            they will see 9/1/2013 and the fetched $350,000.00 value. 
            
            This approach is called a {Client Wins} or {Last in Wins} scenario. 
            All values from the client take precedence over what's in the data store. 
            
            The scaffolded code does no concurrency handling, 
            {Client Wins} happens automatically.

          方式3: Prevent John's change from being updated in the database.
            (防止後者在資料庫的更新, 以顯示異常訊息的方式, 因為資料狀態已改變.)
          
            Typically, the app would:
              1.Display an error message.
              2.Show the current state of the data.
              3.Allow the user to reapply the changes.

            This is called a {Store Wins} scenario. 
            The data-store values take precedence over the values submitted by the client. 
            The Store Wins scenario is used in this tutorial. 
            This method ensures that no changes are overwritten without a user being alerted.
            (此方法可確保在未向使用者發出警報的情況下覆蓋任何更改。)

    > Conflict detection in EF Core(EFCore 的衝突偵測, 利用RowVersion or GUID欄位值是否相符作為)
      * Properties configured as concurrency tokens are used to implement optimistic concurrency control. 
        When an update or delete operation is triggered by SaveChanges or SaveChangesAsync, 
        {the value of the concurrency token in the database is compared against 
        the original value read by EF Core}:
        
        ^ If the values match, the operation can complete.
        ^ If the values do not match, 
          EF Core assumes that another user has performed a conflicting operation, 
          aborts the current transaction, and throws a DbUpdateConcurrencyException.

      * On relational databases EF Core checks for the value of the concurrency token 
        in the WHERE clause of UPDATE and DELETE statements to detect a concurrency conflict.
      
      * The {data model must be configured to enable conflict detection} 
        by including a tracking column 
        that can be used to determine when a row has been changed. 
        
      * EF provides two approaches for concurrency tokens:
        ^ Applying [ConcurrencyCheck] or IsConcurrencyToken to a property on the model. 
          This approach is not recommended. (不建議用此法, 解決並行衝突的問題)
          For more information, see {Concurrency Tokens in EF Core}.
          https://learn.microsoft.com/en-us/ef/core/modeling/concurrency

        ^ Applying {TimestampAttribute or IsRowVersion} to a concurrency token in the model. 
          This is the approach used in this tutorial. (建議用此法, 解決並行衝突的問題)

          1.SQL Server approach, 使用的是增加{TimestampAttribute}欄位.
          2.SQLite approach, 使用的是增加{IsRowVersion}欄位, 欄位型態為 GUID, 給定預設值 = Guid.NewGuid();
          
          程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Models\Department.cs 
            (增加{IsRowVersion}欄位)
          程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Data\SchoolContext.cs
            (指定{IsRowVersion}欄位為 IsConcurrencyToken(), 指定Department的{ConcurrencyToken}屬性, 作為判斷並行衝突用的標識)

        ^ {IsConcurrencyToken} configures the property as a concurrency token. 
          On updates, the concurrency token value in the database is compared to the original value 
          to ensure it has not changed since the instance was retrieved from the database. 
          If it has changed, a {DbUpdateConcurrencyException} is thrown and changes are not applied.

        ^ In the code that updates the entity, update the value of the concurrency token. 
          In this sample, the method that updates the entity uses the following code. 
          This step will be done later in the tutorial.

          {departmentToUpdate.ConcurrencyToken = Guid.NewGuid();}

            @*  針對 SQLite 更新 ConcurrencyToken 方式1
            
              departmentToUpdate.ConcurrencyToken = Guid.NewGuid(); 
              //Only for SQLite, 資料新增或更新時, 須給定新的GUID值.
              
              *@
            
            @*  針對 SQLite 更新 ConcurrencyToken 方式2: SQLite and EF Core Concurrency Tokens
              https://www.bricelam.net/2020/08/07/sqlite-and-efcore-concurrency-tokens.html

              1.增加{IsRowVersion}欄位, 方式同LINE: 1929
                public class Cutomer
                {
                  public int id {get;set;}
                  public string Name {get;set;}
                  public int Version {get;set;} //增加{IsRowVersion}欄位
                }

              2.指定{IsRowVersion}欄位為 IsConcurrencyToken(), 指定Department的{ConcurrencyToken}屬性, 作為判斷並行衝突用的標識
                方式與LINE: 1932 微不同

                //網路範例作法
                modelBuilder.Entity<Cutomer>().ToTable(nameof(Cutomer))
                    .Property(c => c.Version)
                      .HasDefaultValue(0)
                        .IsRowVersion(); //這裡不一樣
                
                //1932的作法
                modelBuilder.Entity<Department>().ToTable(nameof(Department))
                    .Property(d => d.ConcurrencyToken)
                    .IsConcurrencyToken(); //指定Department的{ConcurrencyToken}屬性, 作為判斷並行衝突用的標識

              3.方式1與方式2最大的不同點: 
                # 方式1: 資料新增或更新時, 須手動給定新的 {判斷並行衝突用的標識}.
                # 方式2: 利用Trigger在資料更新後自動異動 {判斷並行衝突用的標識}.

                # 新增Trigger
                  > If you’re using {Migrations}, 
                    you can add this to the {Up} method of a new migration using {migrationBuilder.Sql()}.
                  > If you’re using {EnsureCreated}, 
                    you can create it using {dbContext.Database.ExecuteSqlCommand()} 
                    whenever EnsureCreated returns {true}.

                  > CREATE TRIGGER UpdateCustomerVersion
                    AFTER UPDATE ON Customers
                    BEGIN
                        UPDATE Customers
                        SET Version = Version + 1
                        WHERE rowid = NEW.rowid;
                    END;

              *@

            //如果用SQL Server approach, 使用的是增加{TimestampAttribute}欄位.
            b.Property<byte[]>("ConcurrencyToken")
              .IsConcurrencyToken()
              .ValueGeneratedOnAddOrUpdate() //SQL Server會自動產生, 最好的方式, 但前提是要有 SQL Server
              .HasColumnType("rowversion");

        ^ 模擬並行衝突發生!
          using (var db = new MyDbContext)
          {
            var customer = db.Customers.Find(1);

            // Simulate a concurrent update
            using (var concurrendb = new MyDbContext)
            {
              var concurrenCustomer = concurrendb.Customers.Find(1);
              concurrenCustomer.Name = "David";
              concurrendb.SaveChanges();
            }

            // Throws DbUpdateConcurrencyException
            customer.Name = "Dubi";
            db.SaveChanges();
          }

    > Add a migration
      * Adding the ConcurrencyToken property changes the data model, which requires a migration.
        ^ 異動項目如下:
          1. public Guid ConcurrencyToken {get;set;} = Guid.NewGuid();
          2. modelBuilder.Entity<Department>().ToTable(nameof(Department))
              .Property(d => d.ConcurrencyToken)
              .IsConcurrencyToken(); //指定Department的{ConcurrencyToken}屬性, 作為判斷並行衝突用的標識

        ^ 執行 migration 指令
          1. dotnet ef migrations add RowVersion
          2. dotnet ef database update

        ^ 上面指令作了什麼事？
          1.Creates the Migrations/{time stamp}_RowVersion.cs migration file.
          2.Updates the Migrations/SchoolContextModelSnapshot.cs file. 
            The update adds the following highlighted code to the BuildModel method:
            
            b.Property<Guid>("ConcurrencyToken")
              .IsConcurrencyToken()
              .HasColumnType("TEXT");

    > Scaffold Department pages
      * 執行 Scaffold 指令
        ^ dotnet aspnet-codegenerator razorpage -m Department -dc SchoolContext -udl -outDir Pages\Departments --referenceScriptLibraries

      * Add a utility class(擷取RowVersion欄位部份值)
        ^ 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Utility.cs
        ^ 利用directive 寫成 SQLite & SqlServer 可在同一個檔內維護
          
    > Update the Index page
      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Departments\Index.cshtml
      * 上述程式碼作下列調整:
        ^ Replace Index with Departments.
        ^ Change the code containing ConcurrencyToken to show just the last few characters.
        ^ Replace FirstMidName with FullName.

    > Update the Edit page model
      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Departments\Edit.cshtml.cs
        //{寫法2}-將資料寫入清單供使用者選擇: 直接寫在修改或新增頁面.
      
      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Courses\Create.cshtml.cs
        //{寫法1}-將資料寫入清單供使用者選擇: 寫在{頁面底層}, 修改或新增頁面再繼承頁面底層.

      * The concurrency updates
        ^ OriginalValue is updated with the ConcurrencyToken value from the entity 
          when it was fetched in the OnGetAsync method. 
        ^ EF Core generates a SQL UPDATE command 
          with a WHERE clause containing the original ConcurrencyToken value. 
        
        ^ If {no rows are affected by the UPDATE command}, 
          a {DbUpdateConcurrencyException exception} is thrown.
          
          /* 狀況1: 
            SELECT * Where ConcurrencyToken = OriginalValue(最原始從DB查出來的值) 有資料.
            但是 
            Update xxx Where ConcurrencyToken = OriginalValue(最原始從DB查出來的值)去更新DB, 
            卻沒有任何行被更新, 會丟出{DbUpdateConcurrencyException exception}
          */
          
        ^ No rows are affected by the UPDATE command 
          when no rows have the original ConcurrencyToken value.

          /* 狀況2: 
            SELECT * Where ConcurrencyToken = OriginalValue(最原始從DB查出來的值) 沒有任何資料.
          */

        @* 額外補充: https://learn.microsoft.com/en-us/ef/ef6/saving/change-tracking/property-values
            ^ Entity Framework keeps track of two values for each property of a tracked entity. 
            1.The {current value} is, as the name indicates, 
              the current value of the property in the entity. (Entity裡面的值, 可能是前端回傳值)
            2.The {original value} is the value that the property had 
              when the entity was queried from the database or attached to the context. (最原始從DB查出來的值)
        
         *@

      * SQL Server vs SQLite code differences

        + using System;    // For GUID on SQLite
        // Set ConcurrencyToken CurrentValue(給予新的版本值, 並行控制的關鍵)
        + departmentToUpdate.ConcurrencyToken = Guid.NewGuid(); // For GUID on SQLite

        // Set ConcurrencyToken to value read in OnGetAsync(取載入時版本值, 並行控制的關鍵)
        _context.Entry(departmentToUpdate)
            .Property(d => d.ConcurrencyToken).OriginalValue = Department.ConcurrencyToken;

        - Department.ConcurrencyToken = (byte[])dbValues.ConcurrencyToken; 
        + Department.ConcurrencyToken = dbValues.ConcurrencyToken; // For GUID on SQLite

      * Update the Edit Razor page
        ^ 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Departments\Edit.cshtml

      * Test concurrency conflicts with the Edit page
        ^ Open {two browsers instances} of Edit on the English department:
          1.Run the app and select Departments.
          2.Right-click the Edit hyperlink for the English department and select Open in new tab.
          3.In the first tab, click the Edit hyperlink for the English department.

    > Update the Delete page model 
      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Departments\Delete.cshtml.cs

        ^ The Delete page detects concurrency conflicts 
          when the entity has changed after it was fetched. 
        ^ Department.ConcurrencyToken is the row version 
          when the entity was fetched. 
        ^ When EF Core creates the SQL DELETE command, 
          it includes a WHERE clause with ConcurrencyToken. 
        ^ If the SQL DELETE command results in zero rows affected:
          1.The ConcurrencyToken in the SQL DELETE command doesn't match ConcurrencyToken in the database.
          2.A DbUpdateConcurrencyException exception is thrown.
          3.OnGetAsync is called with the concurrencyError.

      * Update the Delete Razor page
        ^ 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Pages\Departments\Delete.cshtml
        
        ^ 上面程式碼作了下列變更:
          1.Updates the page directive from @page to @page "{id:int}".
          2.Adds an error message.
          3.Replaces FirstMidName with FullName in the Administrator field.
          4.Changes ConcurrencyToken to display the last byte.
          5.Adds a hidden row version. //重點在這裡//
            ConcurrencyToken must be added so postback binds the value.
      
      * Test concurrency conflicts

        ^ 無法測出DELETE的 concurrency conflicts.
          找到原因了:
          1.測試方法有問題. 
            同一筆資料, 第1個User先刪, 第2個User再刪.
            第2個User刪除時, if (await _context.Departments.AnyAsync(m => m.DepartmentID == id)) 找不到, 
            沒有執行比對RowVersion再刪除動作, 當然不會觸發 {DbUpdateConcurrencyException}
          
          2.針對同筆資料
            ~ 先刪除，後刪除：不會引發DbUpdateConcurrencyException
            ~ 先修改，後刪除：會引發DbUpdateConcurrencyException
              While the above examples discussed updates to existing entities. 
              EF also throws {DbUpdateConcurrencyException} 
              when attempting to delete a row that has been concurrently modified. 
              //重點1: 準備刪除的資料已被並行修改, EFCore同樣會觸發{DbUpdateConcurrencyException}
              
              However, this exception is never thrown when adding entities; 
              while the database may indeed raise a unique constraint violation 
              if rows with the same key are being inserted, 
              this results in a provider-specific exception being thrown, 
              and not DbUpdateConcurrencyException.
              //重點2: 新增資料不會觸發{DbUpdateConcurrencyException}, 
                  而是{違反PK重複的限制}.
          
            try
            {
                if (await _context.Departments.AnyAsync(
                    m => m.DepartmentID == id))
                {
                    // Department.ConcurrencyToken value is from when the entity
                    // was fetched. If it doesn't match the DB, a
                    // DbUpdateConcurrencyException exception is thrown.
                    _context.Departments.Remove(Department);
                    await _context.SaveChangesAsync();
                }
                return RedirectToPage("./Index");
            }
            catch (DbUpdateConcurrencyException)
            {
                return RedirectToPage("./Delete",
                    new { concurrencyError = true, id = id });
            }
     
    > Additional resources

{進行中}
/* Tutorial: Get started with Razor Pages in ASP.NET Core <= Razor Pages 初階班 => */
  https://learn.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/razor-pages-start?source=recommendations&view=aspnetcore-7.0&tabs=visual-studio
  練習專案路徑: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage
  >
    *
      ^

  [Part 1, Introduction] (OK, 2023/05/30)
    1.Prerequisites
    2.Create a Razor Pages web app
    3.Run the app
    4.Examine the project files

      > Pages folder
        * Contains Razor pages and supporting files. Each Razor page is a pair of files:
          ^ A .cshtml file that has HTML markup with C# code using Razor syntax.
          ^ A .cshtml.cs file that has C# code that handles page events.

        * Supporting files have names that begin with an underscore. //支援檔案通常以 _ 開頭.
          For example, the {_Layout.cshtml} file configures UI elements common to all pages. 
          {_Layout.cshtml} sets up the navigation menu at the top of the page and the copyright notice at the bottom of the page.

      > wwwroot folder
        * Contains {static assets}, like {HTML files, JavaScript files, and CSS files}. 
          For more information, see {Static files in ASP.NET Core}.

      > appsettings.json
        * Contains {configuration data}, like {connection strings}. //包含設定值, 例: 連接字串
          For more information, see Configuration in ASP.NET Core.

      > Program.cs //重點: APP可以使用的服務, 必須在此註明(DI)
        * 程式碼片段
          var builder = WebApplication.CreateBuilder(args);
          builder.Services.AddRazorPages(); // Add services to the container.
          var app = builder.Build();

        * 上面程式碼作了什麼事
          1.create a WebApplicationBuilder with preconfigured defaults.
          2.add Razor Pages support to the Dependency Injection (DI) container.
          3.builds the app:

        * 程式碼片段
          // Configure the HTTP request pipeline.
          if (!app.Environment.IsDevelopment())
          {
              app.UseExceptionHandler("/Error");
              // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
              app.UseHsts();
          }
        
        * 上面程式碼作了什麼事
          1.sets the exception endpoint to {/Error}
          2.enables HTTP Strict Transport Security Protocol (HSTS) 
            when the app is not running in development mode
          //非正式環境時, 設定異常處理地點 & 強制使用 HTTP Strict Transport Security Protocol (HSTS)

        * The following code enables various {Middleware}: //使用了許多 {中介程式}
          1.app.UseHttpsRedirection(); 
            : Redirects HTTP requests to HTTPS.
          2.app.UseStaticFiles(); 
            : Enables static files, such as HTML, CSS, images, and JavaScript to be served. 
              For more information, see {Static files in ASP.NET Core}.
          3.app.UseRouting(); 
            : Adds route matching to the middleware pipeline. 
              For more information, see {Routing in ASP.NET Core}
          4.app.MapRazorPages();
            : Configures endpoint routing for Razor Pages.
          5.app.UseAuthorization(); 
            : Authorizes a user to access secure resources. 
              This app doesn't use authorization, therefore this line could be removed.
          6.app.Run(); 
            : Runs the app.

    5.Troubleshooting with the completed sample
    6.Next steps

  [Part 2, add a model] (OK, 2023/05/31)
    > classes are added for managing movies in a database. 
      * The app's model classes use Entity Framework Core (EF Core) to work with the database. 
      * EF Core is an {object-relational mapper (O/RM)} that simplifies data access. 
      * You write the model classes first, and EF Core creates the database.
      * The model classes are known as {POCO} classes (from "Plain-Old CLR Objects") 
        because they don't have a dependency on EF Core. 
        They {define the properties of the data} that are stored in the database.
      * #EFCore #ORM #POCO #CodeFirst

    1.Add a data model
      /Models/dataModel.cs
      * 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Models\Movie.cs
      
        ^ The Movie class contains:
          1.An {ID} field to provide a primary key for the database. //PK
          2.A [DataType] attribute to specify the type of data in the {ReleaseDate} field. 
            With this attribute:
            The user is not required to enter time information in the date field.
            Only the date is displayed, not time information.
          3.The question mark after string indicates that the property is nullable. 
            For more information, see {Nullable reference types}.
            例: string? Name {get;set;} //表示 Name 欄位允許NULL值

      * Add NuGet packages and EF tools
        ^ 使用 "dotnet aspnet-codegenerator" 前, 
          請服用 "<命令列環境>下使用 <dotnet aspnet-codegenerator> 工具的前置作業".
        ^ !! 千萬不要忘記 {.NET版本} 必須和 {dotnet-aspnet-codegenerator} 及 {dotnet-ef} 版本相符

          dotnet tool uninstall --global dotnet-aspnet-codegenerator #已安裝不要再移除了#
          dotnet tool install --global dotnet-aspnet-codegenerator --version 6.0.10
          dotnet tool uninstall --global dotnet-ef #已安裝不要再移除了#
          dotnet tool install --global dotnet-ef --version 6.0.10
          dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.10
          dotnet add package Microsoft.EntityFrameworkCore.SQLite --version 6.0.10
          dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 6.0.10
          dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 6.0.10
          dotnet add package Microsoft.EntityFrameworkCore.Tools --version 6.0.10

    2.Scaffold the movie model
      
      > Scaffold the movie model
        * 指令碼(之前用過的): 
            "dotnet aspnet-codegenerator razorpage -m Course -dc SchoolContext -udl -outDir Pages\Courses --referenceScriptLibraries"

        * (Error)指令碼(範例)-.NET 7, --databaseProvider sqlite 在.NET 6會掛掉: 
            "dotnet aspnet-codegenerator razorpage -m Movie -dc RazorPagesMovie.Data.MovieContext -udl -outDir Pages/Movies --referenceScriptLibraries --databaseProvider sqlite"
            //注意: -dc RazorPagesMovie.Data.MovieContext, 寫的完整, 會自動加上namespace

        * (OK)指令碼-.NET 6: 
            "dotnet aspnet-codegenerator razorpage -m Movie -dc EWeb_RazorPage.Data.MovieContext -udl -outDir Pages/Movies --referenceScriptLibraries"
            namespace EWeb_RazorPage.Pages_Movies //長的很怪, 差在 -outDir Pages/Movies

            "dotnet aspnet-codegenerator razorpage -m Movie -dc EWeb_RazorPage.Data.MovieContext -udl -outDir Pages\Movies --referenceScriptLibraries"
            namespace EWeb_RazorPage.Pages.Movies //似乎比較正常, 差在 -outDir Pages\Movies

            //注意1: -dc MovieContext, 儘管未加上namespace (EWeb_RazorPage.Data.MovieContext), 路徑同樣正確.
            //注意2: -outDir Pages/Movies, 生出來的 namespace EWeb_RazorPage.Pages_Movies 
                     -outDir Pages\Movies, 生出來的 namespace EWeb_RazorPage.Pages.Movies
                     個人推測 "Pages\Movies" 符合 Windows 系統路徑規則, 故 namespace 命名正常些.

      > Use SQLite for development, SQL Server for production 
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Program.cs

        * The preceding code doesn't call {UseDeveloperExceptionPage} in development 
          because {WebApplication} calls {UseDeveloperExceptionPage in development mode}.

      > Files created and updated
        * The scaffold process creates the following files:
          1.Pages/Movies: Create, Delete, Details, Edit, and Index.
          2.Data/MovieContext.cs

      > The scaffold process adds the following highlighted code to the {Program.cs} file:
        * 以DI方式, 註冊 DbContext 服務
        * 程式碼:
        
          using Microsoft.EntityFrameworkCore;
          using Microsoft.Extensions.DependencyInjection;

          builder.Services.AddDbContext<MovieContext>(options =>
            options.UseSqlite(builder.Configuration.GetConnectionString("MovieContext") ?? throw new InvalidOperationException("Connection string 'MovieContext' not found.")));

    3.Create the initial database schema using EF's migration feature

      > The migrations feature in Entity Framework Core provides a way to:
        * Create the initial database schema.
        * Incrementally update the database schema 
          to keep it in sync with the app's data model. 
        * Existing data in the database is preserved. //現有資料庫內資料被保留

      > 指令碼:
        * dotnet ef migrations add InitialCreate //第1次移轉名稱慣例: InitialCreate
        * dotnet ef database update //實際更新DB結構

        * The {migrations} command generates code to create the {initial database schema}. 
          The schema is based on the model specified in {DbContext}. 
          The {InitialCreate} argument is used to name the migrations. //依慣例, 會依本次異動命名
          Any name can be used, but by convention a name is selected that describes the migration. 

        * The {update} command runs the {Up} method in migrations 
          that have not been applied. 
          In this case, update runs the Up method in the Migrations/<time-stamp>_InitialCreate.cs file, 
          which creates the database.

        * For {SQLite}, column type for the {Price} field is set to TEXT. 
          This is resolved in a later step. //在 SQLite 沒有與 decimal 對應的DB欄位, 必須手動處理

      > Examine the context registered with dependency injection
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Program.cs

          ^ ASP.NET Core is built with {dependency injection}. 
            Services, such as the {EF Core database context}, 
            are registered with dependency injection during application startup. 
          
          ^ Components that require these services (such as Razor Pages) are provided via constructor parameters. 
            The constructor code that gets a database context instance is shown later in the tutorial.

        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Data\MovieContext.cs (簡單範例)
        * 程式碼: C:\Projects\Projects_ASP.NET_Core\EFCore_RazorPage\Data\SchoolContext.cs (進階範例)
        
          ^ Derives from Microsoft.EntityFrameworkCore.DbContext.
          ^ Specifies which entities are included in the data model. //指的是DB這個MODEL
          ^ Coordinates EF Core functionality, 
            such as Create, Read, Update and Delete, for the Movie model.
          ^ 在 DbContext 內還能設定
            1.建立資料表間的關聯性
            2.指定資料表的並行控制欄位
            3.資料表名稱等細節

        * 程式碼片段: public DbSet<EWeb_RazorPage.Models.Movie> Movie { get; set; } = default!;

          ^ The preceding code creates a DbSet<Movie> property for the entity set. 
          ^ In Entity Framework terminology, 
            1.an {entity set} typically corresponds to a database table. //代表1個資料表
            2.An {entity} corresponds to a row in the table.//代表1列

    4.Test the app
    5.Troubleshooting with the completed sample
    6.Additional resources

  [Part 3, scaffolded Razor Pages in ASP.NET Core]

    > This tutorial examines the Razor Pages created by scaffolding in the previous tutorial [Part 2, add a model].
    
    > The Create, Delete, Details, and Edit pages
      
      > 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Pages\Movies\Index.cshtml.cs

        * Razor Pages are derived from PageModel. 
          By convention, the PageModel derived class is named <PageName>Model. 
          For example, the Index page is named <Index>Model.

        * The constructor uses {dependency injection} to add the RazorPagesMovieContext to the page:
          ^ 程式碼片段
            public class IndexModel : PageModel
            {
                private readonly RazorPagesMovie.Data.RazorPagesMovieContext _context;

                public IndexModel(RazorPagesMovie.Data.RazorPagesMovieContext context) //在這裡DI DBContext
                {
                    _context = context;
                }

        * When a {GET request} is made for the page, the {OnGetAsync} method returns a list of movies to the Razor Page. 
          On a Razor Page, {OnGetAsync} or {OnGet} is called to initialize the state of the page. 
          In this case, {OnGetAsync} gets a list of movies and displays them.
        # 注意: 頁面狀態初始化時, 會呼叫 {OnGetAsync} or {OnGet} #
          
        * When {OnGet returns void} or {OnGetAsync returns Task}, 
          no return statement is used.
        # 注意: 回傳值為 void 或 Task, 不用明確使用 return 敘述子 #

          ^ 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Pages\Privacy.cshtml.cs
            public void OnGet()
            {
            }

          ^ 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Pages\Movies\Index.cshtml.cs
            public async Task OnGetAsync()
            {
                if (_context.Movie != null)
                {
                    Movie = await _context.Movie.ToListAsync();
                }
            }

        * When the return type is {IActionResult} or {Task<IActionResult>}
          a return statement must be provided. 
        # 注意: 回傳值為 IActionResult 或 Task<IActionResult>, 須使用 return 敘述子 #
          
          ^ 程式碼: C:\Projects\Projects_ASP.NET_Core\EWeb_RazorPage\Pages\Movies\Create.cshtml.cs
            public IActionResult OnGet()
            {
                return Page(); //注意事項
            }
            
            public async Task<IActionResult> OnPostAsync()
            {
              if (!ModelState.IsValid || _context.Movie == null || Movie == null)
                {
                    return Page();
                }

                _context.Movie.Add(Movie);
                await _context.SaveChangesAsync();

                return RedirectToPage("./Index"); //注意事項
            }

      > The @page directive

      > The @model directive

      > The layout page

      > ViewData and layout

      > Update the layout

      > The Create page model

      > The Create Razor Page

      > 

  [Part 4, Work with a database]

  [Part 5, update the generated pages in an ASP.NET Core app]

  [Part 6, add search to ASP.NET Core Razor Pages]

  [Part 7, add a new field to a Razor Page in ASP.NET Core]

  [Part 8, Add Validation]

/* Introduction to Razor Pages in ASP.NET Core (Razor Pages 概觀) <= 給 developers who are familiar with controllers and views => */ 
(2023/05/30快速瀏覽過, 還看不太懂, 功力增強後, 須完整回顧)文章內容把 Razor Pages 總體架構作了細部但簡略的說明, 對我目前程度來說太深了.
最後的多個額外資源連接, 有極高的參考價值.
  https://learn.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-7.0&tabs=visual-studio-code#additional-resources
  https://learn.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-7.0&tabs=visual-studio-code#url-generation-for-pages


更新內容移至 SOP-.NET CORE-MVC-30天建立購物網站重編版.txt
/*==從實作學習ASP.NET Core - 30天的購物網站系列 <.NET 6> [2023/04/05 ~ 未完成 ~ 不再更新, 更新內容移至 SOP-.NET CORE-MVC-30天建立購物網站重編版.txt]==*/ 
  第1次沒有作完, 就去台半上班了. 2023/05/09從台半離職後, 再來把它作完
  資料來源: https://ithelp.ithome.com.tw/articles/10258872
  註:學習歷程相同, 採用<VSCode + Sqlite(測試環境) + Oracle XE 11g Express(正式環境)>, 非範例使用的右例工具 <VSCommunity 2019 + SQL Server 2019 Express with Management Studio>
      
    Day1: 新增asp.net core web app(MVC)
      ProjectName: OnlineShopCMS (我的專案名稱: NET6_MvcShopping)
      .Net Version: .NET 5.0 (我的.NET SDK 版本: .NET 6.0)

      * 新增方案資料夾 C:\Projects\Projects_ASP.NET_Core\NET6_MvcShopping
      * CMD路徑切換至方案資料夾
      * 新增MVC架構網站 => dotnet new mvc
      * 測試編譯 => dotnet build
      * 信任測試環境簽章(https用) => dotnet dev-certs https --trust
      * 測試執行 => dotnet run
        1. 第1次建置要花比較久的時間, 接下來產生<bin> & <obj> 兩個資料夾
        2. 產生兩個網址, 一個有https憑證, 另一個沒有
          info: Microsoft.Hosting.Lifetime[14]
                Now listening on: https://localhost:7254
          info: Microsoft.Hosting.Lifetime[14]
                Now listening on: http://localhost:5276
          info: Microsoft.Hosting.Lifetime[0]
                Application started. Press Ctrl+C to shut down.
          info: Microsoft.Hosting.Lifetime[0]
                Hosting environment: Development
          info: Microsoft.Hosting.Lifetime[0]
                Content root path: C:\Projects\Projects_ASP.NET_Core\NET6_MvcShopping\

    Day2: 說明MVC的架構
      https://imgur.com/xbA1MZq.jpg
      
      * 從作者引用的圖可以發現, 雖然使用者看到的是<View>的呈現結果
        但要求都會 "先送至" <Controller>, 
        再由<Controller>負責去<Model>取資料或交給<View>作呈現.

        > Controller：負責商業邏輯處理，管控流程和回應，並以路由傳遞資料
        > Model：負責資料存儲，處理資料與資料庫之間的操作
        > View：負責前端畫面與邏輯顯示，就是使用者會看到的介面

      * MVC網站專案目錄      
        > Controllers、Models、Views 資料夾：我們程式的主角
        > appsettings.json：儲存環境變數的地方，例如資料庫連接字串
        > Program.cs：程式的起始點
        > Startup.cs：程式的組態檔，服務需要從這邊註冊。(註: 從.NET 6開始已合併至Program.cs)

          註: 從.NET 6之後 <Startup.cs> 消失了, "服務註冊作業(DI)" 被合併至 <Program.cs>.
          詳細說明參閱連結, https://stackoverflow.com/questions/70952271/startup-cs-class-is-missing-in-net-6

    Day3: Controller 控制器
      https://imgur.com/CJXZGiK.jpg

      * 觀念介紹
        > 路由, 就是 <網址路徑> 的規則.
        > 使用者需要用<網址路徑>來向程式發出請求.
        > MVC預設網址路徑為: https://[你的網路位置:port]/[Controller名稱]/[Action名稱]
        > MVC預設網址路徑規則定義在: "Program.cs" 檔案內. 
          app.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");

      * 手動 新增控制器(Controller)

        > 新增 HelloWorldController by 自動產生程式碼工具<dotnet aspnet-codegenerator>

          dotnet aspnet-codegenerator controller -name HelloWorldController -outDir Controllers -scripts -udl

        > 透過 Welcome Action, 向 HomeController 傳遞參數, 再回傳值.

          # Program.cs檔案內, 預設<路由規則>-寫法1 #
            app.MapControllerRoute(
              name: "default",
              pattern: "{controller=Home}/{action=Index}/{id?}");

          # Program.cs檔案內, 預設<路由規則>-寫法2 #
            app.MapDefaultControllerRoute(); //功能跟寫法1相同, 但更簡潔.(使用路由範本預設 Home 控制器和 Index 動作)

          # 增加另一個 "Welcome Action" , name 則是選擇性參數.
            https://localhost:7254/Home/Welcome/KL

          # 範例沒有問題, 它用的是 <?> 作為參數分隔符號, 要指定參數名稱(Name)非使用預設路由規則名稱(id)
          # 這不符合目前 <路由規則> 以 </> 作為分隔符號, 所以抓不到傳入值.
            https://localhost:7254/Home/Welcome?KL (X)
            https://localhost:7254/Home/Welcome/KL (O)

          public string Welcome(string? name){
              return "This is Welcome Action of Home Controller: 你好嗎? " + name;
          }
      
      * 利用工具 自動 新增控制器(Controller) & 檢視(View) & DbContext(ORM) & ConnectionStrings(連線字串) by 資料模型(Data/Model)
        
        > #! VIP: 使用 <dotnet aspnet-codegenerator> 快速 "新增控制器(Controller) & 檢視(View) by 資料模型(Data/Model)" 前, 
        
          一定要執行下列前置作業, 否則會出現錯誤.
          請服用 " <命令列環境>下使用 <dotnet aspnet-codegenerator> 工具的前置作業 "

        範例1: 使用 資料模型(Data/Model)的超完整範例
        
          a.資料模型(Data/Model): "Product.cs"
          
            using System;
            using System.Collections.Generic;

            namespace NET6_MvcShopping.Models;

            public class Product
            {
                public int ProductID {get;set;} //系統指定ID, 無法變更
                public string? Name {get;set;}
                public decimal? Price {get;set;}
                public int? Stock {get;set;}
            }

          b.執行 <dotnet aspnet-codegenerator> Scaffolding 程式碼產生工具
            dotnet aspnet-codegenerator controller -name ProductsController -m Product -dc StoreContext -outDir Controllers -sqlite -scripts -udl

            自動完成下列作業: <= 超強 =>
              1.自動新增控制器(\Controllers) & 
              2.新增檢視(\Views) & 
              3.新增DbContext(\Data) & 
              4.新增ConnectionStrings(@appsettings.json) &
                註1: 如果ConnectionStrings未新增, 工具會加在"appsettings.json"檔案內.
                註2: 如果ConnectionStrings已新增, 工具會保留ConnectionStrings原值不異動.
              5.註冊Database服務(@Program.cs)
            
        範例2: 只產生 控制器(Controller), 沒有 檢視(View).
            dotnet aspnet-codegenerator controller 
            -name HelloWorldController 
            -outDir Controllers (O, 指定相對輸出檔案夾路徑)
          
        範例3: 只產生 控制器(Controller), 沒有 檢視(View), 而且把 控制器(Controller)直接加在專案資料夾下.
            dotnet aspnet-codegenerator controller 
            -name HelloWorldController (X, 直接加在專案資料夾, 刪掉)

        > 新增控制器(Controller)指令用法 => "dotnet aspnet-codegenerator controller -h"
          Generator Options:
            --controllerName|-name [#!-必填欄位-#] : (控制器名稱)Name of the controller
            --useAsyncActions|-async            : (產生非同步actions)Switch to indicate whether to generate async controller actions
            --noViews|-nv                       : (產生CRUD檢視)Switch to indicate whether to generate CRUD views
            --restWithNoViews|-api              : (API專用控制器, 預設noViews & 忽略所有檢視設定)Specify this switch to generate a Controller with REST style API, noViews is assumed and any view related options are ignored
            --readWriteActions|-actions         : (產生讀/寫用actions)Specify this switch to generate Controller with read/write actions when a Model class is not used
            --model|-m                          : Model class to use
            --dataContext|-dc                   : DbContext class to use
            --referenceScriptLibraries|-scripts : Switch to specify whether to reference script libraries in the generated views
            --layout|-l                         : Custom Layout page to use
            --useDefaultLayout|-udl             : Switch to specify that default layout should be used for the views
            --force|-f                          : Use this option to overwrite existing files
            --relativeFolderPath|-outDir        : Specify the relative output folder path from project where the file needs to be generated, if not specified, file will be generated in the project folder
            --controllerNamespace|-namespace    : Specify the name of the namespace to use for the generated controller
            --useSqlite|-sqlite                 : Flag to specify if DbContext should use SQLite instead of SQL Server.

        > 新增視圖(View)指令用法 => "dotnet aspnet-codegenerator view -h"

          Generator Arguments:(這兩個參數一定要給)
            viewName     : Name of the view
            templateName : The view template to use, supported view templates: 'Empty|Create|Edit|Delete|Details|List'

          Generator Options:
            --model|-m                          : Model class to use
            --dataContext|-dc                   : DbContext class to use
            --referenceScriptLibraries|-scripts : Switch to specify whether to reference script libraries in the generated views
            --layout|-l                         : Custom Layout page to use
            --useDefaultLayout|-udl             : Switch to specify that default layout should be used for the views
            --force|-f                          : Use this option to overwrite existing files
            --relativeFolderPath|-outDir        : Specify the relative output folder path from project where the file needs to be generated, if not specified, file will be generated in the project folder
            --controllerNamespace|-namespace    : Specify the name of the namespace to use for the generated controller
            --partialView|-partial              : Generate a partial view, other layout options (-l and -udl) are ignored if this is specified
            --useSqlite|-sqlite                 : Flag to specify if DbContext should use SQLite instead of SQL Server.

          Day3.5: 如何使用 .NET CLI 快速產生 ASP․NET Core 的 Controllers 與 Views 程式碼

      資料來源: https://blog.miniasp.com/post/2020/09/09/Create-Controller-and-Views-with-dotnet-aspnet-codegenerator
      重點在於: 
        1.必須先有 <資料表結構> 的程式碼
          建立 Data 相關程式碼(C:\Projects\Projects_ASP.NET_Core\MvcMovie\Models\Movie.cs)
            using System.ComponentModel;
            using System.ComponentModel.DataAnnotations;
            using System.ComponentModel.DataAnnotations.Schema;

            namespace MvcMovie.Models
            {
              public class Movie
              {
                public int Id {get; set;}
                
                [DisplayName("片名"), StringLength(10, MinimumLength =3)]
                public string? Title {get; set;}

                [DisplayName("發售日期"), DataType(DataType.Date)]
                public DateTime ReleaseDate {get; set;}
                
                [DisplayName("類別"), StringLength(20, MinimumLength =3)]
                public string? Genre {get; set;}
                
                [DisplayName("售價"), DataType(DataType.Currency), Range(1,150), Column(TypeName = "decimal(18, 2)")]
                public decimal Price {get; set;}

                [DisplayName("評價"), StringLength(5), RegularExpression(@"^[A-Z]+[a-z]+[0-9]*$")]
                public string? Rating {get;set;}

              }
            }

        2. 參閱 <Dependency injection 關注點注入, 這就是DI> 章節內容 <= 觀念介紹 =>
          MVC中的 "Model" = 由1個實體類別(/Model/Movie.cs) + 1個Context Object(/Data/MvcMovieContext.cs)所組成的, 它代表資料庫中的一個Session.

        3. 快速建立 DepartmentsController 控制器（包含 Views 頁面與使用現有 Layout 版面）
            dotnet aspnet-codegenerator controller -name DepartmentsController 
            -async -scripts -udl 
            -m Department -dc ContosoUniversityContext -outDir Controllers

    Day4: View 視圖
      https://imgur.com/rqnct3l.jpg

      * 新增View

/*== Learn 範例 (2022/06/21~ 進行中..)==*/

  Create a web API with ASP.NET Core controllers (2022/06/21~ 進行中..)
  https://docs.microsoft.com/en-us/learn/modules/build-web-api-aspnet-core/
    
    學習目標: By the end of this session, you'll be able to create new web API applications by using ASP.NET Core. 
      You'll also know how to create API controllers that implement basic CRUD logic.

    API clients communicate with the server over HTTP, 
    and the two exchange information by using a data format such as JSON or XML. (WebApi最常用的兩種格式, JSON & XML, 與前端SPA程式作資料交換)
    APIs are often used in single-page applications (SPAs) that perform most of the user interface logic in a web browser. 
    (SPAs指的就是那些使用JS框架的前端應用程式, 它們把主要負載放在前端瀏覽器的程式.)
    Communication with the web server primarily happens through web APIs.

    REST: A common pattern for building APIs with HTTP
      Representational State Transfer (REST) is an architectural style for building web services. 
      REST requests are made over HTTP.
      它使用瀏覽器存取網頁和回傳資料回Server時, 相同的動詞
      
      GET: Retrieve data from the web service.
      POST: Create a new item of data on the web service.
      PUT: Update an item of data on the web service.
      PATCH: Update an item of data on the web service by describing a set of instructions about how the item should be modified. The sample application in this module doesn't use this verb.
      DELETE: Delete an item of data on the web service.

    Benefits of creating APIs in ASP.NET Core(使用ASP.NET Core新增APIs的優點)
    
      # Simple serialization: (簡單序列化)
        ASP.NET was designed for modern web experiences. Endpoints automatically serialize your classes to properly formatted JSON out of the box. No special configuration is required. Of course, you can customize serialization for endpoints that have unique requirements.
      # Authentication and authorization: (認證和授權機制)
        For security, API endpoints have built-in support for industry-standard JSON Web Tokens (JWTs). Policy-based authorization gives you the flexibility to define powerful access control rules in code.
      # Routing alongside your code: (路由就在程式碼旁邊)
        ASP.NET lets you define routes and verbs inline with your code, by using attributes. Data from the request path, query string, and request body are automatically bound to method parameters.
      # HTTPS by default: (預設的HTTPS加密機制)
        HTTPS is an important part of modern, professional web APIs. It relies on end-to-end encryption to provide privacy and to help ensure that your API calls aren't intercepted and altered between client and server.

    Share code and knowledge with .NET apps(可以和其他.NET分享程式碼.)
    
    Testing web APIs by using the .NET HTTP REPL(利用.NET HTTP REPL工具測試 WebApi)
      # "REPL" stands for read-evaluate-print loop. 
        It's a simple and popular way to a build interactive command-line environments.

    CHECK YOUR KNOWLEDGE
    Which of the following is not a reason to build a web API by using ASP.NET Core?
      (O)To provide a back-end server for an SPA front end, such as Angular or React.
      (O)To provide data to a mobile client application by using XML or JSON.
      (X)To serve a traditional HTML-based web application.
          Answer: To serve a traditional HTML-based web application with ASP.NET Core, you would use Razor Pages or MVC

    Create and explore a web API project(新增WEBAPI專案)
      # 指令詳常用指令
        dotnet new webapi -f net6.0

      # 新增後的程式結構
      -| Controllers (WebApi對外類別方法, 寫在這)
      -| obj (程式編譯後DLL放這)
      -| Properties
      -| appsettings.Development.json (應用程式設定檔-開發環境)
      -| appsettings.json (應用程式設定檔-正式環境)
      -| ContosoPizza.csproj (專案相關設定檔)
      -| Program.cs (註冊服務的地方[DI], 例: 身分驗證; 資料庫設定...)
      -| WeatherForecast.cs

    Build and test the web API
      1. dotnet run 測試執行..

      2. https://localhost:{PORT} or http://localhost:{PORT} 無回應.

      3. https://localhost:{PORT}/weatherforecast 有回應, 回傳JSON字串.

      4. 利用 Microsoft.dotnet-httprepl 工具, 協助測試Webapi (Swagger比較直覺..)
          dotnet tool install -g Microsoft.dotnet-httprepl

          使用步驟(under cmd shell, .NET CLI): 
            1. httprepl 
            2. (Disconnected)> connect https://localhost:{PORT}
            3. https://localhost:7117/>
            4. ls 
              .                 []
              WeatherForecast   [GET]

            5. cd WeatherForecast
              https://localhost:7117/WeatherForecast>

            6. GET => 回傳JSON字串
              https://localhost:7117/WeatherForecast> get
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
              Date: Tue, 21 Jun 2022 06:51:14 GMT
              Server: Kestrel
              Transfer-Encoding: chunked

              [
                {
                  "date": 2022/6/22 下午 02:51:15,
                  "temperatureC": 39,
                  "temperatureF": 102,
                  "summary": "Balmy"
                },

            7. exit => 結束 httprepl 工具

      5. Ctrl + C => 關閉 WebApi 服務.

    ASP.NET Core Web API Controllers

      In this unit, 
      you'll see how <WeatherController> uses the <ControllerBase> base class and a few .NET attributes 
        to build a <functional web API> in a few dozen lines of code. (重點在於, 繼承底層 ControllerBase, 可為建立具備完整功能WEBAPI提供基礎.)


    The base class: ControllerBase

      # 依照慣例(Conventions), 

      !! 注意: WebApi 與 RazorPages or MVC 基底類別不同 !!
      1. WebApi 使用 ControllerBase class 即可.
      2. RazorPages 必須使用 Controller class, 而Controller 也是繼承自ControllerBase, 另外加上了檢視(VIEW)支援, 

  ASP.NET Core MVC(檢視)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/views/overview?view=aspnetcore-5.0

  ASP.NET Core MVC(部分檢視, 先跳過)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-5.0

  ASP.NET Core MVC(控制器)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions?view=aspnetcore-5.0

  ASP.NET Core MVC(路由)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-5.0

  ASP.NET Core MVC(控制器插入服務. Dependency injection into controllers in ASP.NET Core)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/dependency-injection?view=aspnetcore-5.0

  ASP.NET Core MVC(檢視插入服務. Dependency injection into views in ASP.NET Core)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/views/dependency-injection?view=aspnetcore-5.0

  ASP.NET Core MVC(單元測試. Unit test controller logic in ASP.NET Core)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/testing?view=aspnetcore-5.0

  Upload files in ASP.NET Core (for 訪視照片檔案上傳用)
  https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-5.0

  使用 ASP.NET Core、最小 API 和 .NET 6 建立 Web 應用程式和服務
  https://docs.microsoft.com/en-us/learn/modules/build-web-api-minimal-api/4-advanced-commands

    <ASP.net core web api>
    1. 新增路由結構, 來處理資料讀取和寫入
    2. 使用 Swagger, 發佈web api資訊.
  
    <minimal api = 最小化的api based on .net 6.0>
    1. controller-based approach(控制器) and minimal API的差異?
      其實, 兩者都能夠產生WebApi, 之間的差異在於
      1.1. No Startup.cs. 
          建立minimal API時, 不用 Startup.cs. 
          所有的程式碼在 Program.cs 內即可完成.
      1.2. Top-level statements.
          因為使用

    GET: 存取資料, 存取資源 = Select
      app.MapGet("/", () => "Hello World !");
      app.MapGet("/products", () => data );
      app.MapGet("/products/{id}", (int id) => data.SingleOrDefault(product => product.Id == id));

    POST: 新增資源 = Insert
      app.MapPOST

      // JSON 從USER端丟進來
      {
        "Name" : "New Product",
        "Description" : "a Description"
      }

      // WEBAPI 可接收
      app.MapPOST("/products", (Product product) => /**/ );

      // C#類別 Product
      public recored Product(id Id, string Name);

    PUT: 更新資源 = Update, 它的作法和 app.MapPOST很像, 不過傳入的是變更後的資料
      app.MapPUT("/products", (Product product) => /* Update the data store using the `product` instance */)

    DELETE: 刪除資源 = Delete
      app.MapDelete("/products/{id}", (int id) => /* Remove the record whose unique identity */)

    回傳結果
      app.MapGet("/products", () => products);
      
        //JSON(多筆)
        [{"id" = 1, "name" = "product A"}
        ,{"id" = 1, "name" = "product B"}]

      app.MapGet("/products/{id}, (int id) => products.SingleOrDefault(product => product.id == id)");
        
        //JSON(單筆)
        [{"id" = 3, "name" = "Product C"}]

      app.Mapget("/product", () => new {id = 1});
        //JSON(在router範圍外, 給定預設值)
        {
          "id" = 1,
        }

  {完成}-Host ASP.NET Core on Windows with IIS (for 佈署上線)
      https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-5.0
      C:\Users\p10154383\Documents\個人資料夾\筆記-圖書館-new\資訊科技相關\SOP-.NET CORE_部署.txt

  {完成}-[MVC 初階學習 Get started with ASP.NET Core MVC (MVC架構完整RUN一次) => ProjectName: MvcMovie] 2022/05/30 完成.
      https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc?view=aspnetcore-5.0&tabs=visual-studio

        Part 2, add a controller to an ASP.NET Core MVC app (OK)
        Part 3, add a view to an ASP.NET Core MVC app (OK)

        /*== Part 4, add a model to an ASP.NET Core MVC app 關於Model的細節說明 ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/adding-model?view=aspnetcore-6.0&tabs=visual-studio
          
          # <Initial migration 新增或更新資料庫 Model的工具, dotnet-ef>
            "dotnet ef migrations add InitialCreate"
              (註: 依照慣例, 第1次移轉的取名為 InitialCreate; 之後可以改為 add Column_Desc..)
            "dotnet ef database update" 
              (註: 使用最近1次移轉, 執行移轉內的 Up 方法, 來新增資料庫.)
          
          # <Dependency injection 關注點注入, 這就是DI>
            1. MVC中的 "Model", 是由1個實體類別(/Model/Movie.cs) 和 1個Context Object(/Data/MvcMovieContext.cs)所組成的, 它代表資料庫中的一個Session. (2022/05/18)
            2. 1個 Database Context Object允許查詢和儲存資料, 它繼承自 Microsoft.EntityFrameworkCore.DbContext
            3. (自己註解: DbContext 像是虛擬資料庫, 而每一個DbSet<T> or DbSet<Movie>表示 每筆資料實體, 可以取得其屬性.)
            4. 首先, 把整個網站要用的服務在 Program.cs 檔案內註冊. (註: Program.cs 是整個網站的啟始點.)
            
            範例程式碼:
              builder.Services.AddDbContext<MvcMovieContext>(options =>
                options.UseSqlite(builder.Configuration.GetConnectionString("MvcMovieContext") ?? throw new InvalidOperationException("Connection string 'MvcMovieContext' not found.")));

            5. 接著, Controllers/MoviesController.cs 檔案內, 將 MvcMovieContext DI(注入) 到Controller內. 因為 MvcMovieContext 提供 Controller 所需的資料庫CRUD功能.
          
          # <檢視資料庫的連接字串>
            6. appsettings.json 的 "ConnectionStrings" 區段, 

              "ConnectionStrings": {
              "MvcMovieContext": "Data Source=.db",
              "ProductionMvcMovieContext": "Data Source=xxxx.xxx.xxx."

          # 關於 InitialCreate class類別
            7. 位置: Migrations/{timestamp}_InitialCreate.cs migration file:
            
            Up方法 => 新增 Movie 資料表, 設定 Id 為主鍵
            Down方法 => 回復 Up方法的 Schema變更

          # 控制器(Controller)內的 DI
            8.  位置: Controllers/MoviesController.cs file:

            MoviesController初始化時, 把 MvcMovieContext 注入在控制器內, 使得CRUD作業得以在控制器中執行.

            public class MoviesController : Controller
            {
              private readonly MvcMovieContext _context;
              public MoviesController(MvcMovieContext context)
              {
                  _context = context;
              }

          # 檢視(View)中的強型別模型(strongly typed models)及 @model指示詞 
            9. ViewData["..."] 提供一個便利方式, 讓後端資料傳遞至前端檢視. 
              使用方式1: 後端把值放入 ViewData["..."] = "XXX"; 前端再利用右側寫法 @ViewData["..."], 取值後放在HTML中顯示.
              使用方式2: @{ ViewData["..."] = "首頁"; } 可修改內容值後, 再放在HTML中, 再取值.
            
            10. View(movie) 提供另一種方式.
              使用方式3: 後端 return View(movie); 抛至前端, 
                前端View頁面 
                  最上方宣告 @model MvcMovie.Models.Movie 後, 
                  再利用右側寫法 @Html.DisplayFor(model => model.屬性名稱); 
                  注意寫成 @Html.DisplayFor(ob => ob.屬性名稱)也可以;

              使用方式4: 後端 return View(await _context.Movie.ToListAsync()); 抛回清單至前端.
                前端View頁面
                  最上方宣告 @model IEnumerable<MvcMovie.Models.Movie> 集合
                  再利用右側寫法 @foreach (var item in Model) {... @Html.DisplayFor(modelItem => item.Title) ...} 顯示集合內容

          # controller/action/id
                  下列兩種方式, 都能將 id=1 傳給Controller
                  https://localhost:5001/movies/details/1
                  https://localhost:5001/movies/details?id=1

            > 回傳單筆
              * return View(movie); // Controller 將挑出來的Model, 回傳給View使用
              * @model MvcMovie.Models.Movie // View在頁面先定義後, 即可使用
              * Model 物件是強型別 // @Model.Id, 就能抓取 movie.Id 值.

            > 回傳清單
              * return View(await _context.Movie.ToListAsync()); // 存取DB後, 以非同步方式回傳多筆給View // 使用非同步函式, 記得加上 await
              * @model IEnumerable<MvcMovie.Models.Movie> // View抓到的是 可列舉的清單
              * @foreach (var item in Model) // 使用迴圈逐一存取項目

            > SQL Logging of Entity Framework Core
              * 在appsettings.json內, 加入下列LOGGING設定 {,"Microsoft.EntityFrameworkCore.Database.Command": "Information"}
                "Logging": {
                  "LogLevel": {
                    "Default": "Information",
                    "Microsoft": "Warning",
                    "Microsoft.Hosting.Lifetime": "Information"
                  ,"Microsoft.EntityFrameworkCore.Database.Command": "Information"
                  }
                },

        /*== Part 5, work with a database in an ASP.NET Core MVC app 關於與資料庫間的協作, 餵資料 ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/working-with-sql?view=aspnetcore-6.0&tabs=visual-studio
          1. DbContext 最主要的功能在於 (1)連接資料庫 和 (2)Model與資料庫記錄間的對應.
          2. DbContext 會在 Program.cs 內註冊(DI)
            
            builder.Services.AddDbContext<MvcMovieContext>(options => 
              options.UseSqlite(builder.Configuration.GetConnectionString("MvcMovieContext")));

            一般而言, 本機開發時, ConnectionStrings會儲存在 appsettings.json內
            "ConnectionStrings": {
              "MvcMovieContext": "Data Source=MvcMovie.db"
            }
  
            (註: Entity Framework Core migrations 使用限制, 功能不完全)
            dotnet ef migrations add Add_Column_Desc (註: 產生欄位新增的移轉指令時, 可執行成功.)
            dotnet ef database update (註: 但是實際異動Schema時, 卻會出現失敗.)
            
            下列功能都仍未提供.
              Creating a new table.
              Copying data from the old table to the new table.
              Dropping the old table.
              Renaming the new table.
            
            SQLite手動變更指令, 請參考: https://sqlite.org/lang_altertable.html

            因此, 官方建議開發階段, 刪除DB & 重新新增DB

          [Seed the database 餵資料]
          3. 新增 /Models/SeedData.cs 檔案, 加入下列程式碼

            using Microsoft.EntityFrameworkCore;
            using Microsoft.Extensions.DependencyInjection;
            using System;
            using System.Linq;

            namespace MvcMovie.Models
            {
                public static class SeedData
                {
                    public static void Initialize(IServiceProvider serviceProvider)
                    {
                        
                        using (var context = new MvcMovieContext(
                            serviceProvider.GetRequiredService<
                                DbContextOptions<MvcMovieContext>>()))
                        {
                            // Look for any movies.
                            //註: 自己加上去的, 因為 public DbSet<MvcMovie.Models.Movie>? Movie { get; set; } 可能為NULL, 可是官方範例沒改到..
                            if (context.Movie is not null) 
                            {
                              if (context.Movie.Any())
                              {
                                  return;   // DB has been seeded
                              }
                            
                            context.Movie.AddRange(
                                new Movie
                                {
                                    Title = "當哈利遇到瑪麗",
                                    ReleaseDate = DateTime.Parse("1989-2-12"),
                                    Genre = "Romantic Comedy",
                                    Price = 7.99M
                                },

                                new Movie
                                {
                                    Title = "魔鬼剋星",
                                    ReleaseDate = DateTime.Parse("1984-3-13"),
                                    Genre = "Comedy",
                                    Price = 8.99M
                                },

                                new Movie
                                {
                                    Title = "小鬼頭哈哈笑",
                                    ReleaseDate = DateTime.Parse("1986-2-23"),
                                    Genre = "Comedy",
                                    Price = 9.99M
                                },

                                new Movie
                                {
                                    Title = "赤膽屠龍",
                                    ReleaseDate = DateTime.Parse("1959-4-15"),
                                    Genre = "Western",
                                    Price = 3.99M
                                }
                            );
                            context.SaveChanges();
                            }
                        }
                    }
                }
            }
          4. 接著 Program.cs 預先執行, 才會有效果.

            using MvcMovie.Models; //新增

            builder.Services.AddControllersWithViews();
            var app = builder.Build();

            using (var scope = app.Services.CreateScope()) //新增
            {
                var services = scope.ServiceProvider; //新增
                SeedData.Initialize(services); //新增
            }

        /*== Part 6, controller methods and views in ASP.NET Core 關於控制器的異動欄位保護, 檢視畫面的資料檢查 ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/controller-methods-views?view=aspnetcore-6.0

          [Processing the POST Request 處理異動資料]
          1. 增加資料欄位細節 @ /Models/Movie.cs

            using System.ComponentModel.DataAnnotations;
            using System.ComponentModel.DataAnnotations.Schema;

            [Display(Name = "發行日期")]
            [DataType(DataType.Date)]
            public DataTime ReleaseDate {get;set;} //[Display(Name = "發行日期")] 沒加的話, 預設用欄位名稱顯示.

            [Column(TypeName = "decimal(18,2)")]
            public decimal Price {get;set;} //[Column(TypeName = "decimal(18,2)")], EF Core 6.0 指定欄位型態

          2. <Tag Helper> 允許後端程式碼加在前端 XXX.cshtml檔案內, 例: @item.Id
            <Tag Helper> 也是一個很重要的必學項目, 它有很多種類, 
            例: Form Tag Helper, Label Tag Helper, Input Tag Helper, Validation Tag Helper
              <form asp-action="Edit">
              <div asp-validation-summary="ModelOnly" class="text-danger"></div>
              <label asp-for="Price" class="control-label"></label>
              <input asp-for="Price" class="form-control" />
              <span asp-validation-for="Price" class="text-danger"></span>

            原始碼: 
                      <a asp-action="Edit" asp-route-id="@item.Id">Edit</a> |
                      <a asp-action="Details" asp-route-id="@item.Id">Details</a> |
                      <a asp-action="Delete" asp-route-id="@item.Id">Delete</a>
                  </td>
              </tr>

            產生後: (註: 它會利用 Program.cs 內指定路由規則來產生, pattern: "{controller=Home}/{action=Index}/{id?}")
              <td>
                  <a href="/Movies/Edit/4"> Edit </a> |
                  <a href="/Movies/Details/4"> Details </a> |
                  <a href="/Movies/Delete/4"> Delete </a>
              </td>

          3. 控制器(Controller)中 GET Task 及 POST Task 的不同處理方式.

            // GET: Movies/Edit/5
            // 可以加上[HttpGet], 但沒必要, 因為它是預設的
            [HttpGet]
            public async Task<IActionResult> Edit(int? id)
              {
                if (id == null)
                {
                  return NotFound();
                }

                var movie = await _context.Movie.FindAsync(id);
                if (movie == null)
                {
                  return NotFound();
                }
                return View(movie);
              }

            // POST: Movies/Edit/5
            // To protect from overposting attacks, enable the specific properties you want to bind to.
            // For more details, see http://go.microsoft.com/fwlink/?LinkId=317598.
            
            // 防止 over-posting的產生的方式1(似乎比較直覺): [Bind("加入開放變更的欄位項目") Movie movie]
            // 防止 over-posting的產生的方式2: ViewModel (https://rachelappel.com/use-viewmodels-to-manage-data-amp-organize-code-in-asp-net-mvc-applications/)

            // 防止 XSRF 跨站請求偽造攻擊, 加上這個 [ValidateAntiForgeryToken] 後, 會產生隱藏token, 比對回傳網頁token和Controller是否一致.

            [HttpPost]
            [ValidateAntiForgeryToken]
            public async Task<IActionResult> Edit(int id, [Bind("Id,Title,ReleaseDate,Genre,Price")] Movie movie)
              {
                if (id != movie.Id)
                {
                  return NotFound();
                }

                if (ModelState.IsValid)
                {
                  try
                  {
                    _context.Update(movie);
                    await _context.SaveChangesAsync();
                  }
                  catch (DbUpdateConcurrencyExceptoin)
                  {
                    if (!MovieExists(movie.Id))
                    {
                      return NotFound();
                    }
                    else
                    {
                      throw;
                    }
                  }
                  return RedirectToAction(nameof(Index));
                }
                return View(movie);
              }

          * [Bind] 屬性是一種方式, 用來防止 over-posting 攻擊.
          * [Bind] 限制要變更的屬性項目, 
              [HttpPost]
              [ValidateAntiForgeryToken]
              public async Task<IActionResult> Edit(int id, [Bind("ID,Title,ReleaseDate,Genre,Price")] Movie movie)
          * 另一種防止 over-posting 攻擊的方式, ViewModels
          
          * [ValidateAntiForgeryToken], 用來防止 XSRF/CSRF 攻擊, 
              它會去檢查 Form Tag Helper 產生的TOKEN, 通常放在最後面, 長的像下列碼
              <input name="__RequestVerificationToken" type="hidden" value="CfDJ8Inyxgp63fRFqUePGvuI5jGZsloJu1L7X9le1gy7NCIlSduCRx9jDQClrV9pOTTmqUyXnJBXhmrjcUVDJyDUMm7-MF_9rK8aAZdRdlOri7FmKVkRe_2v5LIHGKFcTjPrWPYnc9AdSbomkiOSaTEg7RU" />
          
          * Label Tag Helper, 用來顯示名稱
          * Input Tag Helper, 用來產生輸入欄位
          * Validation Tag Helper, 用來顯示與屬性相關的驗證結果訊息

          !! 注意 !! 
            [HttpGet] 屬性是預設值, 可加可不加.
              千萬不要在 [HttpGet] Action方法內, 異動資料, 有資安上的風險.
            [HttpPost] 屬性則是 新增, 修改, 刪除及其他異動資料時, 使用的.
              要特別加註上去.

        /*== Part 7, add search to an ASP.NET Core MVC app 檢視畫面增加搜尋, 控制器對應的調整 ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/search?view=aspnetcore-6.0
          [原理說明]
            0. 一元運算的後置!功能(null-forgiving), 表示這個運算式不是NULL. 
                例: string? Title = ""; Title變數是 nullable. 
                  如果使用 Title 時, 明確加上 Title! 表示跟編譯器說, 這時候它不是NULL
                  https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving

            0. Linq命令會使用 Lambda 語法, LINQ queries are not executed when they're defined or 
              when they're modified by calling a method such as "Where", "Contains", or "OrderBy".
            0. Linq命令通常不會當下執行, 而會 延遲到 "開始取值" 或 "ToListAsync()" 這類方法呼叫時才會執行.
              https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/query-execution
            0. Linq關鍵字 Where & Contains 間的差異, Where回傳 IEnumerable, Contains回傳 bool, 所以要使用Where

            1. Index的清單畫面中, 增加名稱搜尋功能. (調整 /Controllers/MoviesController.cs)
            1. 最直覺的方式, 還是程式員提供查詢欄位, 而不是由使用者自行修改網址.

              // https://localhost:7076/Movies?searchString=查詢字串
                public async Task<IActionResult> Index(string searchString)
                {
                  var movies = from m in _context.Movie 
                                select m;
                  if (!String.IsNullOrEmpty(searchString)) // !前置, 表示Not
                  {
                    movies = movies.Where(s => s.Title!.Contains(searchString)); // 後置!, 表示 Not null
                  }
                  return View(await movies.ToListAsync()); 
                }
              // https://localhost:7076/Movies/index/查詢字串
                public async Task<IActionResult> Index(string id)
                {
                    var movies = from m in _context.Movie
                                select m;

                    if(!String.IsNullOrEmpty(id))
                    {
                        movies = movies.Where(s => s.Title!.Contains(id));
                    }
                    return View(await movies.ToArrayAsync());
                }

            2. 使用 method="get" 指定前端以GET方式將資料送至後端, 後端當然也要有對應[HttpPost] or [HttpGet] 方法
              之間差異在於 
              (1) POST 送出時, 會有 "1串隱藏碼" 避免XSRF攻擊, 所以你要重新篩選結果的網址會失敗.
              (2) GET 送出時, Form內的查詢字串會放在網址, 沒有 "1串隱藏碼" 問題, 便於分享或作書籤使用.
              (3) 後端方法如果沒有 [HttpPost] or [HttpGet], 前端無論以 GET OR POST 送都能接, 預設前端以 GET 後送的資料 
              (4) 後端方法如果加上 [HttpPost], 只接前端 以 POST 後送的資料.
              (5) 前端方法 加上 method="get" 後, 限定以 GET 將資料送至後端
              (6) 前端方法 未加上 method="get" 時 , 預設以 POST 將資料送至後端

          [Add Search by genre 程式碼調整]

            > Add Search by genre (by HttpGet)
              * 不需要用 HttpPost, 就能達成篩選目的.
              * 使用 HttpGet, 查詢字串會放在URL內.

              // Controller.cs
              public async Task<IActionResult> Index(string searchString)
              {
                  var movies = from m in _context.Movie
                                select m;
                  if (!String.IsNullOrEmpty(searchString))
                  {
                      movies = movies.Where(s => s.Title.Contains(searchString));
                  }
                  return View(await movies.ToListAsync());
              }

              // View.cshtml
              @* 新增查詢欄位, 指定用[HttpGet]方式傳送, 即使Controller有[HttpPost]的Action, 一樣不會跑進去 *@
              <form asp-controller="Movies" asp-action="Index" method="GET">
                  <p>
                      名稱: <input type="text" name="searchString">
                      <input type="submit" value="篩選">
                  </p>
              </form>

            > Add search by genre to the Index View (by ViewModel)
              // MvcMovie.Models.MovieGenreViewModel.cs
              using Microsoft.AspNetCore.Mvc.Rendering;
              using System.Collections.Generic;
              namespace MvcMovie.Models
              {
                  public class MovieGenreViewModel
                  {
                      public List<Movie> Movies { get; set; }
                      public SelectList Genres { get; set; }
                      // User Selected Genre
                      public string MovieGenre { get; set; }
                      // User Input SearchString
                      public string SearchString { get; set; }
                  }
              }

              // Controller.cs
              public async Task<IActionResult> Index(string movieGenre, string searchString)
                {
                    IQueryable<string> genreQuery = from m in _context.Movie
                                                    orderby m.Genre
                                                    select m.Genre;
                    var movies = from m in _context.Movie
                                select m;

                    if(!string.IsNullOrEmpty(searchString))
                    {
                        movies = movies.Where(s => s.Title.Contains(searchString));
                    }

                    if(!string.IsNullOrEmpty(movieGenre))
                    {
                        movies = movies.Where(s => s.Genre == movieGenre);
                    }

                    var movieViewModel = new MovieGenreViewModel
                    {
                        Genres = new SelectList(await genreQuery.Distinct().ToListAsync())
                        , Movies = await movies.ToListAsync()
                    };
                    return View(movieViewModel);
                }
              
              // View.cshtml
              @model MvcMovie.Models.MovieGenreViewModel
              @* 新增查詢欄位, 使用 ViewModel *@
              <form asp-controller="Movies" asp-action="Index" method="get">
                  <p>
                      類型: <select asp-for="MovieGenre" asp-items="Model.Genres">
                          <option value="">All</option>
                      </select>
                      <br>
                      名稱: <input type="text" name="searchString">
                      <input type="submit" value="篩選">
                  </p>
              </form>

          [Add search by genre to the Index view 程式碼調整] # 進階功能-多欄位篩選 #

            3. 利用 ViewModel , 實現多欄位篩選功能.

              檔案: /Models/MovieGenreViewModel.cs

                using Microsoft.AspNetCore.Mvc.Rendering;
                using System.Collection.Generic;
                namespace MvcMovie.Models;

                public class MovieGenreViewModel
                {
                  public List<Movie>? Movies {get;set;} //可供顯示的電影清單
                  public SelectList? Genres {get;set;} //可供選擇的類別清單
                  public string? MovieGenre {get;set;} //使用者選擇的類別項目
                  public string? SearchString {get;set;} //使用者輸入的查詢字串
                }

              檔案: /Controllers/MoviesController.cs

                public async Task<IActionResult> Index(string movieGenre, string searchString)
                {
                  //調整下列項目
                  
                  //抓出可供選擇的類別清單
                  IQueryable<string> genreQuery = from m in _context.Movies
                                                  orderby m.Genre
                                                  select m.Genre;

                  //抓出可供顯示的電影清單
                  var movies = from m in _context.Movies
                              select m;

                  if(!String.IsNullOrEmpty(searchString))
                  {
                    movie = movies.Where(s => s.Title!.Contains(searchString));
                  }

                  if(!String.IsNullOrEmpty(movieGenre))
                  {
                    movies = movies.Where(s => s.Genre == movieGenre);
                  }

                  var movieGenreVM = new MovieGenreViewModel
                  {
                    Genre = new SelectList(await genreQuery.Distinct().ToListAsync()),
                    Movies = await movies.ToListAsync()
                  }

                  return View(movieGenreVM);
                }
                
              檔案: /Views/Movies/Index.cshtml

                @model MvcMovie.Models.MovieGenreViewModel <!-- 因為控制器Controller return View(movieGenreVM), 所以要先宣告才能用. -->

                <!--加入下列程式碼-->
                <select asp-for="MovieGenre" asp-item="Model.Genres"> <!-- 加入選擇清單 -->
                  <option value="">All</option>
                </select>

                <!--調整下列程式碼-->
                <table class="table">
                    <thead>
                        <tr>
                            <th>
                                @Html.DisplayNameFor(model => model.Movies[0].Title) <!--調整-->
                            </th>
                            <th>
                                @Html.DisplayNameFor(model => model.Movies[0].ReleaseDate) <!--調整-->
                            </th>
                            <th>
                                @Html.DisplayNameFor(model => model.Movies[0].Genre) <!--調整-->
                            </th>
                            <th>
                                @Html.DisplayNameFor(model => model.Movies[0].Price) <!--調整-->
                            </th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                      @foreach (var item in Model.Movies) <!--調整-->
                      {
                        <tr>
                            <td>
                                @Html.DisplayFor(modelItem => item.Title)
                            </td>
                            <td>
                                @Html.DisplayFor(modelItem => item.ReleaseDate)
                            </td>
                            <td>
                                @Html.DisplayFor(modelItem => item.Genre)
                            </td>
                            <td>
                                @Html.DisplayFor(modelItem => item.Price)
                            </td>
                            <td>
                                <a asp-action="Edit" asp-route-id="@item.Id">Edit</a> |
                                <a asp-action="Details" asp-route-id="@item.Id">Details</a> |
                                <a asp-action="Delete" asp-route-id="@item.Id">Delete</a>
                            </td>
                        </tr>
                      }
                    </tbody>
                </table>

              # 問題: 出現 warning CS8618: 退出建構函式時，不可為 Null 的 屬性 'Name' 必須包含非 Null 值
              # 官方說明: https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/compiler-messages/nullable-warnings

              解決方案1: 將 'Name' 宣告為 Nullable 型別
              public class Products
              {
                public int Id{get;set;} //ProductID
                public string? Name{get;set;} //ProductName
                public int? Price{get;set;} //ProductPrice
              }

              解決方案2: 給 'Name' 預設""值
              public class Products
              {
                public int Id{get;set;} //ProductID
                public string? Name{get;set;} = string.Empty; //ProductName
                public int? Price{get;set;} = string.Empty; //ProductPrice
              }

              # 問題: 出現 warning CS8602: 可能 null 參考的取值 (dereference) 警告 #
              https://docs.microsoft.com/en-us/ef/core/miscellaneous/nullable-reference-types

                因為 C# 8 以後引進了 nullable的型別, 編譯器會自動偵測, 並提醒可能會出現NULL的宣告上要加上 '?' .
                但是編譯時, 就會經常出現 warning CS8602 的困擾, 如果你確認物件不可能為NULL, 可以使用加上 後置'!' => 一元運算的後置!功能(null-forgiving), 表示這個運算式不是NULL.

                例1: public string? Title {get; set;}
                例2: public SelectList? Genres { get; set; } //可供選擇的類別清單

                例3: public string ProductName {get;set;} = ""; //如果不使用 nullable的型別, 宣告時可以加上預設值(default value), 警告就會消失了..

              # 解決方法: 下面記錄了我花兩小時解決的警告(nullable 型別), 幸好最後有解決, 發生在 View 檢視畫面出現 'warning CS8602' 的問題.

                檔案: \Models\MovieGenreViewModel.cs
                  
                  public class MovieGenreViewModel
                  {
                    public List<Movie>? Movies { get; set; } //因為 Movies is nullable(可能為NULL的型別)
                    public SelectList? Genres { get; set; } 
                    public string? MovieGenre { get; set; } 
                    public string? SearchString { get; set; } 
                  }
                
                檔案: \Views\Movies\Index.cshtml
                  @model MvcMovie.Models.MovieGenreViewModel

                  @Html.DisplayNameFor(m => m.Movies![0].Title) //如果沒有在 m.Movies![0] 加上'!', 就會出現 'warning CS8602' 的警告, 程式不會出錯, 只是有警告.

                  @foreach (var item in Model.Movies!) { //這裡也要加上 '!', 在變數後置'!'功能(null-forgiving), 表示這個運算式不是NULL.
                    <tr>
                        <td>
                            @Html.DisplayFor(modelItem => item.Title)

        /*== Part 8, add a new field to an ASP.NET Core MVC app 新增資料欄位, 及相關程式碼更新(檢視畫面, Controller [Bind]) ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/new-field?view=aspnetcore-6.0&tabs=visual-studio
          1. (EF Code First方式) 常用於
            [Add a new field to the model]
            [Migrate the new field to the database]

          2. 另外, 使用 (EF Code First方式) 來新增資料庫, 可擁有下列優點:
            # 追蹤資料表綱要Schema的變更
            # 確認 model 類別與 資料庫欄位是否一致. 若不一致, 則 EF會丟例外

          [Add a Rating Property to the Movie Model]

            檔案: /Models/Movie/
            public string? Rating {get;set;}

            接著執行指令 "dotnet build"

            檔案: /Controllers/MoviesController
            修改 [Bind] 內容, 在 Create & Edit 方法內, 加入Rating

            檔案: /Views/Movies
            Index & Create & Delete & Details & Edit 都要一起修改

          (註: Entity Framework Core migrations 使用限制, 功能不完全)
            dotnet ef migrations add Add_Column_Desc (註: 產生欄位新增的移轉指令時, 可執行成功.)
            dotnet ef database update (註: 但是實際異動Schema時, 卻會出現失敗.)
            
            下列功能都仍未提供.
              Creating a new table.
              Copying data from the old table to the new table.
              Dropping the old table.
              Renaming the new table.
            
            SQLite手動變更指令, 請參考: https://sqlite.org/lang_altertable.html
            因此, 官方建議開發階段, 刪除DB & 重新新增DB

        /*== Part 9, add validation to an ASP.NET Core MVC app 將 '驗證規則' 加至Model內, 並且確保使用者在新增及修改時, 均能套用 '驗證規則' ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/validation?view=aspnetcore-6.0
          [Keeping things DRY]
            1. MVC & EF Core Code First是 DRY很好的實踐.
            2. 將 '驗證規則' 放在 Model中, 而且這些規則會強制套用至整個網站

          [Add validation rules to the movie model]
            1. using System.ComponentModel.DataAnnotations; 
              DataType 屬性 => (只有資料格式化), 無資料檢查
              Required 屬性 => 資料檢查
              StringLength 屬性 => 資料檢查(預設最大; 最小長度)
              RegularExpression 屬性 => 資料檢查(RegularExpression)
              Range 屬性 => 資料檢查(數值範圍, 例: 1-100)

            2. using System.ComponentModel.DataAnnotations.Schema;
              [Column(TypeName = "decimal(18, 2)")] => 定義資料庫欄位型態 & 指定為必填欄位
              Value types (such as decimal, int, float, DateTime) are inherently required and don't need the [Required] attribute

          [Validation Error UI]
            1. Validation 在 Client Side & Server Side 都會套用.
            2. 最明顯的效益是 => 驗證屬性只須在 Model 內調整, Controller & Create View 都不用修改
            3. 同樣地, Edit View 也不用修改
          
          [How validation works]
            1. 驗證發生的時間點有二: 
              (1) 前端 by JavaScript, 
              (2) 當前端JavaScript被關掉後, 後端會再驗證1次
                if (ModelState.IsValid) //當前端JavaScript被關掉後, 後端會再驗證1次
                {
                    _context.Add(movie);
                    await _context.SaveChangesAsync();
                    return RedirectToAction(nameof(Index));
                }
                return View(movie);
          
            2. Controller & Create View 都不會知道 "驗證規則" & "驗證錯誤的訊息"
                The (Input Tag Helper) uses the (DataAnnotations attributes) and produces HTML attributes needed for jQuery Validation on the client side. 
                The (Validation Tag Helper) displays validation errors.
                
                節錄自 Create.cshtml
                <div class="form-group">
                    <label asp-for="Title" class="control-label"></label>
                    <input asp-for="Title" class="form-control" />
                    <span asp-validation-for="Title" class="text-danger"></span>
                </div>

          [Using DataType Attributes]
            1. using System.ComponentModel.DataAnnotations;
              DataType 屬性 => (只有資料格式化), !! 無任何資料檢查功能 !!
              已內建多種資料格式. such as Date, Time, PhoneNumber, Currency, EmailAddress and more

            2. 另外, 也可以使用 [RegularExpression(@"^[A-Z]+[a-z]+[0-9]*$")] 方式作資料格式檢查.
            3. 注意, [DataType(DataType.Date)] 無法指定日期格式, 日期格式會依伺服器的 CultureInfo 而定.
            4. 如果, 需要指定日期格式, 請考慮使用下列方式(不建議, 維持 [DataType(DataType.Date)] 是比較好的作法):

              [DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]
              public DateTime ReleaseDate { get; set; }

            5. 優點, 使用 [DataType(DataType.Date)] 顯示日期欄位的優點
              a. The browser can enable HTML5 features (for example to show a calendar control, the locale-appropriate currency symbol, email links, etc.)
              b. By default, the browser will render data using the correct format based on your locale.
              c. The DataType attribute can enable MVC to choose the right field template to render the data (the DisplayFormat if used by itself uses the string template).

            6. 不建議, 把 [Range] 屬性 和 DateTime放在一起用.
              
              [Range(typeof(DateTime), "1/1/1966", "1/1/2020")]
              因為上列用法會造成 jQuery驗證功能失效

          [Additional resources]
            Working with Forms https://docs.microsoft.com/en-us/aspnet/core/mvc/views/working-with-forms?view=aspnetcore-6.0
            Globalization and localization https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-6.0
            Introduction to Tag Helpers https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-6.0
            Author Tag Helper https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/authoring?view=aspnetcore-6.0

        /*== Part 10, examine the Details and Delete methods of an ASP.NET Core app 檢視資料明細及刪除頁面 ==*/
          https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/details?view=aspnetcore-6.0
          1. 它會根據 Program.cs 內的路由規則, 將request傳至(Details) 方法.
            重點在於 
              (1)先判斷傳入的ID是否為空值(NULL), 若為空值, 要丟給 NotFound() 頁面.
              (2)再判斷ID值是否有對應的object, 若為空值, 也要丟給 NotFound() 頁面.
              (3)抓到你要的object後, 再作邏輯運算.

          2. 如果沒有先檢查空值, 出現系統異常時, 例外狀況曝露的資訊可能會被駭客不當使用.
            
              檔案: /Program.cs
                app.MapControllerRoute(
                name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}"); //<==規則在這

              檔案: /Controllers/MoviesController.cs
                // GET: Movies/Details/5
                public async Task<IActionResult> Details(int? id) //<==方法在這, 網址: Movies/Details/5
                {
                    if (id == null || _context.Movie == null) //(1)先判斷傳入的ID是否為空值(NULL), 若為空值, 要丟給 NotFound() 頁面.
                    {
                        return NotFound();
                    }

                    var movie = await _context.Movie
                        .FirstOrDefaultAsync(m => m.Id == id);
                    if (movie == null) //(2)再判斷ID值是否有對應的object, 若為空值, 也要丟給 NotFound() 頁面.
                    {
                        return NotFound();
                    }

                    return View(movie);
                }

          3. 再來看 // Get: Movies/Delete/5 "Delete" & // Post: Movies/Delete/5 "DeleteConfirmed" 這兩個方法.
            檔案: Controllers/MoviesController.cs

            a. // Get: Movies/Delete/5 Delete, 它只有抓值顯示, 未實際刪除資料
            b. // Post: Movies/Delete/5 DeleteConfirmed, 它才是實際刪除資料的方法.

              // GET: Movies/Delete/5, 它只有抓值顯示, 未實際刪除資料
              public async Task<IActionResult> Delete(int? id)
              {
                  if (id == null)
                  {
                      return NotFound();
                  }

                  var movie = await _context.Movie
                      .FirstOrDefaultAsync(m => m.Id == id);
                  if (movie == null)
                  {
                      return NotFound();
                  }

                  return View(movie);
              }

              // 防止 XSRF 跨站請求偽造攻擊, 加上這個 [ValidateAntiForgeryToken] 後, 會產生隱藏token, 比對回傳網頁token和Controller是否一致.
              // POST: Movies/Delete/5, 它才是實際刪除資料的方法.
              [HttpPost, ActionName("Delete")]
              [ValidateAntiForgeryToken] 
              public async Task<IActionResult> DeleteConfirmed(int id)
              {
                  var movie = await _context.Movie.FindAsync(id);
                  _context.Movie.Remove(movie);
                  await _context.SaveChangesAsync();
                  return RedirectToAction(nameof(Index));
              }

          4. 如何在 Controller 重載方法(Action), 1個給GET使用, 另1個給POST使用

            a. 方法1:
              // Get
              public async Task<IActionResult> Delete(int? id)

              // Post
              [HttpPost, ActionName("Delete")]
              [ValidateAntiForgeryToken]
              public async Task<IActionResult> DeleteConfirmed(int id)

            b. 方法2:
              // Get
              public async Task<IActionResult> Delete(int? id)

              // Post
              [HttpPost]
              [ValidateAntiForgeryToken]
              public async Task<IActionResult> Delete(int id, bool notUsed)

  {完成}-ASP.NET Core MVC 概觀 (MVC > Overview) (2021/07/08)
      https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-5.0
        > 什麼是MVC模式?
          1. M = Model(模型), V = View(檢視), C = Controller(控制器).
          2. 關注點分離(SOC)是拆分為MVC的優點之一.
          3. View & Controller都相依於Model, 
              但Model不相依於View or Controller, 這是分離的主要優點之一.

          > Model職責
            1. 保存應用程式狀態, 商務邏輯或作業.
            2. 商務邏輯應與保存應用程式狀態的實作邏輯, 一起封裝在模型中.
            3. 強型別檢視 常會使用 {ViewModel類型}, 目於在於包含要在檢視上顯示的資料.
            4. Controller 會從 Model 建立, 並填入這些 ViewModel類型 執行個體.
            
          > View職責
            1. 檢視會負責透過使用者介面展示內容。
            2. 它們使用 Razor view engine將 .net 程式碼內嵌在 HTML 標籤中。 
            3. 檢視內應該有基本邏輯，而且 {其中的任何邏輯都應該與展示內容相關}。 
            4. 如果您需要在檢視檔案中執行大量邏輯以便顯示複雜模型中的資料，
                請考慮使用 {檢視元件、ViewModel 或檢視範本} 來簡化檢視。

          > Controller職責
            1. 控制器是處理使用者互動、使用模型，並在最終選取要呈現之檢視的元件。 
            2. 在 MVC 應用程式中，檢視只會顯示資訊，而控制器則會處理及回應使用者輸入和互動。 
            3. 在 MVC 模式中，控制器是初始進入點，負責選取要使用的模型類型及要呈現的檢視 
                (如其名稱所指，它會控制應用程式回應指定要求的方式)。
            
            !! Notice !!: Controller不應該太過複雜, 如有太多商務邏輯請移至 {領域模型} 中.
            !! Notice !!: Controller經常執行相同動作類型時, 請將常用動作移至 {篩選} 中.
          
        > 什麼是 ASP.NET Core MVC
          1. 它是一個架構, 輕量型, 開放原始碼及可高度測試的架構.
          2. 可建立動態網站, 套用SOC. 可掌握HTML標記, 適合TDD開發, 並使用最新網站標準.

        > 功能
          > 路由
            1. 以 {慣例為基礎的路由}, 可定義全域AP能接受的URL格式, 及這些URL格式如何對應至指定控制器的特定動作方法.
              routes.MapRoute(name: "Default", template: "{controller=Home}/{action=Index}/{id?}");
            2. {屬性路由}, 指定路由屬性, 來裝飾這些控制器及動作方法.
              [Route("api/[controller]")]
              public class ProductsController : Controller
              {
                  [HttpGet("{id}")]
                  public IActionResult GetProduct(int id)
                  {
                    ...
                  }
              }
          
          > 模型繫結
            1. 自動將用戶端REQUEST資料, 轉換為Controller可處理的物件.
            2. Controller不必管資料內容, 它只會將資料當作動作方式的參數.

              public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null) { ... }

              // https://localhost:5001/Helloworld/welcome?name=KL&numTimes=25
              // 控制器會自動對應 "網址參數(?後面的值)".
              public string Welcome(string name = "Jack", int numTimes = 1)

              // https://localhost:5001/helloworld/welcome/50?name=Leo&age=25
              // 控制器也會自動對應 "Routing URL", 
              // 參考路由定義, routes.MapRoute(name: "Default", template: "{controller=Home}/{action=Index}/{id?}");
              // id?, 有個?表示它是選項欄位.
              public string Welcome(string name = "Judy", int ID = 1, int age = 28)

          > 模型驗證
            1. 指定資料註解{驗證屬性}, 來裝飾這些模型物件.
            2. 用戶端先檢查, 伺服器端再檢查, 最後再呼叫控制器動作.

              // 指定資料註解{驗證屬性}, 來裝飾這些模型物件.
              using System.ComponentModel.DataAnnotations;
              public class LoginViewModel
              {
                  [Required]
                  [EmailAddress]
                  public string Email { get; set; }

                  [Required]
                  [DataType(DataType.Password)]
                  public string Password { get; set; }

                  [Display(Name = "Remember me?")]
                  public bool RememberMe { get; set; }
              }

              // 控制器動作
              public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null)
              {
                  if (ModelState.IsValid)
                  {
                    // work with the model
                  }
                  // At this point, something failed, redisplay form
                  return View(model);
              }

          > 相依性插入
            1. 方式1: 在控制器中, 利用建構函式要求所需的服務.
            2. 方式2: 在檢視中, 利用 @inject 指示詞 使用所需的服務.

              @inject SomeService ServiceName

              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <title>@ServiceName.GetTitle</title>
              </head>
              <body>
                  <h1>@ServiceName.GetTitle</h1>
              </body>
              </html>

          > 篩選器
            1. 時機: 常用於{例外狀況處理}或{授權}.
            2. 功能: 篩選可執行動作方法的自訂處理前後邏輯，並可設定為在指定要求之執行管線內的特定時間點執行。
            3. 套用: 把篩選作為屬性套用於控制器、動作或全域執行.

              [Authorize]
              public class AccountController : Controller

          > 區域
            1. 時機: 大型電子商務應用程式, 可區分為多個BU, 例: 結帳、帳單、商品查詢等不同功能別.
            2. 功能: 將程式拆解為 個別自行運作的單元模組, 每個單元模組擁有各自的MVC架構.

          > Web API
            1. ASP.NET Core MVC 支援Web API.
            2. 支援 格式化資料 JSON OR XML.
            3. 支援 跨原始來源資源共用 (CORS).

          > 可測試性
            1. ASP.NET Core MVC 使用 相依性插入(DI)概念, 服務適合於單元測試.
            2. 例: 利用Entiry Framework 的 TestHost & InMemory, 進入整合測試.
          
          > Razor 查看引擎
            1. 簡單來說, 就是View裡面使用 內嵌C#程式碼, 再由Razor動態產生前端HTML內容.

              <ul>
                  @for (int i = 0; i < 5; i++) {
                      <li>List item @i</li>
                  }
              </ul>

          > 強型別檢視(View)
            0. 檢視內不應該 (1)執行商業邏輯, (2)與資料庫直接互動.
            0. 檢視內應該 (3)只使用控制器提供的資料, 以維持 Clean & Testable & Maintainable.
            1. Razor MVC 中的 views 可以根據您的模型以強型別為基礎。
            2. 控制器(Controller)可以將強型別模型(ViewModel)傳遞至檢視.
            2. !! (註: 首選作法, 使用 ViewModel傳資料給View, 而非使用 ViewData 集合來傳)
            3. 控制器(Controller)內的動作方法, 等同於檢視(View)檔案名稱.

              @model IEnumerable<Product>
              <ul>
                  @foreach (Product p in Model)
                  {
                      <li>@p.Name</li>
                  }
              </ul>

              // 例:return View(); 結果會傳給 Index.cshtml 檢視檔案作處理.
              public class HelloWorldController: Controller
              {
                  public IActionResult Index()
                  {
                    return View();
                  }
              }

          > HTML標籤協助程式
            1. 自訂HTML標籤內屬性(例:<environment>), 或變更現有HTML標籤行為(例:<label>)
            
              <!--例1: EnvironmentTagHelper 可根據執行階段環境 (例如開發、預備或生產)，將不同的指令碼加入檢視-->
              <environment names="Development">
                  <script src="~/lib/jquery/dist/jquery.js"></script>
              </environment>
              <environment names="Staging,Production">
                  <script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-2.1.4.min.js"
                          asp-fallback-src="~/lib/jquery/dist/jquery.min.js"
                          asp-fallback-test="window.jQuery">
                  </script>
              </environment>
              
              <!--例2: 變更現有HTML標籤行為, 點選下方的LINK, 它會導向 Account Controller 內的 Login Action -->
              <p>
                  Thank you for confirming your email.
                  Please <a asp-controller="Account" asp-action="Login">Click here to Log in</a>.
              </p>

          > 檢視元件
            1. 類似自訂控制項/部分檢視, 可在整個AP中重複使用.
            2. 將可共用的邏輯加以封裝

          > 區分環境別 by Startup.cs (for ASP.NET CORE MVC 架構)
            * 完整範例程式
              public Startup(IConfiguration configuration, IWebHostEnvironment env)
              {
                  Environment = env;
                  Configuration = configuration;
              }
              public IConfiguration Configuration {get;}
              private IWebHostEnvironment Environment {get;}
              public void ConfigureServices(IServiceCollection services)
              {
                  services.AddControllersWithViews();
                  services.AddDbContext<JobsContext>(options =>
                  {
                      var connectionString = Configuration.GetConnectionString("JobsContext");
                      if (Environment.IsDevelopment() || Environment.IsStaging())
                      {
                          Console.WriteLine(Environment.EnvironmentName);
                          Console.WriteLine("Now is IsDevelopment or IsStaging");
                          //connectionString = Configuration.GetConnectionString("JobsContext-Dev"); //重點在這裡.
                          options.UseSqlite(connectionString);
                      }
                      else
                      {
                          Console.WriteLine("Not dev or staging env.");
                          options.UseSqlServer(connectionString);
                      }
                  });            
              }

              // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
              public void Configure(IApplicationBuilder app)
              {
                  if (Environment.IsDevelopment())
                  {
                      app.UseDeveloperExceptionPage();
                  }
                  else
                  {
                      app.UseExceptionHandler("/Home/Error");
                      // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                      app.UseHsts();
                  }
                  app.UseHttpsRedirection();
                  app.UseStaticFiles();

                  app.UseRouting();

                  app.UseAuthorization();

                  app.UseEndpoints(endpoints =>
                  {
                      endpoints.MapControllerRoute(
                          name: "default",
                          pattern: "{controller=Home}/{action=Index}/{id?}");
                  });
              }
          
        > 安裝ORM套件(EntityFrameworkCore) #!-- 安裝工具或套件時, 千萬要注意是否跟 .NET SDK 版本 相容--#
            dotnet tool install --global dotnet-ef  //抓最新版安裝
            dotnet tool install --global dotnet-ef --version 6.0.10  //指定安裝6.0.10版
            dotnet add package Microsoft.EntityFrameworkCore.Design //專案引用套件
            dotnet add package Microsoft.EntityFrameworkCore.SQLite
            dotnet add package Microsoft.EntityFrameworkCore.SqlServer
            dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design

        > 安裝 ASP.NET Core Scaffolding 引擎  #!-- 安裝工具或套件時, 千萬要注意是否跟 .NET SDK 版本 相容--#
          (自動產生程式碼, 只適用於命令列cmd環境下)
            dotnet tool uninstall -g dotnet-aspnet-codegenerator
            dotnet tool install -g dotnet-aspnet-codegenerator --version 6.0.10 //指定安裝6.0.10版

        > {新增Model後}, 產生對應的Controller & View (ORM套件要先裝, 不然程式碼生不出來)
            dotnet-aspnet-codegenerator controller 
            -name JobsController 
            -m Jobs 
            -dc JobsContext 
            --relativeFolderPath Controllers 
            --useDefaultLayout 
            --referenceScriptLibraries
        
        > 測試用SQLite, 上線用SqlServer by Startup.cs

        > 接下來, 資料庫初始移轉(inital migration), 依據 JobsContext 所產生.

            dotnet ef migrations add InitialCreate
            dotnet ef database update
            dotnet ef database update -- --environment Development
            dotnet ef database update -- --environment Production

            問題:
              執行 "dotnet ef database update"後, 出現下列錯誤. 
              Connection string keyword 'server' is not supported. For a possible alternative, see https://go.microsoft.com/fwlink/?linkid=2142181.

            原因: 
              1. EF自動產生的是SQL Server用連接字串,不支援SQLite[測試環境我把它設為讀取SQLite,正式環境讀取SQL Server],所以會
              2. {C:\Users\syscc\Documents\Visual Studio Code\Projects\MvcMovie\appsettings.json}
              3. "JobsContext": "Server=(localdb)\\mssqllocaldb;Database=JobsContext-0d04fe32-b4eb-47cb-a886-0161e3b643af;Trusted_Connection=True;MultipleActiveResultSets=true"

            解決辦法: 
              1. 新增SQLite用連接字串. @appsettings.json => 
                  "JobsContext-Dev": "Data Source=MvcJob.db"
              2. 測試環境讀取SQLite用連接字串字串即可. @Startup.cs => 
                  public void ConfigureServices(IServiceCollection services)
                  {
                      services.AddControllersWithViews();
                      services.AddDbContext<JobsContext>(options =>
                      {
                          var connectionString = Configuration.GetConnectionString("JobsContext");
                          if (Environment.IsDevelopment() || Environment.IsStaging())
                          {
                              Console.WriteLine(Environment.EnvironmentName);
                              Console.WriteLine("Now is IsDevelopment or IsStaging");
                              connectionString = Configuration.GetConnectionString("JobsContext-Dev"); //重點在這裡.
                              options.UseSqlite(connectionString);
                          }
                          else
                          {
                              Console.WriteLine("Not dev or staging env.");
                              options.UseSqlServer(connectionString);
                          }
                      });            
                  }

        > 相容性版本
            1. {SetCompatibilityVersion} 方法可讓應用程式加入或退出 ASP.NET Core MVC 2.1 或更新版本所引入的可能重大行為變更。

        > 其他資源

  {完成}-ASP.NET Core MVC with EF Core (加強資料庫工具應用.) => ProjectName: ILanUniversity (2021/07/13)
      https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/?view=aspnetcore-5.0

        1. Create web app
          ProjectName : ILanUniversity
          dotnet new mvc //指令: 新增MVC架構網站(MVC)
          dotnet dev-certs https --trust //指令: 信任測試環境簽章(https用)
          
          2021/07/09
          TODO: 如果要使用登入驗證功能，請參考下列使用說明。
          不然，加入SchoolContext後，在產生DB時會出錯。
          因為，登入驗證功能用的ApplicationContext，也會產生DB。
          https://docs.microsoft.com/zh-tw/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&tabs=visual-studio

        2021/07/09
          找到原因：要遷移(Migration)後，資料庫才會產生。 
          EF 支援下列模型開發方法：
          從現有的資料庫產生模型。
          將模型手動編寫成符合資料庫的程式碼。
          建立模型之後，請使用 EF 遷移 從模型建立資料庫。 當模型變更時，遷移可讓資料庫演進。

        2. Set up the site style (調整網站風格, 修改名稱, 新增選單...)
          * 調整首頁 Views > Home > Index.cshtml
          * 調整共用版面 Views > Shared > _Layout.cshtml

        3. 安裝ORM套件(EntityFrameworkCore) #!-- 安裝工具或套件時, 千萬要注意是否跟 .NET SDK 版本 相容--#
            dotnet tool install --global dotnet-ef  //抓最新版安裝
            dotnet tool install --global dotnet-ef --version 6.0.10  //指定安裝6.0.10版
            dotnet add package Microsoft.EntityFrameworkCore.Design //專案引用套件
            dotnet add package Microsoft.EntityFrameworkCore.SQLite
            dotnet add package Microsoft.EntityFrameworkCore.SqlServer
            dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
            
            // 自動產生程式碼範本用
            dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
            
            // 協助偵測及診斷EF Core Migration(移轉)的問題
            dotnet add package Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore
        
        4. 新增 Data Model
          * Three Table(Course, Enrollment, Student), 新增3個Entity
            > 1名 Student, 可選多堂課(Enrollment)
            > 1堂 Course, 可被多名學生選取(Enrollment)
          * 若使用 ICollection<T>建立關聯, EFCore 預設會新增 HashSet<T>
          
          * Models.Student.cs
            
            using System;
            using System.Collection.Generic;
            namespace ILanUniversity.Models
            {
              public class Student
              {
                // EFCore會視為PK, 使用自動遞增
                public int ID {get;set;}
                public string LastName {get;set;}
                public string FirstName {get;set;}
                // 範例怪怪的, 選課時間放在學生實體內??
                public DateTime EnrollmentDate {get;set;}

                // Navigation Properties(關聯實體)
                public ICollection<Enrollment> Enrollments {get;set;}
              }
            }

          * Models.Enrollment.cs

            using System;
            namespace ILanUniversity.Models
            {
              public enum Grade
              {
                A, B, C, D, F
              }

              public class Enrollment
              {
                // EFCore會視為PK, 使用自動遞增
                public int EnrollmentID {get;set;}
                public int CourseID {get;set;}
                public int StudentID {get;set;}
                public Grade? Grade {get;set;}

                // Navigation Properties(關聯實體)
                public Course Course {get;set;}
                public Student Student {get;set;}

              }
            }
          * Models.Course.cs

            using System;
            using System.Collections.Generic;
            using System.ComponentModel.DataAnnotations.Schema;
            namespace ILanUniversity.Models
            {
              public class Course
              {
                // 指定使用 CourseID 為PK, 而非使用 EFCore 自動產生的
                // 不會套用自動遞增設定.
                [DatabaseGenerated(DatabaseGeneratedOption.None)]
                public int CourseID {get;set;}
                public string Title {get;set;}
                public int Credits {get;set;}

                // Navigation Properties
                public ICollection<Enrollment> Enrollments {get;set;}
              }
            }

        5. 新增 Database Context
          * DbContext 是 EFCore內最主要的類別, 決定使用哪些 Data Model.
          * 須繼承自 Microsoft.EntityFrameworkCore.DbContext 類別.
          * 1個 entity DbSet 會對應 1個 Table
          * 1個 entity 會對應 1筆 Row
          * EFCore新增DB時, 預設以 {DbSet名稱} 作為 {資料表名稱}
                          , 亦可使用 {程式員指定名稱} 詳下例:

          * Data.SchoolContext.cs

            using ILanUniversity.Models;
            using Microsoft.EntityFrameworkCore;
            namespace ILanUniversity.Data
            {
              public class SchoolContext: DbContext
              {
                // : base(options), 這一段不要漏掉了.
                public SchoolContext(DbContextOptions<SchoolContext> options): base(options)
                {
                }

                public DbSet<Student> Students {get;set;}
                public DbSet<Course> Courses {get;set;}
                public DbSet<Enrollment> Enrollments {get;set;}

                // 不用DbSet名稱作為TableName(預設), 例: Table Students, Courses 有些程式員無法接受.
                // 改以指定名稱新增
                protected override void OnModelCreating(ModelBuilder modelBuilder)
                {
                  modelBuilder.Entity<Student>().ToTable("Student");
                  modelBuilder.Entity<Course>().ToTable("Course");
                  modelBuilder.Entity<Enrollment>().ToTable("Enrollment");
                }
              }
            }

        6. 註冊Database服務
          * .NET Core 使用 DI(依賴性注入), 所以 EFCore Database Context 也要註冊後才能使用.
          * 去哪註冊服務?
            > Startup.cs -> ConfigureServices 方法

          * 範例: Startup.cs

            using ILanUniversity.Data; //放DbContext的地方
            using Microsoft.EntityFrameworkCore; //連接資料庫用套件

            namespace ILanUniversity
            {
              public class Startup
              {
                ...
                public void ConfigureServices(IServiceCollection services)
                {
                  if (env.IsDevelopment())
                  {
                    // 連接SQLite
                    services.AddDbContext<SchoolContext>(options => 
                    options.UseSqlite(Configuration.GetConnectionString("DefaultConnection")));
                  }
                  else
                  {
                    // 連接SQL Server
                  services.AddDbContext<SchoolContext>(options => 
                    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
                  }            
                }

                // 新增資料庫例外篩選器(Add the database exception filter)
                services.AddDatabaseDeveloperPageExceptionFilter();

                services.AddControllersWithViews();
              }
            }

        7. 新增資料庫例外篩選器(Add the database exception filter)
          * 在開發環境下, 可提供有用的錯誤資訊.
          * 同樣在 > Startup.cs -> ConfigureServices 方法內註冊
          * 範例: 詳上列程式碼

        8. (正式環境) 新增初始移轉 + 匯出SQL Scripts
          dotnet ef migrations add InitialCreate //新增初始移轉 by DbContext
          dotnet ef migrations script //匯出SQL Scripts by Latest Migration
          dotnet ef migrations script --output SqlScripts\InitialCreate.sql //匯出至指定資料夾

          !! 注意 !! SQL Scripts匯出後, 要改寫才能用在SQL Server
            1. 資料表存在否, 語法改寫
                IF OBJECT_ID('__EFMigrationsHistory', 'U') IS NOT NULL
                DROP TABLE __EFMigrationsHistory
                GO
            2. 自動遞增欄位, 語法改寫為 IDENTITY(1,1), 不能用 AUTOINCREMENT
            3. 拿掉所有的 "", 除了新增值或異動值外
                (X)CREATE INDEX "IX_Enrollment_StudentID" ON "Enrollment" ("StudentID");
                (O)CREATE INDEX IX_Enrollment_StudentID ON Enrollment (StudentID);

                (O)INSERT INTO __EFMigrationsHistory (MigrationId, ProductVersion)
                VALUES ('20210713014457_InitialCreate', '5.0.7');
            
          dotnet ef database update //產生資料庫(測試環境用)

        8. (測試環境)資料庫初始化 + 測試資料 (Initialize DB with test data)
          * 撰寫新增初始化資料類別
          * Data.DbInitializer.cs

            using ILanUniversity.Models;
            using System;
            using System.Linq;

            namespace ILanUniversity.Data
            {
              public static class DbInitializer
              {
                public static void Initialize(SchoolContext context)
                {
                  // 每次都會刪除資料庫再重新建立, 僅適用於<測試階段>
                  // MVC範例放在塞資料的類別內有點怪
                  // RazorPages範例則是放在 Program.cs 內, 當作一個服務來用, 不要時, 直接在那裡MARK最快.
                  context.Database.EnsureCreated();

                  // Look for any students.
                  if (context.Students.Any())
                  {
                    return; // DB has been seeded.
                  }

                  var students = new Student[]
                  {
                  new Student{FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")},
                  new Student{FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")},
                  new Student{FirstMidName="Arturo",LastName="Anand",EnrollmentDate=DateTime.Parse("2003-09-01")},
                  new Student{FirstMidName="Gytis",LastName="Barzdukas",EnrollmentDate=DateTime.Parse("2002-09-01")},
                  new Student{FirstMidName="Yan",LastName="Li",EnrollmentDate=DateTime.Parse("2002-09-01")},
                  new Student{FirstMidName="Peggy",LastName="Justice",EnrollmentDate=DateTime.Parse("2001-09-01")},
                  new Student{FirstMidName="Laura",LastName="Norman",EnrollmentDate=DateTime.Parse("2003-09-01")},
                  new Student{FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")}
                  };
                  foreach (Student s in students)
                  {
                      context.Students.Add(s);
                  }
                  context.SaveChanges();

                  var courses = new Course[]
                  {
                  new Course{CourseID=1050,Title="Chemistry",Credits=3},
                  new Course{CourseID=4022,Title="Microeconomics",Credits=3},
                  new Course{CourseID=4041,Title="Macroeconomics",Credits=3},
                  new Course{CourseID=1045,Title="Calculus",Credits=4},
                  new Course{CourseID=3141,Title="Trigonometry",Credits=4},
                  new Course{CourseID=2021,Title="Composition",Credits=3},
                  new Course{CourseID=2042,Title="Literature",Credits=4}
                  };
                  foreach (Course c in courses)
                  {
                      context.Courses.Add(c);
                  }
                  context.SaveChanges();

                  var enrollments = new Enrollment[]
                  {
                  new Enrollment{StudentID=1,CourseID=1050,Grade=Grade.A},
                  new Enrollment{StudentID=1,CourseID=4022,Grade=Grade.C},
                  new Enrollment{StudentID=1,CourseID=4041,Grade=Grade.B},
                  new Enrollment{StudentID=2,CourseID=1045,Grade=Grade.B},
                  new Enrollment{StudentID=2,CourseID=3141,Grade=Grade.F},
                  new Enrollment{StudentID=2,CourseID=2021,Grade=Grade.F},
                  new Enrollment{StudentID=3,CourseID=1050},
                  new Enrollment{StudentID=4,CourseID=1050},
                  new Enrollment{StudentID=4,CourseID=4022,Grade=Grade.F},
                  new Enrollment{StudentID=5,CourseID=4041,Grade=Grade.C},
                  new Enrollment{StudentID=6,CourseID=1045},
                  new Enrollment{StudentID=7,CourseID=3141,Grade=Grade.A},
                  };
                  foreach (Enrollment e in enrollments)
                  {
                      context.Enrollments.Add(e);
                  }
                  context.SaveChanges();

                }
              }
            }

          * 程式啟動前, {新增初始資料}
          * 更新 Program.cs

            using ILanUniversity.Data;
            using Microsoft.Extensions.DependencyInjection;
            ...

            namespace ILanUniversity
            {
              public class Program
              {
                public static void Main(string[] args)
                {
                  var host = CreateHostBuilder(args).Build();
                  CreateDbIfNotExists(host);
                  host.Run();
                }

                private static void CreateDbIfNotExists(IHost host)
                {
                  using (var scope = host.Services.CreateScope())
                  {
                    var services = scope.ServiceProvider;
                    try
                    {
                      // Get a database context instance from the dependency injection container.
                      var context = services.GetRequiredService<SchoolContext>();
                      
                      // Call the DbInitializer.Initialize method.
                      DbInitializer.Initialize(context);
                    }
                    catch (Exception ex)
                    {
                      var logger = services.GetRequiredService<ILogger<Program>>();
                      logger.LogError(ex, "An error occured during creating the DB.");
                    }

                    // Dispose the context when the Initialize method completes
                  }
                }

                public static IHostBuilder CreateHostBuilder(string[] args) => ...
              }
            }

          * 上述方法, 可在APP首次執行時使用, 新增DB, 塞入Test Data.
          * 但是當{data model變更}時, 則須 (1)刪除DB (2)更新DataSeed函式 (3)新增DB (4)Insert into Test Data.

          !! 之後會說明當 {data model變更} 時, 毋須 {刪除DB & 新增DB} 的方法, 使用 {移轉Migrations from DbContext} !!

        9. {新增Model後}, 自動產生對應的Controller & View 
          * ORM套件要先裝, 不然程式碼生不出來.
          * Model已撰寫完成.
          * 利用 dotnet-aspnet-codegenerator 工具產生程式碼
          * 官方說明: https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator?view=aspnetcore-5.0
      
          * 先前範例
            dotnet-aspnet-codegenerator controller // 指定產生控制器
            -name JobsController             // 控制器名稱
            -m Jobs                          // 要使用的模型類別
            -dc JobsContext                  // DbContext要使用的類別 or 要產生的類別名稱
            --relativeFolderPath Controllers //指定相對輸出檔案夾路徑
            --useDefaultLayout               //針對檢視使用預設的配置
            --referenceScriptLibraries       //所產生檢視中的參考指令碼程式庫
        
          * 本專案指令(for Student, Course, Enrollment三個Model)
            dotnet-aspnet-codegenerator controller
            -name StudentsController
            -m Student
            -dc SchoolContext
            --relativeFolderPath Controllers
            --useDefaultLayout      
            --referenceScriptLibraries

            dotnet-aspnet-codegenerator controller -name CoursesController -m Course -dc SchoolContext --relativeFolderPath Controllers --useDefaultLayout --referenceScriptLibraries

            dotnet-aspnet-codegenerator controller -name EnrollmentsController -m Enrollment -dc SchoolContext --relativeFolderPath Controllers --useDefaultLayout --referenceScriptLibraries

        10. 檢視資料庫
          * 資料庫自動產生, 乃依據 Data.DbInitializer.cs
          * 因為使用了 context.Database.EnsureCreated(); // 每次都會刪除資料庫, 僅適用於<測試階段>
            如果Model屬性異動時, 例: Student須多記錄 Email
            > 類別Student 新增屬性Email
            > 刪除資料庫
            > 停止再啟動APP. 資料庫將重新產生
          
          !! 注意, 資料庫重新產生後, 檢視並不會同步更新, 因為工具不同(dotnet-aspnet-codegenerator). !!

        11. 慣例(Conventions)
          * DbContext 的 DbSet 名稱 = 資料表名稱; 
          * DbContext 的 Entity 未被 DbSet 參考時, Entity名稱 = Table Name
          * Entity Property名稱 = Column Name
          * Entity Property名稱 = ID or classnameID時, 將被視為PK
          * Model 內有 navigation property 將被視為FK, 
            FK命名規則1: <navigation property name><PK property name>, 
              例如: navigation property = Student, PK property = ID => FK Name = StudentID
            FK命名規則2: <primary key property name>, 
              例如: Enrollment entity的 PK = EnrollmentID
          
          !! 注意, 上述慣例可被推翻/覆寫, 例如: 指定資料表名稱, 指定PK或FK !!

        12. 非同步指令碼(aysnchronous code)
          * Asynchronous programming is the default mode for ASP.NET Core and EF Core.
          * 非同步指令碼 可解決因等待I/O完成, 造成執行緒無法充份利用的問題.
          * 非同步指令碼 有成本, 但對於效能改善有實質幫助.

          * 關鍵詞 async, Task<T>, await, ToListAsync 讓程式碼變得非同步.
            public async Task<IActionResult> Index()
            {
              return View(await _context.Students.ToListAsync());
            }
          
          * 實作原理
            The async keyword tells the compiler to generate callbacks for parts of the method body and to automatically create the Task<IActionResult> object that's returned.
            The return type Task<IActionResult> represents ongoing work with a result of type IActionResult.
            The await keyword causes the compiler to split the method into two parts. The first part ends with the operation that's started asynchronously. The second part is put into a callback method that's called when the operation completes.
            ToListAsync is the asynchronous version of the ToList extension method.

          !! 注意事項: 使用 非同步指令碼(aysnchronous code)時 !!
            # 只在{送至資料庫的查詢或指令}上執行非同步.
              正例(須非同步): ToListAsync(取列表), SingleOrDefaultAsync(取第1個值), SaveChangesAsync(儲存)
              反例(不要使用非同步): 單純篩選IQueryable, 例: var students = context.Students.Where(s => s.LastName == "David");

            # EF Context 非執行緒安全, 不要試著平行執行多個作業.
              使用任何 async EFCore 方法, 都要加上 await 關鍵字.

              public async Task<IActionResult> Index()
              {
                // 記得加上 await, 在使用async EFCore 方法時 (ToListAsync())
                return View(await _context.Students.ToListAsync());
              }

            # 確定所有 library package 也使用 async

        13. Limit entities fetched(效能考量)
          * 通常會利用分頁或限制回傳筆數上限, 不會開放隨意筆數回傳.
          * 存取大張資料表時, 可回傳HTTP 200(成功)作為回應, 儘管資料庫存取時出現例外.
          * MaxModelBindingCollectionSize 預設值 = 1024筆, 下列程式碼將值重設為 100
          * Startup.cs
            using Microsoft.AspNetCore.Mvc; //這個要加, For MvcOptions
            public void ConfigureServices(IServiceCollection services)
            {
              var myMaxModelBindingCollectionSize = Convert.ToInt32(
                Configuration["MyMaxModelBindingCollectionSize"] ?? "100");
              services.Configure<MvcOptions>(options => 
                options.MaxModelBindingCollectionSize = myMaxModelBindingCollectionSize);        
              ...
            }
          
          * Configuration["MyMaxModelBindingCollectionSize"]的值去哪抓?
            設定位置: appsetting.{Environment}.json
              {
                "ConnectionStrings": {
                  "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=MyDB-2;Trusted_Connection=True;MultipleActiveResultSets=true"
                },
                "MyMaxModelBindingCollectionSize":"50",
                "AllowedHosts": "*"
              }

        14. SQL Logging of EntityFrameworkCore
          * Logging設定通常由 appsetting.{Environment}.json 檔案提供.
          * 如果要記錄 SQL 指令, 請在檔案內 appsettings.json or appsetting.Development.json
            加入以下設定 "Microsoft.EntityFrameworkCore.Database.Command": "Information"
          * appsetting.Development.json 設定範例
            { 
              "Logging": {
                "LogLevel": {
                  "Default": "Information",
                  "Microsoft": "Warning",
                  "Microsoft.Hosting.Lifetime": "Information",
                  // 增加下1行, SQL Command 會顯示在 Terminal內.
                  "Microsoft.EntityFrameworkCore.Database.Command": "Information"
                }
              },
              "AllowedHosts": "*"
            }      

  {完成}-Entity Framework Core or dotnet-ef (資料庫工具) => ProjectName: EFGetStarted (2021/07/12)
    https://docs.microsoft.com/en-us/ef/core/get-started/overview/first-app?tabs=netcore-cli

        {基本觀念}
          新增專案
            dotnet new console -o <ProjectName>
          
          安裝套件至專案中(存取Sqlite)
            dotnet add package Microsoft.EntityFrameworkCore.Sqlite

          新增模型(Model)
            1. 主類別 : DbContext; 繼承至 DbContext
            2. 資料實體類別, 描述實體屬性及與其他實體間的關係; 例: Student, Course

          新增資料庫(利用migrations移轉來新增DB)
            dotnet tool install --global dotnet-ef //安裝共用工具(dotnet-ef)
            dotnet add package Microsoft.EntityFrameworkCore.Design //安裝套件至專案中(自動產生移轉程式碼用)
            dotnet ef migrations add InitialCreate //產生初始移轉
            dotnet ef database update //依據最近1次移轉, 產生資料庫DB

          利用【主類別 : DbContext】作資料庫異動(CRUD)
            using (var db = new BloggingContext())
            {
              //Create
              db.Add(new Blog{...});
              db.SaveChanges();

              //Read(讀取1筆)
              var blog = db.Blogs.Order.OrderBy(b=>b.BlogId).First();

              //Update
              blog.Url = "https://www.ilan.gov.tw";
              blog.Posts.Add(new Post{ Title="測試", Content="一篇測試文章" }); //新增實體相關子實體項目
              db.SaveChanges(); //儲存變更

              //Delete
              db.Remove(blog); //刪除取出來的Blog實體
              db.SaveChanges(); //儲存變更
            }

        {資料實體屬性細節設定} https://docs.microsoft.com/en-us/ef/core/modeling/
          * 實體屬性無設定時, 會依慣例.
          * 兩種方式可設定實體屬性, 適用優先性(左至右, 由高至低) Fluent API > data annotation(資料註釋) > Conventions(慣例)

            > Fluent API
              * 在你繼承產生的DB主類別中, OnModelCreating 方法內設定
                protected override void OnModelCreating(ModelBuilder modelBuilder)
                {
                  modelBuilder.Entity<Blog>()
                    .Property(b=>b.Url)
                    .IsRequired();

                  modelBuilder.Entity<Blog>()
                    .Property(b=> b.Comments)
                    .HasMaxLength(500);

                  modelBuilder.Entity<Blog>()
                    .Property(b => b.Title)
                    .IsRequired()
                    .HasMaxLength(160);
                }
              
              * 若你想簡化 OnModelCreating 方法的程式碼長度, 可利用 Grouping configuration, 將設定獨立為類別檔再引用.
                https://docs.microsoft.com/en-us/ef/core/modeling/#grouping-configuration

            > data annotation(資料註釋)
              * 在資料實體上, 加上註釋
                using System.ComponentModel.DataAnnotations;
                public class Blog
                {
                  public int BlogId{get;set;}

                  [Required] //加上註釋, 必填欄位
                  public string Url{get;set;}

                  [Required]
                  [MaxLength(500) , MinLength(5)] //多條件限制
                  public string Comments {get;set;}

                  [Required]
                  [StringLength(160)]
                  public string Title {get;set;}
                }

        {利用Migrations移轉, 更新Table Schema, 在資料實體改變後}
          * 初版實體
            public class Blog
            {
              public int Id {get;set;}
              public string name {get;set;}
            }

          * 安裝共用工具(dotnet-ef)
            dotnet tool install --global dotnet-ef //安裝共用工具(dotnet-ef)

          * 產生初版移轉(預設放在Migrations資料夾內)
            dotnet ef migrations add InitialCreate

          * (測試環境) 產生資料庫及綱要
            dotnet ef database update //套用最新版migrations, 產生資料庫及綱要
            dotnet ef database update {migrations name} //套用指定migrations, 產生資料庫及綱要.

            !!注意 (SQlite不支援)!! 
              1. dotnet ef database update 指令, 不完整, 異動DB上可能出現錯誤
              2. dotnet ef migrations add xxx, OK, 產生移轉沒問題
              
              //亦可用於回溯於之前移轉版本, 有產生資料遺失的風險.

            註: (正式環境) 通常不會使用上述指令直接異動DB，而是【產生SQL Scripts】比較保險
            dotnet ef migrations script                  //採用最新版migrations, 產生SQL Scripts
            dotnet ef migrations script {指定migrations} //From 指定migrations to 最新版migrations, 產生SQL Scripts
            dotnet ef migrations script {From} {To}      //From migrations To migrations, 產生SQL Scripts
          
            註: (正式環境) 產生已套用移轉的【Idempotent SQL scripts】, 常用於確認【套用至DB的最新版移轉】？
            dotnet ef migrations script --idempotent

          * 改版實體
            public class Blog
            {
              public int Id {get;set;}
              public string name {get;set;}
              public DateTime CreatedTimestamp (get;set;) //新增欄位
            }

          * 產生改版移轉
            dotnet ef migrations add AddBlogCreatedTimestamp
          * 改版資料庫及綱要
            dotnet ef database update

          !! 注意: 排除在移轉範圍內 !!
            > 常發生在【主類別: DbContext】 引用 另一個DbContext資料時
            > 請套用下列指令碼, 將 另一個DbContext資料 排除在移轉範圍外

              protected override void OnModelCreating(ModelBuilder modelBuilder)
              {
                modelBuilder.Entity<IdentityUser>()
                  .ToTable("AspNetUsers",t => t.ExcludeFromMigrations());
              }

  