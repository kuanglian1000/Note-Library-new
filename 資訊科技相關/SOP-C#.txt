/* C# 7.0 後出現的新東西 */
  {default} <= 給型別的Null 常值或可能的 Null 值

  {default!} <= 注意後面多一個驚嘆號 '!', 一元運算的後置!功能(null-forgiving), 表示這個運算式不是NULL.
    string str = default!; // default!, 表示這個運算式不是NULL.

  0. 一元運算的後置!功能(null-forgiving), 表示這個運算式不是NULL. 
  例: string? Title = ""; Title變數是 nullable. 
      如果使用 Title 時, 明確加上 Title! 表示跟編譯器說, 這時候它不是NULL
      https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-forgiving

/*新的運算子*/
  '=>' 運算子
    Lambda 運算式 (=>) 運算子定義 Lambda 運算式
    https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/lambda-operator
    
    public bool HasPreviousPage => PageIndex > 1; //是否有前頁(member => expression;運算式主體定義)
  
  .ForEach 運算子 //2023-05-26 新發現
    forEach() 方法會將陣列內的每個元素，皆傳入並執行給定的函式一次。

    departments 是陣列
    departments.ForEach(d => d.InstructorID = null); //C#

    此用法在JS也有{Array.prototype.forEach()}
    const array1 = ['a', 'b', 'c'];
    array1.forEach(element => console.log(element));
    // Expected output: "a"
    // Expected output: "b"
    // Expected output: "c"


  {?.} 運算子 //2023-05-24 新發現
    語法: nullableVariable ?. expression
    說明: 評估 nullableVariable 這個ARRAY 是否為NULL
          > 若為TRUE(NULL), 就回傳NULL
          > 若為FALSE(NOT NULL), 往下評估expression值
    
    範例1: int? c = NullableArrayValue?.Length;
          上述寫法等同於
          {
            if (NullableArrayValue is null)
              c = null;
            else
              c = NullableArrayValue.Length;
          }
    範例2: instructorToUpdate.OfficeAssignment?.Location
          上述寫法等同於
            if (instructorToUpdate.OfficeAssignment == null)
              return null;
            else 
              return instructorToUpdate.OfficeAssignment.Location; //往下評估expression值

  {?:} 運算子
    語法: Type variable = condition ? expression-true : expression-false;
    說明: 評估 condition 結果
          > 若為TRUE, 給 expression-true 結果
          > 若為FALSE, 給 expression-false 結果
    範例: int temp = 30;
          string strFeeling = (temp > 25) ? "Hot" : "Cool";

  {??} 運算子
    1.判斷 ?? 左側運算元是否為null, 若是NULL則給定右側值
    
    用法1:
      int? a = null;
      int b = a ?? -1; //a 是 null的話, 就給 -1
      Console.WriteLine(b);  // output: -1
    
    用法2:
      if (variable is null)
      {
          variable = expression;
      }
      可以改寫為 variable ??= expression; //variable是null的話, 就指定為 expression


/*== 將 ASP.NET Identity 新增至空的或現有的 Web Form 專案(先利用EF把儲存Token的DB生出來, 使用 Identity & OAUth套件) ==*/
https://learn.microsoft.com/zh-tw/aspnet/identity/overview/getting-started/adding-aspnet-identity-to-an-empty-or-existing-web-forms-project?source=recommendations
  專案位置: C:\Projects\Projects_ASP.NET\WebFormsIdentity

  (VIP): 若為 Visual Studio 2015 或更高版本，請在"連接字串"中將 取代 (localdb)\v11.0 改為 (localdb)\MSSQLLocalDB
  (VIP): identity DefaultConnection 的位置 => 會放在專案的 App_Data 資料夾內
  (VIP): 範例程式碼是舊版(authenticationManager.SignOut();) / 新版(authenticationManager.Authentication.SignOut();)

  關於<權限管理>的必裝套件: (for web form, mvc , web api.)
  Microsoft.AspNet.Identity.EntityFramework <= 身分識別套件
  Microsoft.AspNet.Identity.Owin <= 驗證用套件. 包含一組 OWIN 擴充類別，可管理和設定 ASP.NET Identity Core 套件所取用的 OWIN 驗證中介軟體.
  Microsoft.Owin.Host.SystemWeb <= 包含 OWIN 伺服器. 可讓以 OWIN 為基礎的應用程式使用 ASP.NET 要求管線在 IIS 上執行。 如需詳細資訊，請參閱 IIS 整合管線中的 OWIN 中介軟體.

/*== ASP.NET Web API中的安全性、驗證和授權(OAuth2, JWT, 外部驗證) 專案實作(儲存Token的DB生出來後, 再套用至Web API. 因為這裡DB生不出來, 嘻~~)==*/
https://learn.microsoft.com/zh-tw/aspnet/web-api/overview/security/
  專案位置: C:\Projects\Projects_ASP.NET\WebAPI_Identity
  
  (VIP): 若為 Visual Studio 2015 或更高版本，
    請在"連接字串"中將 取代 (localdb)\v11.0 改為 (localdb)\MSSQLLocalDB

  自行實作(難度太高): https://github.com/VeronicaWasson/LocalAccountsApp

/*== C# 撰寫良好程式碼的50個具體作法 ==*/
  
  <CH01- C#語言慣用語法>

    Method 01- 偏好隱含型別的區域變數 var  2022/03/04
      var myCompany = "sheico";

      原因在於:
      1. C#加入隱含型別的區域變數以支援不具名型別.
      2. 查詢結果是 IQueryabl<T>, 而非 IEnumerable<T>.
      3. 讓開發人員更注意(語意意涵)而非變數型別特性.

      過度使用var的缺點: 
      1. 降低程式可讀性
      2. 可能引發微妙的型別轉換BUG

      範例1:
        var foo = new MyType(); //容易, 應該是 MyType. 
        var thing = AccountFactory.CreateSavingAccount(); //容易, 應該是 Account type.
        var result = someObject.DoSomeWork(anotherParameter); //壞範例, 極端錯誤範例, 程式庫名稱要能表示能回傳型別.

      範例2:
        //效能較差範例, 自行宣告型別
        public IEnumerable<string> FindCustomerStartWith1(string start)
        {
          IEnumerable<string> q = 
            from c in db.Customers
            select c.ContactName; //問題1, 資料庫查詢回傳的是 IQueryable<string>, 開發者卻宣告為 IEnumerable<string>

          var q2 = q.Where(s => s.StartWith(start)); //問題2, 呼叫 Enumerable.Where 的效能比 Queryable.Where 差
          return q2;
        }

        //效能較佳範例, 隱含型別宣告
        public IEnumerable<string> FindCustomerStartWith2(string start)
        {
          var q = 
            from c in db.Customers
            select c.CustomerID; //q 被宣告為 IQueryable<string>
          
          var q2 = q.Where( s => s.StartWith(start))
          return q2;
        }

      結論:
        0. "初始化表示式" 能看出清楚顯示開發者語意時, 請使用 var 宣告區域變數.
        1. 除非開發者(包括你) "必須看到型別宣告才能理解程式", 否則使用 var 宣告區域變數.
        2. 建議 明確宣告 所有數值型別(int, float, double ..), 不要用 var.
        3. 使用"隱含型別的區域變數", 由編譯器幫你決定變數型別, 通常比較好.
        
    Method 02- 偏好執行期間常數 readonly, 而非編譯期間常數 const 2022/03/09
      1. 編譯期間常數 const 留給效能關鍵 & 常數值絕不改變時使用. (例: 控制版本號的參考類別常數, 版號)
      2. 編譯期間常數 const 效能稍快, 但彈性較差.
        
        public const int ThisYear = 2022; //編譯期間常數
        public static readonly int LastYear = 2021; //執行期間常數

      3. 編譯期間常數 const 可在方法中宣告, 但 執行期間常數 readonly 無法在方法中宣告.
        這個IDE可以協助識別, 出現紅色底線不讓你寫.
      
      4. 編譯期間常數 const & 執行期間常數 readonly 行為差異在於 <如何存取>
        a. 編譯期間常數 
          => if (myDateTime.Year == ThisYear) //程式寫法.
          => if (myDateTime.Year == 2022) //編譯後會(用常數的值取代).
        b. 執行期間常數 
          => if (myDateTime.Year == LastYear) //程式寫法.
          => if (myDateTime.Year == LastYear) //編譯後會(參考 LastYear 參數), 而非其值.

      5. 編譯期間常數 const & 執行期間常數 readonly 的<型別限制>
        a. 編譯期間常數 => 整數型別int, 浮點數型別float|double|decimal, 列舉enum, 字串string, null值 <= 這些都是初始化程式中必須指派有意義的常數值型別
        b. 執行期間常數 => 其他任何型別, 但必須在建構元進行初始化, 或使用初始化程序.

          => private const DateTime inStockDate = new DateTime(2022, 3, 9, 0, 0, 0); //宣告為 編譯期間常數 const , ERROR-無法編譯
          => private readonly DateTime inStockDate = new DateTime(2022, 3, 9, 0, 0, 0); //宣告為 執行期間常數 readonly , OK-可編譯
          
      6. 編譯期間常數 const & 執行期間常數 readonly 的<最大差異>
        a. Case1: 使用 (執行期間常數 readonly), 可以只建置 (類別檔專案) & Move 最新版DLL into (執行程式專案) , 即可變更 (執行程式專案) 行為, 而不用重新建置 (執行程式專案).
            但使用 (編譯期間常數 const) 就無法達到這種效果, 因為它無法在執行期間抓取執行階段最新值, 只能用上次編譯進去的常數 <= VIP =>

          (執行程式專案)
          using DemoCommonClass;
          namespace DemoConstOrReadonly
          {
              class Program
              {
                  static void Main(string[] args)
                  {
                      for (int i = UsefulValues.StartValue; i < UsefulValues.EndValue; i++) //使用類別檔的 "執行期間常數 readonly"
                      {
                          Console.WriteLine(String.Format("Current Value: {0}", i));
                      }
                      Console.ReadLine();
                  }
              }
          }

          (類別檔專案)
          using System;
          namespace DemoCommonClass
          {
              public class UsefulValues
              {
                  public static readonly int StartValue = 600; //執行期間常數 readonly
                  public static readonly int EndValue = 630;
              }
          }
 
        b. Case2: 使用 (編譯期間常數 const), 可用來 <識別/追蹤規則改版日>, 確保 (執行程式專案) 行為執行時回報<規則/演算法最後更新時間>. 
          => 只建置 (類別檔專案) & Move 最新版DLL into (執行程式專案) , 並無法變更 (執行程式專案) 行為.
          => 必須 [1]先建置 (類別檔專案), [2]再建置 (執行程式專案), 才能變更 (執行程式專案) 行為.

          //(類別檔專案)
          using System;
          namespace DemoCommonClass
          {
              public class UsefulValues
              {
                  public static readonly int StartValue = 600;
                  public static readonly int EndValue = 630;

                  public const string RevisionString = "版本異動日期 : 2022/03/09";
                  public const string RevisionMessage = "版本異動訊息 : 新增版本資訊, " + "增加計算規則";
              }
          }

          //(執行程式專案)
          using System;
          using DemoCommonClass;

          namespace DemoConstOrReadonly
          {
              class Program
              {
                  static void Main(string[] args)
                  {
                      for (int i = UsefulValues.StartValue; i < UsefulValues.EndValue; i++)
                      {
                          Console.WriteLine(String.Format("Current Value: {0}", i));
                      }

                      Console.WriteLine(UsefulValues.RevisionString);
                      Console.WriteLine(UsefulValues.RevisionMessage);
                      Console.ReadLine();
                  }
              }
          }

      7. 編譯期間常數 const & 執行期間常數 readonly 使用上的<結論>
        a. 必須在編譯期間確定的值須使用 const : 屬性參數, switch case tag & enum定義, 以及少數不會被版本間變化的值.
        b. 其餘狀況傾向使用 readonly 常數提昇彈性.
        c. 如要比較之間的效能差異, 可試試 BenchmarkDotNet, https://github.com/PerfDotNet/BenchmarkDotNet 工具.

    Method 03- 偏好 is 或 as 運算子而非型別轉換 (MyType t = (MyType)st) 2022/03/10
      1. 接到 object 參數時, 可能須轉換為物件或其他型別.
      
      2. 轉換時, 有 3 種選擇
        a. 使用 as 運算子 <= 建議作法
        b. 強制編譯器依程式員指定型別轉換
        c. 使用 (is 運算子)測試轉換, 再用 (as 運算子) or (型別轉換) <= 建議作法
      
      3. (as 運算子) & (is 運算子) 不執行實際轉換, 它們只在執行期間型別符合目標型別時進行. 而且很少建構新物件(as 只會轉換 boxed值型別至unboxed可為null時, 建構新物件)
      3.1. 使用 as 只須檢查 null
      3.2. 使用 型別轉換 須檢查 null & 捕捉例外
        //程式範例
          
          //Version1: 使用 as 運算子 <= 建議作法 =>
            object o = Factory.GetObject();
            MyType t = o as MyType;

            if(t != null)
            {
              // t is MyType, do something.
            }
            else
            {
              // return failed Message(回報失敗訊息)
            }

          //Version2: 依程式員指定型別轉換
            object o = Factory.GetObject();
            try
            {
              MyType t;
              t = (MyType)o;
              // t is MyType, do something.
            }
            catch(InvalidCastException)
            {
              // return failed Message(回報失敗訊息)
            }
      
      4. <VIP> 記憶點1: 使用者定義的轉換運算子 (MyType) 只能針對物件編譯期間型別作轉換, 而不是執行期間型別.
      4. <VIP> 記憶點2: 與是否存在 某個Object 與 MyType 型別間的執行期間轉換無關.
        
        //程式範例: 寫成轉換函式會比較好一些, 而不要在寫在邏輯判斷內. 詳見 "Version2: 依程式員指定型別轉換"

          object o = Factory.GetObject();
          DoStuffWithObject(o);
          private static void DoStuffWithObject(object o)
          {
            try
            {
              MyType t;
              t = (MyType)o; // 失敗, o 不是 MyType

              // 成功, 

            }
            catch (InvalidCastException)
            {
              // 回報轉換失敗
            }
          }

      5. 何時不該使用 as 運算子

        //程式範例: 無法編譯
          object o = Factory.GetValue();
          int i = o as int; //無法編譯, 因為 int 是值型別 & 不能為null. 如果 o 不是整數, 該存什麼到 i 變數呢?

      //程式範例: 可以編譯, 此技巧用於 "as 運算子" 左邊的運算元是值型別 or 任何可能為null型別時使用.
        obejct o = Factory.GetValue();
        var i = o as int?; 
        if (i != null)
          Console.WriteLine(i.Value);

      6. foreach loop 若使用非泛型IEnumerable序列, 它也需要作轉型, 轉型失敗會丟例外 (VIP: 應儘可能用 型別安全的泛型 ICollection<string>)
        //程式範例
          public void UseCollection(IEnumerable collection)
          {
            foreach(MyType t in collection)
              t.DoStuff();
          }

        //程式範例-上述程式轉換後的版本
          public void UseCollection(IEnumerable collection)
          {
            IEnumerator it = collection.GetEnumerator();
            while(it.MoveNext())
            {
              MyType t = (MyType)it.Current; //這裡要作型別轉換以支援 "值型別" or "參考型別"
              t.DoStuff();
            }
          }

      7. 想知道物件確實型別, 而不是目前型別可否轉為目標型別(使用 as or is), 該如何處置?
        a. (is 運算子) 是使用多形規則: if fido is dog, dog 繼承自 Animal, then fido is Animal return true.
            註: ':' <= 是C#繼承的關鍵詞
        
        b. GetType() 方法能取得物件的 "執行期間型別". 它比 is or as 運算子更為嚴格.
        c. GetType() 回傳物件型別能與特定型別比較.

    Method 04- 以內插字串$""取代 string.Format() <= $"" C# 6.0 支援 => 
      
      Console.WriteLine

    Method 05- 對文化特定字串偏好 FormattableString

    Method 06- 避免字串型別API nameof() <= C# 6.0 支援

    Method 07- 以 delegate(委派) 表示 callback

    Method 08- 對事件叫用使用空條件運算子

    Method 09- 減少 boxing 與 unboxing 的轉換(值到參考 = boxing, 參考到值 = unboxing)

    Method 10- 只對基底類別更新使用 new 修飾詞

  <CH02- .NET資源管理>

  <CH03- 使用泛型>

  <CH04- 使用LINQ>

  <CH05- 例外的最佳作法 Exception>

/*== C# 學習歷程 ==*/

  <字串插補 $"{直接放入變數名稱即可}" , 類似之前 String.Format("{0}{1}{2}{3}...", xxx,xxx,xxx,xxx)>;
  資料來源: https://docs.microsoft.com/zh-tw/dotnet/csharp/tutorials/string-interpolation
  
    //基本用法
      var name = "<name>";
      Console.WriteLine($"Hello, {name}. It's a pleasure to meet you!");

    //包含不同的資料類型
      var item = (Name: "eggplant", Price: 1.99m, perPackage: 3);
      var date = DateTime.Now;
      Console.WriteLine($"On {date}, the price of {item.Name} was {item.Price} per {item.perPackage} items.");

    //控制插入運算式的格式, 讓輸出格式更為精確
      Console.WriteLine($"On {date:d}, the price of {item.Name} was {item.Price:C2} per {item.perPackage} items");

    //控制插入運算式的欄位寬度(數值即是寬度) & 對齊方式(正數靠左 / 負數靠右) & 格式化一起加上去(:d, :C..)
      var inventory = new Dictionary<string, int>()
      {
          ["hammer, ball pein"] = 18,
          ["hammer, cross pein"] = 5,
          ["screwdriver, Phillips #2"] = 14
      };

      Console.WriteLine($"Inventory on {DateTime.Now:d}");
      Console.WriteLine(" ");
      Console.WriteLine($"|{"Item",-25}|{"Quantity",10}|");
      foreach (var item in inventory)
        Console.WriteLine($"|{item.Key,-25}|{item.Value,10}|");

    //欄位寬度(數值即是寬度) & 對齊方式(正數靠左 / 負數靠右) & 格式化一起加上去(:d, :C..)
      Console.WriteLine($"[{DateTime.Now,-20:d}] Hour [{DateTime.Now,-10:HH}] [{1063.342,15:N2}] feet");
    
    //$"{interpolationExpression}" 大括弧可直接放入運算式
      double a = 3;
      double b = 4;
      Console.WriteLine($"Area of the right triangle with legs of {a} and {b} is {0.5 * a * b}");

      //>注意這裡<
      Console.WriteLine($"Length of the hypotenuse of the right triangle with legs of {a} and {b} is {CalculateHypotenuse(a, b)}");

      //我是函式
      double CalculateHypotenuse(double leg1, double leg2) => Math.Sqrt(leg1 * leg1 + leg2 * leg2);

    //$"{<interpolationExpression>:<formatString>}" 運算式可再加上<格式化>
      var date = new DateTime(1731, 11, 25);
      Console.WriteLine($"On {date:dddd, MMMM dd, yyyy} Leonhard Euler introduced the letter e to denote {Math.E:F5} in a letter to Christian Goldbach.");

      // Expected output:
      // On Sunday, November 25, 1731 Leonhard Euler introduced the letter e to denote 2.71828 in a letter to Christian Goldbach.

      // Expected output:
      // Area of the right triangle with legs of 3 and 4 is 6
      // Length of the hypotenuse of the right triangle with legs of 3 and 4 is 5

    //如何在插入字串中使用逸出序列(ex. \)

      var xs = new int[] { 1, 2, 7, 9 };
      var ys = new int[] { 7, 9, 12 };
      Console.WriteLine($"Find the intersection of the {{{string.Join(", ",xs)}}} and {{{string.Join(", ",ys)}}} sets.");

      var userName = "Jane";
      var stringWithEscapes = $"C:\\Users\\{userName}\\Documents";
      var verbatimInterpolated = $@"C:\Users\{userName}\Documents";
      Console.WriteLine(stringWithEscapes);
      Console.WriteLine(verbatimInterpolated);

      // Expected output:
      // Find the intersection of the {1, 2, 7, 9} and {7, 9, 12} sets.
      // C:\Users\Jane\Documents
      // C:\Users\Jane\Documents

    //如何在內插補點運算式中使用三元條件運算子 ?:
      var rand = new Random();
      for (int i = 0; i < 7; i++)
      {
          Console.WriteLine($"Coin flip: {(rand.NextDouble() < 0.5 ? "heads" : "tails")}");
      }

    //如何使用字串插補建立文化特性特有的結果字串(依國別區分的字串型態) <== 重點在 ToString(加入文化特性)
      var cultures = new System.Globalization.CultureInfo[]
      {
          System.Globalization.CultureInfo.GetCultureInfo("en-US"),
          System.Globalization.CultureInfo.GetCultureInfo("en-GB"),
          System.Globalization.CultureInfo.GetCultureInfo("nl-NL"),
          System.Globalization.CultureInfo.InvariantCulture
      };

      var date = DateTime.Now;
      var number = 31_415_926.536;
      FormattableString message = $"{date,20}{number,20:N3}";
      foreach (var culture in cultures)
      {
          var cultureSpecificMessage = message.ToString(culture);
          Console.WriteLine($"{culture.Name,-10}{cultureSpecificMessage}");
      }

      // Expected output is like:
      // en-US       5/17/18 3:44:55 PM      31,415,926.536
      // en-GB      17/05/2018 15:44:55      31,415,926.536
      // nl-NL        17-05-18 15:44:55      31.415.926,536
      //            05/17/2018 15:44:55      31,415,926.536

    //如何建立使用不因文化特性而異的結果字串(不受國別影響的)
      string messageInInvariantCulture = FormattableString.Invariant($"Date and time in invariant culture: {DateTime.Now}");
      Console.WriteLine(messageInInvariantCulture);

      // Expected output is like:
      // Date and time in invariant culture: 05/17/2018 15:46:24

  <& or && 的差異>
    1. (條件1) & (條件2), 兩個條件都會評估
    2. (條件1) && (條件2), 若 (條件1) 為 false, 則不評估(條件2)

  學習路徑 - 使用 C# 邁出您的第一步 (Take your first steps with C#) (OK)
    參考資料: https://docs.microsoft.com/en-us/learn/paths/csharp-first-steps/

    # 字串串連
      1. 字串串連可讓您將較小的常值與變數字串合併為單一字串。 (註: + )
      2. 若新增中繼變數並不會增加可讀性，避免建立中繼變數。 (註: string a = "a"; string b = "b"; string temp = a + b;)

    # 字串插補
      1. 字串插補透過減少某些情況中需要的字元數目，提供比字串串連更好的改良。 (註: $"{str1} {str2}";)
      2. 您可以透過合併每個項目的符號並使用該符號作為字串範本的前置字元，來合併字串插補與逐字常值。 
        @"...", 視為逐字常值. (註: 何謂逐字常值, 就是 \n 不視為換行, 而是字面上的 '\n')
        $"{var}", 可放入字串插補.
        $@"C:\Output\{projectName}\Data"; 
          (註: 此例為什麼要加上 @, 因為裡面有 3個 \ 跳脫字元後面找不到對應, 會出現錯誤)
          (註: 此例為什麼要加上 $, 因為裡面有 {字串插補})
          (註: How to Display Unicode on Console ? 
              加上這段碼 "Console.OutputEncoding = System.Text.Encoding.UTF8;" )
          (註: 逸出字元 = \跳脫字元 + 對應逸出字元, 例: \t = tab, \n = 換行, \\ = 加上1個\字元 )

    # 數值
      1. 您可對數字執行如加法的數學運算。
      2. 字串串連和加法都會使用加號 +。 這稱為「對運算子進行多載」，且編譯器會根據其正在運算的資料類型推斷出適當的使用方式。
      3. 在可以的情況下，C# 編譯器會在開發人員明顯基於顯示目的想要串連代表數字的字串時，將 int 隱含地轉換為 string。
      4. 使用括弧來定義運算順序，以明確地告知編譯器，我們想要在執行其他運算之前先執行特定運算。
        (!!: 您應該避免在單一程式碼中同時執行{數值計算}和{字串串連}。 此處的重點在於協助您了解如何從編譯器角度來檢視運算子與運算元。)

    # 數值運算
      1. int 無法存入小數點. ex. int i = 5 / 2 = 2 (OK)
      2. decimal 才能存入小數點. ex. decimal d  = 7 / 5.0m; (OK)
      3. 如何保留計算後的小數值? 
        (註: 商 (指派運算子的左側) 必須是 decimal 類型，且 被除數「或」除數也必須是 decimal 類型 (「或是」兩者皆為該類型)。)
        OK:
          decimal decimalQuotient = 7 / 5.0m;
          decimal decimalQuotient = 7.0m / 5.0m;
          decimal decimalQuotient = (decimal)7 / 5; (註: 對 int 轉型為 decimal)
        Error:
          int decimalQuotient = 7 / 5.0m; (註: 只留下整數, 因為int 無法存入小數點)
          int decimalQuotient = 7.0m / 5; (註: 只留下整數, 因為int 無法存入小數點)
          int decimalQuotient = 7.0m / 5.0m; (註: 只留下整數, 因為int 無法存入小數點)
          decimal decimalQuotient = 7 / 5; (註: 只留下整數, 因為 int / int 還是整數)
      4. % 可求出 (int) 除法的餘數 (註: 型態是 int )
      5. 運算順序(PEMDAS)
        * 括號 ()
        * 指數 System.Math.Pow(), 求指數函數
        * 乘 * & 除 /
        * 加 + & 減 -

      6. 小結  
        * 使用 +、-、* 與 / 等運算子來執行基本數學運算。

        * 將兩個 int 值相除將會導致系統截斷小數點之後的任何值。 
          !!注意: 若要保留小數點之後的值，您需要先將除數或被除數 (或兩者) 從 int 轉換為浮點數 (例如 decimal)，而且商也必須是相同的浮點類型，才能避免截斷。
        
        * 執行轉換作業來暫時將值視為不同的資料類型。(例: (decimal)7 | 7.0m)
        * 使用 % 運算子來擷取相除後的餘數。(例: 5 % 3 = 2)
        * 運算順序將會遵循 PEMDAS 縮寫的規則。

    # 遞增和遞減值
      1. 小結    
        * 使用 +=、-=、*=、++ 與 -- 之類的複合指派運算子來執行如遞增或遞減的數學運算，然後將結果指派到原始變數中。
        * 根據遞增和遞減運算子是位於運算元之前或之後，它們的執行方式將會有所不同。
          ++value , 加1後再取值
          value++ , 先取值再加1

    # 呼叫方法(接受參數, 使用.NET Class Library)
      1. .NET Class Library 簡介
        * 類別是方法的容器
        * 資料類型(data type)都是 .NET Class Library 的一部分
        * 什麼是命名空間(namespace)？
            (註: 可想像成家族名稱, 避免與其他同名同姓的方法發生衝突)
            (註: 命名空間可以協助確保不會有任何類別具有相同的「全名」)

      2. 小結    
        * .NET Class Library 能為我們提供豐富的功能，且我們僅需參考所需的類別和方法就能使用它們。
        * 連資料類型都是 .NET Class Library 的一部分。 C# 單純只是針對那些資料類型提供別名。
        * 「命名空間」能防止 .NET Class Library 中類別名稱間的命名衝突。

    # 呼叫 .NET Class Library 中不同類型的方法
      1. 具狀態與無狀態方法
        * 具狀態方法, 要宣告物件(又稱執行個體 instance)來儲存狀態.
        * 無狀態方法, 因不保留狀態, 所以直接使用即可. (註: 不用先宣告, 再使用.)
          又稱靜態方法(static method). 
          (例: Console.Write("123");)
          (例: PizzaService.GetAll(); 因為 PizzaService 宣告為無狀態類別, GetAll() 也是無狀態方法, 所以能直接使用.)
      
      2. 在呼叫某個類別的方法之前，要如何判斷是否需要先建立該類別的執行個體？
        * 查參考文件
        * 直接尋找範例
      
      3. 小結    
        * 若要呼叫 .NET Class Library 中類別的方法，您會使用 ClassName.MethodName() 格式，
          其中 . 符號是用來存取定義於類別上之方法的成員存取運算子，而 () 符號則是方法叫用運算子。

        * 呼叫無狀態方法時，您不需要先建立其類別的新執行個體。
        * 呼叫具狀態方法時，您需要建立類別的執行個體，並存取物件上的方法。
        * 使用 new 運算子來建立類別的新執行個體。
        * 類別的執行個體稱為「物件」。

    # 使用傳回值與輸入參數
      1. 傳回值(return)
        * void 無回傳
        * return DataType (OK)
        * return ClassObject (OK)
      
      2. 傳入參數(input parameter)
        * 輸入參數是使用{資料類型}來定義。 我們無法傳遞不同資料類型的值作為輸入參數，因為方法將無法運作.
        * {類型檢查} 是 C# 與 .NET 使用者用來確認資料類型，以防止終端使用者遇到例外狀況的其中一種方法。
        * {方法簽章} 是針對每個輸入參數與資料類型所定義的輸入參數。
      
      3. 多載方法(Overload)
        * 多載方法 是以多個{方法簽章}定義。

      4. 小結    
        * 方法可能不會接受任何參數，或是接受多個參數，這取決於它們的設計與實作方式。 在傳遞多個輸入參數時，請以 , 符號來分隔它們。
        * 方法可能會在完成其工作時傳回值，也可能不會傳回任何內容 (void)。
        * 多載方法支援數個方法實作，每個實作都會有唯一的方法簽章 (輸入參數的數目，以及每個輸入參數的資料類型)。
        * Intellisense 可以協助您更迅速地撰寫程式碼。 它能針對方法提供快速參考、其傳回值、其多載版本，以及其輸入參數的類型。
        * docs.microsoft.com 是您想要了解 .NET Class Library 中方法運作方式時的「信任來源」。

    # 條件判斷式(if)
      1. 小結  
        * 使用 if 陳述式來為程式碼邏輯設定分支。 
          如果 if 決策陳述式的布林運算式等於 True，則將執行其程式碼區塊中的程式碼。 
          否則，執行階段將略過此程式碼區塊，並繼續執行此程式碼區塊後面的下一行程式碼。
        * 布林運算式是任何會傳回布林值的運算式。
          布林運算子將比較其左邊和右邊的兩個值，以進行相等、比較等操作。
        * 程式碼區塊會以大括弧 { } 來定義。 它會收集應視為單一單位的程式碼。
        * 邏輯 AND 運算子 && 會彙總兩個運算式，
          如此一來，這兩個子運算式都必須為 True，整個運算式才為 True。
        * 邏輯 OR 運算子 || 會彙總兩個運算式，
          如此一來，若任一個子運算式為 True，則整個運算式即為 True。

    # 條件判斷式(else if & else)
      1. 小結    
        * if-else 可讓您測試條件，以在布林運算式為 True 時執行程式碼，並在布林運算式為 False 時執行不同的程式碼。
        * 您可以巢狀處理 if 陳述式來縮小可能的條件。 
          不過，您應該考慮改為使用 if-elseif-else 陳述式。
          使用 elseif 來建立多個獨佔條件。
        * else 是選擇性的，但一律需最後出現。

    # 使用 C# 中的陣列及 foreach 陳述式來儲存及逐一查看資料序列
      1. 陣列基本知識
      
      2. 什麼是陣列
        * 陣列是個別資料元素的序列，可透過單一變數名稱存取。 
        * 您會使用以零為基礎的數值索引來存取陣列中的每個元素。
      
      3. 宣告陣列
        * 陣列是特殊類型的變數，可保存相同資料類型的多個值
        
        * 宣告語法，必須同時指定資料類型和陣列大小。
            string[] aryString = new string[3];
            var aryString = new string[] {"a","b","c"};
        
        * 將值指派至陣列的元素, 
            索引值以 0 開始.
        
        * 將陣列初始化
            string[] aryString = {"a","b","c"};
        
        * 取得陣列的大小(使用 Length屬性 )
            aryString.Length;

      4. 小結    
        * 陣列是能保存相關資料元素序列的特殊變數。
        * 您應該記住陣列變數宣告的基本格式。
        * 存取陣列的每個元素，以透過用方括弧括住、以零為基礎的索引來設定或取得其值。
        * 如果您嘗試存取超出陣列界限的索引，將會收到執行階段例外狀況。
        * Length 屬性能讓您以程式設計方式判斷陣列中元素的數目。

    # foreach 陳述式
      1. 使用 foreach 在陣列中執行迴圈
        foreach (string s in aryString)
        {
          Console.Write(s);
        }
      2. 小結    
        * 使用 foreach 陳述式來逐一查看陣列中的每個元素，針對陣列中的每個元素執行相關聯的程式碼區塊一次。
        * foreach 陳述式會將陣列中目前元素的值設定至暫時變數，您可在程式碼區塊的本文中使用它。
        * 使用 ++ 遞增運算子來對變數的目前值新增 1。

    # 使用 C# 中的慣例、空白字元與註解，建立可讀取的程式碼(增加程式碼的可讀性與品質)

    # 選擇遵循規則與慣例的變數名稱
      1. 變數名稱規則
        * 變數名稱只能包含{英數字元}與{底線字元}。 
          不允許使用井字號 #、破折號. 與貨幣符號 $ 等特殊字元。
        * 變數名稱的{開頭必須是字母或底線}，而{不是數字}。 
          !! 注意: 開發人員會針對特殊用途使用底線( _ )，因此{請試著暫時不要使用它(底線字元)}。
        * 變數名稱{「不得」為 C# 關鍵字}。 例如，不允許使用下列變數名稱宣告：float float; 或 string string;。
        * 變數名稱會{區分大小寫}，這表示 string MyValue; 與 string myValue; 是兩個不同的變數。

      2. 變數名稱慣例    
        * 變數名稱應該使用 {駝峰式大小寫}，這是一種撰寫樣式，
          它會在第一個單字開頭使用小寫字母，並在每個後續單字的開頭都使用大寫字母。 
          例如：string thisIsCamelCase;。
        * 變數名稱在您的應用程式中應該是{描述性且有意義的}。 
          您應該針對您變數所保留的資料種類，選擇其名稱。
        * 變數名稱應該是一或多個完整的單字附加在一起。 
          !! 注意: {請勿使用縮寫}，因為讀取您程式碼的其他人可能不清楚該變數的名稱。
        
        * !! 注意: {變數名稱不應包含變數的資料類型}。 
          您可能會看到一些使用樣式 (例如 string strMyValue;) 的建議。 
          這是多年前常用的樣式。 不過，{{{大部分的開發人員都不再遵循這個建議}}}。

    # 練習. 為您的程式碼加上註解
      1. 程式碼註解 //    
        * 當您想要為程式碼片段的意圖留下一個備註時。 當您撰寫一組特別具挑戰性的程式碼指令時，這有助於描述用途或思考過程。 您的未來將會感謝您。
        * 當您想要暫時移除應用程式中的程式碼以嘗試不同的方法，但您還不確信新的構想是否有效時。 您可以將程式碼註解化、撰寫新的程式碼，然後在您確信新程式碼以您想要的方式運作之後，就可以安全地刪除舊的程式碼 (已加上註解的程式碼)。
        * 加入如 [TODO] 的訊息，以提醒您之後查看特定的程式碼片段。 雖然您應該謹慎使用，但這是有效的原因。 當您讀取一行可能會有顧慮的程式碼時，您可能正在使用另一個功能。 您可以將其標示為稍後進行調查，而不是忽略新的顧慮。 Visual Studio IDE 甚至會提供一個稱為「工作清單」的視窗，協助您識別您在程式碼中留下的 TODO 訊息。
        
        * !! 注意: 為{更高層級的構想使用註解}，而{不是加入個別程式碼行運作方式的相關註解}, 因為程式員常常會改碼, 忘記改註解.
          !! 利用 [多行註解], 在函式最上面說明構想.
      
      2. 多行註解 /* 註解三行或多行使用 */

    # 練習. 使用空白字元, 增加可讀性及段落感
      1. !! 注意(建議調整): 將左大括號和右大括號移至其本身的行，以改善間距
          Random dice = new Random();

          int roll1 = dice.Next(1, 7);
          int roll2 = dice.Next(1, 7);
          int roll3 = dice.Next(1, 7);

          int total = roll1 + roll2 + roll3;
          Console.WriteLine($"Dice roll: {roll1} + {roll2} + {roll3} = {total}"); //$ 插補字元, @"for" 逐字常值, 不把for作為無法使用的關鍵字

          if ((roll1 == roll2) || (roll2 == roll3) || (roll1 == roll3)) 
          {
              if ((roll1 == roll2) && (roll2 == roll3)) 
              {
                  Console.WriteLine("You rolled triples!  +6 bonus to total!");
                  total += 6; 
              } 
              else 
              {
                  Console.WriteLine("You rolled doubles!  +2 bonus to total!");
                  total += 2;
              }
          }
      
      2. 小結
        * 謹慎地使用空白字元，提升程式碼的可讀性。
        * 使用換行符號建立空行來分隔程式碼的語句。 語句是由類似或共同運作的程式碼行所組成。
        * 使用換行符號分隔程式碼區塊符號，使其位於自己的程式碼行上。
        * 使用 tab 鍵，將程式碼區塊與相關聯的關鍵字對齊。
        * 將程式碼區塊內的程式碼縮排，以顯示擁有權。

  學習路徑 - 使用 C# 建置 .NET 應用程式 (Build .NET applications with C#) (OK)
    參考資料: https://docs.microsoft.com/zh-tw/learn/paths/build-dotnet-applications-csharp/

    # 使用 ASP.NET Core 建立 Web API (CRUD) (2021/05/26, OK)
      1. REST in ASP.NET Core
        * REST 是 build web service的架構模式
        * GET. 從 Web service 存取資料.
        * POST. 在 Web service 上新增項目.
        * PUT. 在 Web Service 上更新項目.
        * DELETE. 在 Web Service 上刪除項目.
        * PATCH. 在 Web Service 上修正資料, 通常不會在同一支程式上使用.
      
      2. RESTful APIs 是由下列項目所組成的:
        * 1 組基本網址(a base URI)
        * HTTP 方法, 例: GET, POST, PUT, DELETE, PATCH.
        * 資料型態, 例: JSON or XML.
      
      3. 另外, 會搭配網址路由來區隔功能, 
        例1: http://localhost:5000/order 會路由至 OrderController
        例2: http://localhost:5000/Pizza 會路由至 PizzaController

      * 利用.NET Core建立 API的好處
        1. Simple serialization(物件快速序列化為JSON)
        2. Authentication and authorization(驗證及授權)
        3. Routing alongside your code(自動路由至對應程式碼)
        4. HTTPS by default(預設HTTPs, 基於點對點的加密, 自動產生測試用憑證)
        5. Share code & knowledge with .NET apps(程式碼可以相互分享)

      * 利用 .NET HTTP REPL 對 WebAPI 作測試
        0. WebAPI 並不適合利用 瀏覽器 作測試, 因為它不是回傳 HTML.
        1. REPL = Read-Eval-Print Loop.
        2. REPL = command line 的 測試互動環境
      
      * 如果要建立HTML based Web application ? 
        In order to serve a traditional HTML based web application with ASP.NET Core, 
        使用 Razor Pages or MVC 是比較好的作法.

      * 練習. 新增 Web API 專案
        
        =新增專案=
          1. 新增 Web API 專案資料夾 (ContosoPizza)
          2. 切換至 專案資料夾 (cd ContosoPizza)
          3. dotnet new webapi --no-https (註: 新增 WEBApi 專案, 先關閉 HTTPS 功能)
          
          4. !! 注意: 放到正式環境前, 必須設定 configure the ASP.NET Core HTTPS development certificate
            參考手冊: https://docs.microsoft.com/en-us/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0&tabs=visual-studio#trust-the-aspnet-core-https-development-certificate-on-windows-and-macos
          
          5. 檢視下列重要檔案功能
            * Controllers/ 放置公開的端點類別檔
            * Program.cs   內含1個 Main 方法, 這是APP的進入點
            * Startup.cs   設定服務 & app的 HTTP request pipeline.
            * ContosoPizza.csproj 內含專案相關設定.
        
        =建置和測試執行=
          1. dotnet build (註: 第1次建置, 成功後生出bin & obj兩個資料夾)
          2. dotnet run (註: 測試執行. 之後儘管程式碼修改, dotnet run 能同時完成編譯及執行作業)
          3. open browser 連接至 http://localhost:5000/weatherforecast 回傳 JSON 結果.

          4. dotnet tool install -g Microsoft.dotnet-httprepl (註: 開另一個CMD, 安裝 REPL 測試工具 )
              安裝成功訊息: 
                您可以使用下列命令來叫用工具: httprepl
                已成功安裝工具 'microsoft.dotnet-httprepl' ('5.0.2' 版)。
            4.1. httprepl http://localhost:5000 (註: 利用 httprepl 連結 WEBAPI)
              連接成功訊息:
                (Disconnected)> connect http://localhost:5000
                Using a base address of http://localhost:5000/
                Unable to find an OpenAPI description
                For detailed tool info, see https://aka.ms/http-repl-doc

                http://localhost:5000/>
            4.2. ls (註: 列出 OpenAPI 項目)
            4.3. cd (註: 切換路由)
            4.4. get (註: 送出查詢, 並列印回傳結果)
            4.4. exit (註: 離開目前session.)

        =(重要章節)ASP.NET Core Web API Controllers=
          1. 新增 Controllers前, 先檢視範例 WeatherForecastController
            
            * :ControllerBase , 內含建立WEB API的許多基本功能, 用來控制 HTTP requests.
            
            * API Controller 類別屬性, 有兩個重要類別屬性
              > [ApiController]         註: [ApiController] enables opinionated behaviors that make it easier to build web APIs.
              > [Route("[controller]")] 註: [Route] defines the routing pattern [controller]
              
              > [Route("api/[controller]")] 註: 另一種路由規則, http://localhost:5000/api/controllerName
        

            * Providing Weather results with the Get() method
              > [HttpGet]
              > public IEnumerable<WeatherForecast> Get() 註: 就是此公開方法, 提供回傳值.

              > [HttpGet("{id}")] 註: 另一種有傳入參數的GET型態.

        =練習-新增資料存放區(Add a data store, Model Class)=
          1. Create a pizza model (Model Class)
          2. Add data service (新增1個 in-memory pizza data services)
              註: 使用 泛型List<Pizza> 儲存Pizza資料, 利用 LINQ異動泛型List<Pizza>內的資料.
          3. dotnet build
              註: 檢查是否有錯誤.

        =練習-新增Controller(Add a controller)=
          1. ActionResult or IActionResult 的差別?
            ActionResult 僅能回傳受限類型, 另外它也是IActionResult實作結果.
            IActionResult 回傳類型不受限, 例如: 下列回傳結果都是
              * ContentResult
              * EmptyResult
              * FileResult
              * HttpStatusCodeResult
              * JavaScriptResult
              * JsonResult
              * RedirectResult
              * RedirectToRouteResult 

        =ASP.NET Core 的 CRUD作業=

        =練習-實作CRUD作業=

        =總結=

    # 處理 .NET 應用程式中的檔案與目錄 (2021/06/01, OK)

      {小結}
        
        * {Directory.EnumerateDirectories} and {Directory.EnumerateFiles} 
          accept a parameter that enables you to specify a search condition for names to return, 
          and a parameter to recursively traverse all child directories.
          
          註: 好用函式, 搜尋符合指定條件 & 是否遍尋子階資料夾 的資料夾及檔案.
        
        * {System.Environment.SpecialFolder} is an enumeration that enables you to access system-defined folders, 
          such as the desktop or user profile, in a cross-platform manner without having to memorize the exact path for each operating system.

          註: 指定專用資料夾, 且會依系統別自動對應.

        * If you need to parse other file types, {check out the packages on nuget.org}. 
          For example, you can use the {CsvHelper} package for .csv files.
          You can use the {Newtonsoft} package for .json files.

          註: 解析資料時, 可先至 nuget 尋找是否有合適的{解析器}.

      {Work with the file system}
        
        using System.IO;

        * 可利用此命名空間內的資料型態, 讀取、寫入、同步及非同步資料串流及檔案.
        * 列出所有資料夾, Directory.EnumerateDirectories("folderPath");
        * 列出資料夾的所有檔案, Directory,EnumerateFiles("folderPath");
        * 列出資料夾(含子資料夾)特定檔案, Directory.EnumrateFiles("stores", "*.txt", SearchOption.AllDirectories);

      {Clone the project}
        
        * 複製所需專案資料檔及資料夾.
          git clone https://github.com/MicrosoftDocs/mslearn-dotnet-files && cd mslearn-dotnet-files
        
        * 指令: 新增Console專案
          dotnet new console -n files-module -o .

        * 複製範例資料夾(stores)到Console專案內.
        
      {Work with file paths in .NET}

        * 確認目前資料夾路徑, Directory.GetCurrentDirectory()

      {Work with special directories}

        * 根據不同作業系統或環境, 自動調整對應參數,  System.Environment.SpecialFolder.*
          string docPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); //回傳微軟系統的"我的文件夾"

      {Work with paths}

        * Path 類別是放在 System.IO 內.
        
        * !!注意: Path 只會協助組合出路徑, 至少路徑是否存在, 還要實際測試才知道.
        
        * 組合正確路徑的兩種方法 => .NET 自動判別系統, 加上正確的分隔符號. ex. 微軟用 'stores/201' 蘋果用 'stores\201'.
          
          1. Path.DirectorySeparatorChar
            string folderPath = $"stores{Path.DirectorySeparatorChar}201"; // output: stores/201

          2. Path.Combine("stores","201");
            string folderPath = Path.Combine("stores","201"); // same output: stores/201

        * 取出檔案副檔名, Path.GetExtension("sales.json"); // output: .json {Determine filename extensions}

        * 從檔案或資料夾取得任何你所知道的資訊. by Path.DirectoryInfo(<directoryPath>), by Path.FileInfo(<filePath>)

          string fileName = $"stores{Path.DirectorySeparatorChar}201{Path.DirectorySeparatorChar}sales.json"; // stores/201/sales.json

          FileInfo info = new FileInfo(fileName);
          info.FullName
          info.Directory
          info.Extension
          info.CreateTime...

      {Create files and directories}

        * Directory 類別, 用來新增、刪除、複製和移動 {資料夾}...
        * File 類別, 用來新增、刪除、複製和移動 {檔案}...

        * Create directories
          
          Directory.CreateDirectory(Path.Combine(Directory.GetCurrentDirectory(), "stores", "201", "newDir"));
          
          > Directory.CreateDirectory() 不會失敗, 如果全路徑或部分路徑不存在, 它會自動新增補足.

        * 確認資料夾是否存在 ?

          bool isDirExists = Directory.Exists(filePath);

        * 新增檔案

          File.WriteAllText(filePath, "data to be written.");

          File.WriteAllText(Path.Combine(Directory.GetCurrentDirectory(), "stores", "201", "textOutput.txt"), "Hello 2021/06/01");

          > 檔案不存在, 新增檔案並寫檔.
          > 檔案已存在, 覆蓋檔案內容.

      {Read and Write to files}

        * Read data from files. 從檔案讀取資料

          File.ReadAllText(Path.Combine("stores", "201", "sales.json"));
        
        * Parse data in files. 解析檔案內資料

          > 解析 JSON 檔案, 常用 Json.NET
          > 加入參考, dotnet add package Newtonsoft.Json

          using Newtonsoft.Json;

          class SalesTotal
          {
            public double Total {get;set;}
          }

          var salesJson = File.ReadAllText(Path.Combine("stores", "201", "sales.json"));
          var salesData = JsonConvert.DeserializeObject<SalesTotal>(salesJson);

          Console.WriteLine(salesData.Total);

        * 檔案格式各式各樣, 可能會碰到 .csv, 固定寬度, 或其他格式. => 最好的方式去 nuget.org 上找適合的解析工具.

        * Write data to files. 寫資料進檔.

          > File.AppendAllText(<filePath>, <fileData>); // 附加檔案資料
          > File.WriteAllText(<filePath>, <fileData>); // 寫檔案資料(直接覆蓋)

          // 寫檔案資料(直接覆蓋)
          var data = JsonConvert.DeserializeObject<SalesTotal>(Path.Combine("stores", "201", "sales.json"));
          File.WriteAllText(Path.Combine("salestotalDir", "totals.txt"), data.Total.toString());

          // 附加檔案資料
          var data = JsonConvert.DeserializeObject<SalesTotal>(Path.Combine("stores", "201", "sales.json"));
          File.AppendAllText($"salestotalDir{DirectorySeparatorChar}totals.txt", $"{data.Total}{Environment.NewLine}");

    # .NET 簡介 (2021/06/28, OK)

    # 撰寫您的第一個 C# 程式碼 (2021/06/28, OK)

    # 建立新的 .NET 專案並使用相依性(套件) (2021/06/28, OK)
      > 學習目標
        1. .NET專案初始化
        2. .NET專案, 加入套件及移除套件
        3. 管理套件的相依件, 並更新這些套件
      
      > 評估你是否需要使用套件
        1. 產出更好的程式碼, 例: 使用成熟的安全性驗證套件
        2. 節省時間, 例: 利用套件可讓你更快完成目標
        3. 可維護性, 例: 評估是否有必要自行維護或使用開放原始碼即可

      (註): 安裝前, 通常會至 https://www.nuget.org/packages/<package name>了解套件功能.

      > 安裝套件
        1. 指令: {dotnet add package <name of package>}
          例: {dotnet add package Humanizer}
        2. 指令執行後, 套件檔案會放在 所有專案都能使用的 <cached Folder> 內.
        3. 安裝 & 專案編譯後, 套件檔案會放在 <debug> 或 <release> 資料夾內.
          -| bin/
          ---| Debug/
          ------| net3.1
          --------| <files included in the dependency>

      > 尋找套件
        1. 套件可能放置在
          a. Registries(儲存庫), 例: NuGet.org 放置自己套件, 私人或公開的; 例: GitHub and Azure DevOps, 通常是私有的
          b. Files(本地檔案), 通常是自行開發&本地測試, 或是某些理由不公開.

      > NuGet 儲存庫 和 dotnet tool
      > .NET 指令工具(.NET Core CLI), 指令大致上可分為三類:
        1. 管理套件相依性, 例: 安裝, 移除, 清除, 更新..
        2. 執行程式, 協助管理程式開發流程, 例: 測試、編譯、升級移轉
        3. 撰寫和發行套件, 例: 產生壓縮套件 & 發行至儲存庫
        4. 查詢功能指令: {dotnet --help}, 列出所有指令清單

      > 如何安裝套件相依性組件(part of package)
        指令: {dotnet add package <dependency name>}

      > 如何安裝指令工具
        指令: {dotnet tool install <name of package>}

      > 如何安裝程式範本(templates)
        指令: {dotnet new -i <name of package>}
        
      > 安裝後, 列出專案內所有套件
        1. 指令: {dotnet list package} (最上層)
        1. 指令: {dotnet list package --include-transitive} (列出所有可轉移套件)
        2. The installed packages are listed in the dependencies section of your {.csproj} file
      
      > 還原套件
        0. 套件實際加入專案時間點在 {專案編譯後}.
        1. 指令(明確地): dotnet restore
        1. 指令(隱含地): dotnet new.. dotnet build.. dotnet run.., 都會將套件自動加入專案中.

      > 清理(clean up)套件
        0. 若不需要這個套件, 記得把它移除.
        0. Doing so keeps things clean. Also, dependencies take up space.
        1. 指令: {dotnet remove package <name of package>}

      > 設定專案只會取得patch(bug fix)更新
        Project檔案內, 使用下列設定
        <PackageReference Include="<package>" Version="2.7.*">

      > Semantic Version語意版本
        <Major>.<Minor>.<Patch>

        1. 套件<Major版本號>變更, 引用程式要改寫
        2. 套件<Minor版本號>變更, 通常是套件功能新增, 引用程式毋須大改, 但程式仍有故障風險.
        3. 套件<Patch版本號>變更, 通常是套件BUG修正, 引用程式毋須大改.

      > 設定專案套件版本更新規則
        0. 如果你使用很多套件, 最好先設套件更新規則. 當專案還原(restore), 編譯(build), 執行(run).
        
        {規則1} <==強烈建議使用==>
          Notation 	    Applied rule 	Description
          1.0 	            x >= 1.0 	Minimum version, inclusive
          (1.0,) 	          x > 1.0 	Minimum version, exclusive
          [1.0] 	          x == 1.0 	Exact version match
          (,1.0] 	          x ≤ 1.0 	Maximum version, inclusive
          (,1.0) 	          x < 1.0 	Maximum version, exclusive
          [1.0,2.0] 	1.0 ≤ x ≤ 2.0 	Exact range, inclusive
          (1.0,2.0) 	1.0 < x < 2.0 	Exact range, exclusive
          [1.0,2.0) 	1.0 ≤ x < 2.0 	Mixed inclusive minimum and exclusive maximum version
          (1.0) 	          invalid 	invalid(錯誤寫法)
        
        {規則2}
          6.0.* , 表示自動套用6.0.x的最新版, 例: 來源有 6.0, 6.0.1, 6.1, 要求 Version >= 6.0.*, 實際取得 6.0.1
          4.*   , 表示自動套用4.x的最新版

        {套件版本設定範例}
          <!-- Accepts any version 6.1 and later. -->
          <PackageReference Include="ExamplePackage" Version="6.1" />

          <!-- Accepts any 6.x.y version. -->
          <PackageReference Include="ExamplePackage" Version="6.*" />
          <PackageReference Include="ExamplePackage" Version="[6,7)" />

          <!-- Accepts any later version, but not including 4.1.3. Could be
              used to guarantee a dependency with a specific bug fix. -->
          <PackageReference Include="ExamplePackage" Version="(4.1.3,)" />

          <!-- Accepts any version earlier than 5.x, which might be used to prevent pulling in a later
              version of a dependency that changed its interface. However, we don't recommend this form because determining the earliest version can be difficult. -->
          <PackageReference Include="ExamplePackage" Version="(,5.0)" />

          <!-- Accepts any 1.x or 2.x version, but not 0.x or 3.x and later. -->
          <PackageReference Include="ExamplePackage" Version="[1,3)" />

          <!-- Accepts 1.3.2 up to 1.4.x, but not 1.5 and later. -->
          <PackageReference Include="ExamplePackage" Version="[1.3.2,1.5)" />

      > 檢查套件是否有新版
        1. 指令: {dotnet list package --outdated}
        
    # 使用 Visual Studio Code 偵錯工具對 .NET 應用程式進行互動式偵錯 (2021/06/29, OK)
      > 學習目標      
        1. 搭配 .NET 程式使用 Visual Studio Code 偵錯工具。
        2. 建立中斷點並逐步執行程式碼，以找出問題。
        3. 在執行的任何階段中檢查程式狀態。
        4. 倒轉呼叫堆疊，以找出例外狀況的來源。

      > 什麼是偵錯工具
        1. 將程式裝載於其本身的執行處理序中，或作為獨立處理序連結至執行中的程式(例.NET)來執行
        2. 類型: 從Command Line執行, 從圖形化使用者介面執行

      > 偵錯工具的兩大重要功能
        1. 對程式執行的控制。例: 暫停程式並逐步執行
        2. 觀察程式的狀態。例:變數值和函式參數
        3. 另外, 最適合用來觀察不同函式中特定變數目前的值, {監看面板}.
        4. 另外, 顯示目前在範圍內的所有變數, {變數面板}.

      > .NET 應用程式中的記錄與追蹤(使用情境)
        1. 追蹤常用於監視應用程式執行狀況，在正式上線後。(分散式應用程式直接用偵錯功能，也不容易找錯)
        2. 長期間出現的問題
        3. 多緒行緒應用程式與分散式應用程式
        4. 分散式應用程式的問題由許多元件間交互作用而產生
        5. 服務不該停止，連接偵錯工具可能導致逾時失敗
        6. 問題不一定經常發生。利用記錄和追蹤功能(低額外負荷)，在發生問題時，程式會記錄。

      > 將資訊寫入至輸出視窗(方式有3種)      
        1. System.Console (最簡單, 通常用於進行臨機操作的暫時性偵錯; 客戶用)
            一律啟用且一律寫入到主控台。
            適用於客戶可能需要在發行版本中看到的資訊。
            此偵錯程式碼通常絕對不會簽入到原始程式碼控制。
        
        2. System.Diagnostics.Trace (已上線, 找問題用)
            只有在定義 TRACE 時才會啟用。
            寫入到已連結的接聽程式，預設為 DefaultTraceListener。
            在建立將在大部分組建中啟用的記錄時，請使用此 API。
        
        3. System.Diagnostics.Debug (已上線, 程式員偵錯用)
            只有在已定義 DEBUG 時才會啟用 (在偵錯模式中)。
            寫入到已連結的偵錯工具。
            在建立將只在偵錯組建中啟用的記錄時，請使用此 API。

          Console.WriteLine("This message is readable by the end user.");
          Trace.WriteLine("This is a trace message when tracing the app.");
          Debug.WriteLine("This is a debug message just for developers.");

        註: !!輸出格式的官方建議!!
          1. 結合多個來源，產生單一資訊時 => 請使用多個 Write
          2. 單一完整資訊 => 請使用 WriteLine

      > 定義 TRACE & DEBUG 常數 (VIP, 可限定發行版本, 只有 Trace 語法生效)
        1. 預設，偵錯時期執行，會定義 DEBUG 變數。
        2. 指定，利用專案檔內屬性群組，新增 DefineConstants 項目控制。

        <!-- Debug時, 開啟 DEBUG & TRACE -->
        <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
          <DefineConstants>DEBUG;TRACE</DefineConstants>
        </PropertyGroup>
        <!-- Release時, 開啟 TRACE -->
        <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
            <DefineConstants>TRACE</DefineConstants>
        </PropertyGroup>

      > 條件式追蹤
        1. 簡單, Write() & WriteLine();
        2. 條件, WriteIf() & WriteLineIf();

        範例1:
          if (count == 0)
          {
            Debug.WriteLine("The count is 0 and this may cause an exception.");
          }
        範例2:
          Debug.WriteLineIf(count == 0 , "The count is 0 and this may cause an exception.");
        範例3:
          bool errorFlag = false;
          System.Diagnostics.Trace.WriteIf(errorFlag, "Error in AppendData procedure.");
          System.Diagnostics.Debug.WriteIf(errorFlag, "Transaction abandoned.");
          Trace.Write("Invalid value for data request");

      > 確認特定條件是否存在
        1. 利用 Assert 陳述式測試條件(放入正常值), 將條件放入 Assert 引數內.
          若 判斷結果為 true, 則不會執行任何動作.
          若 判斷結果為 false, 則判斷提示會失敗. (使用debug組建執行時, 程式會進入中斷模式.)
        2. Debug.Assert(condition, message) & Trace.Assert(condition, message), 都能使用.
          但 Debug.Assert程式碼不會放入 Relase版本 中, 故不會增加Relase版本程式碼大小或減緩程式執行速度.
        3. Debug.Assert(condition, message)方法, 可用來測試程式碼正確的情況下, 判斷結果應為 True 的條件.
          例:
            static int IntDivide(int dividend, int divisor)
            {
                //除數不得為0
                System.Diagnostics.Debug.Assert(divisor != 0, $"nameof(divisor) is 0 and will cause an exception.");
                return dividend / divisor;
            }

        4. !!注意!! 
          當您使用 System.Diagnostics.Debug.Assert 時，
          請確定移除判斷提示時，判斷提示中的任何程式碼都不會變更程式的結果。 
          否則，您可能會不小心引進了只會出現在程式發行版本中的錯誤 (Bug)。 
          特別注意包含函式或程序呼叫的判斷提示。

      > 練習- 記錄和追蹤(專案名稱: DotNetDebugging)
        1. 寫入偵錯主控台 (常用於"觀察計算過程")
          Debug.WriteLineIf(sum == 1, $"sum is 1, n1 is {n1}, n2 is {n2}");

        2. 使用判斷提示(Assert)檢查條件 (常用於"條件是否如預期發生.", 不如預期時，停止執行中程式)
          // If n2 is 5 continue, else break.
          Debug.Assert(n2 == 5, "The return value is not 5 and it should be.");
          return n == 0 ? n1 : n2;

        3. 執行測試1, 在不進行偵錯情況執行程式{cmd: dotnet run} , 結果如何?
          A: 請注意，在判斷提示失敗並將資訊記錄到應用程式輸出之後，應用程式即會終止。
            Process terminated. Assertion failed.
            The return value is not 5, actual return is 8
              at DotNetDebugging.Program.Fibonacci(Int32 n) in C:\Projects_C#\DotNetDebugging\Program.cs:line 38
              at DotNetDebugging.Program.Main(String[] args) in C:\Projects_C#\DotNetDebugging\Program.cs:line 10

        4. 執行測試2, 在{發行設定}下執行程式{cmd: dotnet run --configuration Release}
          A: 應用程式已成功執行到完成，因為我們已不再處於 Debug 設定中。
          註: 重點在於 {定義 TRACE & DEBUG 常數 (VIP, 可限定發行版本, 只有 Trace 語法生效)}

  學習路徑 - 使用 C# 處理資料 (Work with data in C#) (OK)
    參考資料: https://docs.microsoft.com/en-us/learn/paths/csharp-data/

    Module1: 在您的 C# 程式碼中選擇正確資料類型 (2021/06/30, OK)

      > 整數型別 (sbyte, short, int, long / byte, ushort, uint, ulong)
        1. 整數型別是簡單的實值資料類型，可保存整數。
        2. 其中有帶正負號及不帶正負號(均為正數)的資料類型，帶正負號的實值型別會使用1位元儲存其值為正數或負數。
            註: 有u開頭型別為正數型號 = 不帶正負號
        3. 能利用數值類型的 MaxValue & MinValue 屬性來評估數值能否容納在資料型態內。

      > 評估浮點數類型 (float, double, decimal)
        1. float & double 以 2進位 格式儲存(取實際值的大約值); decimal 以 10進位 格式儲存(取精確值).
        2. 案例1: 計算遊戲爆炸範圍，取大約值即可，所以用 float or double即可.
        3. 案例2: 財務運算，取精確值才行，應使用 decimal.
        4. E = 科學符號 = 乘於10的幾次方，例: 5E+2 = 5 * 10^2 = 5 * 10 * 10 = 5乘於10的2次方
        5. 浮點數是實值資料類型，可保存小數。
        6. 選擇正確的浮點數考慮項目: 最大值、最小值；2進位或10進位儲存；精確度要求
        7. 浮點數十分龐大時，會利用 E 科學符號表示
        8. 編譯器和執行階段處理 decimal 的方式，與處理 float 或 double 的方式有基本差異，尤其是在判斷數學運算所需的正確性程度時。

      > 參考型別與實值型別的差異
        0. 參考型別的類型: {陣列}, {類別} 和 {字串}.
        1. 參考型別: 參考型別變數會將其值儲存在稱為「堆積(Heap)」的不同記憶體區域中。 堆積是同時在作業系統上執行的許多應用程式所共用記憶體區域。
        2. 參考型別 保存可較大的值，堆疊內放的是{實際值的參考位址}。
        2. 使用 new 運算子來建立參考類別的新執行個體，並將其位址傳回至變數。
        3. 實值型別: 實值型別變數會將其值直接儲存在稱為「堆疊(Stack)」的儲存體區域。 堆疊是配置到目前正在 CPU 上執行程式碼的記憶體 (也稱為堆疊框架或啟用框架)。 當堆疊框架完成執行時，堆疊中的值便會移除。
        4. 實值型別 保存可較小的值，它直接把值放在堆疊內。
        5. 實值型別的類型: {整數}, {浮點數}, {字元char}, {結構}, {列舉}。所以實值型別只能儲存數字(X)
        6. 將實值型別(堆疊)中的值 => Copy to(複製) => 到參考型別(堆積)中的行為，就叫Boxing(裝箱)
        7. 將到參考型別(堆積)中的值 => Copy to(複製) => 到實值型別(堆疊)中的行為，就叫UnBoxing(拆箱)
        8. 因為裝箱跟拆箱的過程，會消耗程式效能。所以才會衍生出(集合)及(泛型)等類型, 降低耗能.
        
      > 資料類型的常用慣例
        {有疑慮時, 就使用'一般'}
          1. int, 用於大多數的整數
          2. decimal, 用於表示貨幣的數字
          3. bool, 用於 True or False 值
          4. string, 用於英數值
    
        {特殊情況}
          5. byte, 用於處理不同字元集的編碼資料(例: Unicode)
          6. double, 用於幾何或科學用途, 例: 涉及動作的遊戲
          7. System.StringBuilder, 用於從許多常數或其他變數建置單一字串, 例: String.StringBuilder sb = new StringBuilder(); sb.ToString();
          8. System.DateTime, 用於特定日期和時間值
          9. System.TimeSpan, 用於一段範圍的年/月/日/時/分/秒/毫秒

    Module2: Convert data types using casting and conversion techniques in c# (2021/12/22) https://docs.microsoft.com/en-us/learn/modules/csharp-convert-cast/?ns-enrollment-type=LearningPath&ns-enrollment-id=learn.languages.csharp-data

      > Unit 1 of 9 - Introduction - 2021/12/22

      > Unit 2 of 9 - Exercise - data type casting and conversion   2021/12/22     
          問題1: Is it possible, depending on the value, that attempting to change the value's data type would throw an exception at run time?
            // Error, 為避免異常發生, 還是必須執行<資料轉型>
            int first = 2;
            string second = "4";
            int result = first + second;
            Console.WriteLine(result);

            // Success
            int first = 2;
            string second = "4";
            string result = first + second;
            Console.WriteLine(result);

          問題2: Is it possible, depending on the value, that attempting to change the value's data type would result in a loss of information?
            
            // Sample-1
            int myInt = 3;
            Console.WriteLine($"int:{myInt}");

            // The key to this example is this line of code: 縮小轉換
            decimal myDecimal = myInt; 
            Console.WriteLine($"decimal: {myDecimal}");

            // Sample-2
            decimal myDecimal = 3.14m;
            Console.WriteLine($" decimal: {myDecimal}");

            // 另一個縮小轉換 例子 by ()
            int myInt = (int)myDecimal;
            Console.WriteLine($" int: { myInt }");

          問題3: 我如何知道轉換是"延伸"或"縮減"呢 https://docs.microsoft.com/en-us/dotnet/standard/base-types/conversion-tables

            或者 利用撰寫簡單程式測試

            decimal myDecimal = 1.236456789m;
            float myFloat = (float)myDecimal;
            Console.WriteLine($"decimal:{myDecimal}");
            Console.WriteLine($"float:{myFloat}");

            // Output (輸出結果得知, 這是"縮減"轉換, 因為losing precision.)
            Decimal: 1.23456789
            Float: 1.234568 

          Performing Data Conversions(執行資料轉換的三種方式)
            1. Use a helper method on the variable
            2. Use a helper method on the data type
            3. Use the Convert class' methods

          Step 4 - Modify the code in the .NET Editor to convert a number to a string using the ToString() helper method

            Use ToString() to convert a number to a string => 數值轉字串, 用 ToString()

              //Code Sample
              int first = 5;
              int second = 7;
              string message = first.ToString() + second.ToString();
              Console.WriteLine(message);

          Explicitly converting a string to a number => 字串轉數值, Parse()

          Step 5 - Modify the code in the .NET Editor to convert a string to an int using the Parse() helper method
              
            //Code Sample
            string first = "5";
            string second = "7";
            int sum = int.Parse(first) + int.Parse(second);
            Console.WriteLine(sum);

            //更好的轉換方式是透過 TryParse(), 而非 Parse()

          Data Conversion using the Convert class

          Step 6 - Modify the code in the .NET Editor to 
          convert a string to a number using the Convert class

            //Code Sample
            string value1 = "5";
            string value2 = "7";
            int result = Convert.ToInt32(value1) * Convert.ToInt32(value2);
            Console.WriteLine(result);

            //重要概念: 何時該使用 Convert 類別呢? 
            //The Convert class is best for converting fractional numbers into whole numbers (int) because it rounds up the way you would expect.
            //Convert類別是將小數(fractional numbers)轉換為整數(whole numbers)時的最佳選擇.

          Casting(強制轉型) versus Conversion(轉型)

          Step 7 - Modify the code in the .NET Editor to compare casting 
          and converting a decimal into an int(縮減轉型)

            //Code Sample
            int value (int)1.5m; // castiing truncates 強制去尾數 
            Console.WriteLine(value); // output : 1

            int value2 = Convert.ToInt32(1.5m); // converting rounds up 強制進位
            Console.WriteLine(value2); // output : 2

          * Recap(重點回顧)

            We covered several important concepts of data conversion and casting:
            1. Perform a data conversion when it's possible that doing so could cause a runtime error.
            2. Perform an explicit cast to tell the compiler you understand the risk of losing data.
            3. Rely on the compiler to perform an implicit cast when performing an expanding conversion.
            4. Use the () cast operator and the data type to perform a cast (for example, (int)myDecimal). <= 強制去尾數
            5. Use the Convert class when you want to perform a narrowing conversion, but want to perform rounding, not a truncation of information.(for example, Convert.ToInt32(value1)) <= 強制進位

      > Unit 3 of 9 - Exercise - How To Use the TryParse(string , out int) method return 'true' -> '轉換成功' / 'false' -> '轉換失敗' 2021/12/22

        Exercise - TryParse() method
          因為字串資料型態可能帶有非數值資料, 可能在執行階段轉換時發生異常.
            //sample code
            string name = "bob";
            Console.WriteLine(int.Parse(name));

            //Error
            System.FormatException: 'Input string was not in a correct format.'

        Solution: Use TryParse()

          The TryParse() method does several things simultaneously:
            1.  It attempts to parse a string into the given numeric data type.
            2.  If successful, it will store the converted value in an out parameter.
            3.  It returns a bool to indicate whether the action succeeded or failed.
          
          註: TryParse()方法在所有的 int 資料型態內都有.
          What is an out parameter?
          Step 1 - TryParse() a string into an int

            //sample code
            string value = "102";
            int result = 0; // 另一個重點在這, 因為它被利用out 指示詞傳出來, 所以之後的判斷也能使用...
            
            // 重點: will return true if it successfully converted our string variable value into an int 
            if (int.TryParse(value, out result)) 
            {
              Console.WriteLine($"Measurement: {result}");
            }
            else
            {
              Console.WriteLine("Unable to report the measurement.");
            }

            if (result > 0)
            {
              //我也可以用...
            }

        * Recap(重點回顧)
          The TryParse() method is a very valuable tool.(TryParse 方法是個十分有用的工具)
          Here are few quick ideas to remember.
            1. Use TryParse() when converting a string into a numeric data type.(轉換字串至數值型態時)
            2. TryParse() returns true if the conversion is successful, false if it's unsuccessful.
            3. An out parameter provides a secondary means of a method returning a value. 
              In this case, the out parameter returns the converted value.(第2個參數:回傳轉換結果)
            4. Use the keyword out when passing in an argument to a method that has defined an out parameter.(第2個參數:要加上out指示詞傳入)

      > Unit 4 of 9 - First Challenge <難度頗高, 要徹底搞清楚 數值.TryParse用法才解的出來> 2021/12/22

        Code challenges throughout these modules will reinforce what you've learned and help you gain some confidence before continuing.
        Step 1: Delete all of the code in the .NET Editor from the earlier exercise.
        Step 2: Write code in the .NET Editor to implement the business rules.
        
        Iterate through each value in a string of values.
        
        Start with the following line of code.
        string[] values = { "12.3", "45", "ABC", "11", "DEF" };
        
        Add all the code necessary to implement the following business rules:
        Business Rules:
          Rule 1: If the value is alphanumeric, concatenate it to form a message
          Rule 2: If the value is numeric, add it to the total
          Rule 3: Make sure the result matches the following output:
            Message: ABCDEF
            Total: 68.3
      
      > Unit 5 of 9 - My Sample Code(我完成的程式碼, 果然要先把邏輯寫出來) 2021/12/22 

        string[] values = { "12.3", "45", "ABC", "11", "DEF" };
        string message = "";
        decimal total= 0;
        decimal after = 0;

        foreach (string i in values)
        {
            if (decimal.TryParse(i , out after))
            {
                total += after;
                //true: able to convert to number, add to total
            }
            else
            {
                message += i;
                //false: unable to convert to number, concat to message
            }
        }

        //print Output
        System.Console.WriteLine($"Message: {message}");
        System.Console.WriteLine($"Total: {total}");

      > Unit 6 of 9 - Second Challenge <理解 impact of narrowing and widening conversions的影響> <= 簡言之, Convert.ToInt32() = (int), (decimal)/(decimal) = (decimal), (float)/(int) = (float)

        Step 1: Delete all of the code in the .NET Editor from the earlier exercise
        Step 2: Write code in the .NET Editor to produce the desired output
          
          int value1 = 12;
          decimal value2 = 6.2m;
          float value3 = 4.3f;

          // Your code here to set result1
          Console.WriteLine($"Divide value1 by value2, display the result as an int: {result1}");

          // Your code here to set result2
          Console.WriteLine($"Divide value2 by value3, display the result as a decimal: {result2}");

          // Your code here to set result3
          Console.WriteLine($"Divide value3 by value1, display the result as a float: {result3}");

      > Unit 7 of 9 (以下只是一種可能解) 2021/12/22

        int value1 = 12;
        decimal value2 = 6.2m;
        float value3 = 4.3f;

        int result1 = Convert.ToInt32((decimal)value1 / value2);
        Console.WriteLine($"Divide value1 by value2, display the result as an int: {result1}");

        decimal result2 = value2 / (decimal)value3;
        Console.WriteLine($"Divide value2 by value3, display the result as a decimal: {result2}");

        float result3 = value3 / value1;
        Console.WriteLine($"Divide value3 by value1, display the result as a float: {result3}");

      > Unit 8 of 9 - Knowledge check 2021/12/22
        1. 你要從string 4.123456789 轉為 decimal, 應該避免使用下列何種技術??
          a. Convert.ToDecimal()
          b. decimal.TryParse()
          c. (decimal) (X)

        2. You need to change a float into an int. How would you describe this action?
          (O)This is a narrowing conversion.
          This is a widening conversion.
          This is an illegal conversion.
          This is a parsing conversion.

      > Unit 9 of 9 - 2021/12/22

          Summary
            Our goal was to use several different techniques to change the data type of a given value.
            We used <implicit conversion>(隱含轉換), relying on the C# compiler to perform widening conversions. 
            When the compiler was unable to perform an implicit conversion, we used explicit conversions. 
            We used the ToString() method to explicitly convert a numeric data type into a string.

            When we needed to perform narrowing conversions, we used several different techniques. 
            We used the casting operator () when the conversion could be made safely and were willing to accept truncation of values after the decimal. 

            And we used the Convert() method when we wanted to perform a conversion and use common rounding rules when performing a narrowing conversion.

            Finally, we used the TryParse() methods when the conversion from a string to a numeric data type could potentially result in a data type conversion exception.

            Without this wealth of options, it would be difficult to work in a strongly typed programming language. 
            Fortunately, this well executed system of types, conversion, and casting can be harnessed to build error free applications.

    Module3: Perform operations on arrays using helper methods in C# (2021/12/23~2021/12/29) https://docs.microsoft.com/en-us/learn/modules/csharp-arrays-operations/?ns-enrollment-type=LearningPath&ns-enrollment-id=learn.languages.csharp-data
    
      Use powerful helper methods to manipulate and control the content of arrays.

      > Unit 1 of 10 - Introduction
        1. 正向及反向排列陣列項目順序
        2. 清清及重新定義陣列項目
        3. 將字串分割(Split)為字串(string)陣列或字元(char)陣列
        4. 合併(Join)陣列項目為字串

      > Unit 2 of 10 - Exercise - Sort() and Reverse()

        Use array methods to sort elements in an array
        //Step 1 - Create an array of pallets, then sort them
        //  Array.Sort(pallets); //將 array 內容由小到大作排序

        //Sample Code
        string[] pallets = { "B14", "A11", "B12", "A13"};

        Console.WriteLine("Sorted...");
        Array.Sort(pallets); //將 Array.Sort 內容由小到大作正向排序
        foreach(var pallet in pallets)
        {
          Console.WriteLine($"--{pallet}");
        }

        //Step 2 - Reverse the order of the pallets
          //Array.Reverse(pallets)

        Console.WriteLine("...");
        Console.WriteLine("Reversed...");
        Array.Reverse(pallets); //將 Array.Reverse 內容由大到小作反向排序
        foreach(var pallet in pallets)
        {
          Console.WriteLine($"--{pallet}");
        }

        * Recap(重點回顧)
          1. Array.Sort(); //Array 類法方法可以操縱 array順序(正向)
          2. Array.Reverse(); //Array 類法方法可以操縱 array順序(反向)

      > Unit 3 of 10 - Exercise - Clear() and Resize() 2021/12/28

        Use array methods to clear and resize an array
        //Step 1 - Clear items from the array
          //  Array.Clear(array,index,number); //array=要清除的陣列對象,index=索引起始值,number=清除個數
          //  Array.Clear(array,0,2); // 從index=0開始清,清除2個
          // 重點: Clear != Remove, 清除後空間還在, 只有值不見了....

          //Sample Code(陽春版)
          string[] pallets = {"B14", "A11", "B12", "A13"};
          Console.WriteLine("");

          Array.Clear(pallets,0,2); 
          Console.WriteLine($"Clearing 2 .. Count: { pallets.Length }");
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

          //Empty string versus null
          When you use Array.Clear(), the elements that were cleared no longer reference a string in memory. 
          In fact, the element points to nothing at all. 
          This is an important distinction that can be difficult to grasp at first.

        //Step 2 - Access the value of a cleared element (C# compile 自動把 null 轉為 "" 字串顯示出來)

          //Sample Code(加強版)
          string[] pallets = {"B14", "A11", "B12", "A13"};
          Console.WriteLine("");

          Console.WriteLine($"before:{pallets[0]}"); //清除前, "B14"
          Array.Clear(pallets,0,2); 
          Console.WriteLine($"after:{pallets[0]}"); //清除後, null, 卻被轉為""

          Console.WriteLine($"Clearing 2 .. Count: { pallets.Length }");
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

        //Step 3 - Call a string helper method on a cleared element(清除陣列內容)
          為了證明 Array.Clear 後被清為null, 另外再呼叫 string helper method, 觸發例外(通常不會這麼作)

          //Sample Code(異常版)
          string[] pallets = {"B14", "A11", "B12", "A13"};
          Console.WriteLine("");

          Console.WriteLine($"before: {pallets[0].ToLower()}"); //"B14"
          Array.Clear(pallets,0,2);
          if (pallets[0] != null) // 避免發生例外, 因為Array.Clear會有array清除清為null, 若在上面使用函式會發生例外.
          {
            Console.WriteLine($"after: {pallets[0].ToLower()}"); // null throw exception
          }
          
          Console.WriteLine($"Clearing 2 ... count: {pallets.Length}");
          foreach(var pallet in pallets)
          {
            Console.WriteLine($"-- {pallet}");
          }

        //Step 4 - Resize the array to add more elements(陣列調整大小, 增加元素)
          
          Array.Resize(ref <name of array>, size);
          
          //重點1: 陣列調整大小時, 在陣列前要有 ref 參考指示詞, 表示傳入位址而非值
          //重點2: 新加入的元素, 放在陣列最後方
          //重點2: 新加入的元素, 預設值為null

          //Sample Code(重點在於: 增加陣列個數)
          string[] pallets = {"B14", "A11", "B12", "A13"};
          Console.WriteLine("");

          Console.WriteLine($"before:{pallets[0]}"); //清除前, "B14"
          Array.Clear(pallets,0,2); //陣列清除內容
          Console.WriteLine($"after:{pallets[0]}"); //清除後, null, 卻被轉為""

          Console.WriteLine($"Clearing 2 .. Count: { pallets.Length }");
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

          //增加陣列個數
          Array.Resize(ref pallets, 6); // KEY IS 陣列調整大小
          Console.WriteLine($"Resizing 6 ... count : {pallets.Length}..");

          pallets[4] = "C01";
          pallets[5] = "C02";
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

        //Step 5 - Resize the array to remove elements(陣列調整大小, 也能減少元素)

          Array.Resize(ref <name of array>, size);
          
          //重點1: 陣列調整大小時, 在陣列前要有 ref 參考指示詞, 表示傳入位址而非值
          //重點2: 減少的元素, 也是從陣列最後方往前刪
          
          //Sample Code(重點在於: 減少陣列個數)
          string[] pallets = {"B14", "A11", "B12", "A13"};
          Console.WriteLine("");

          Console.WriteLine($"before:{pallets[0]}"); //清除前, "B14"
          Array.Clear(pallets,0,2); //陣列清除內容
          Console.WriteLine($"after:{pallets[0]}"); //清除後, null, 卻被轉為""

          Console.WriteLine($"Clearing 2 .. Count: { pallets.Length }");
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

          //增加陣列個數
          Console.WriteLine("");
          Array.Resize(ref pallets, 6); // KEY: 增加陣列個數
          Console.WriteLine($"Resizing 6 ... Count : {pallets.Length}..");

          pallets[4] = "C01";
          pallets[5] = "C02";
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

          //減少陣列個數
          Console.WriteLine("");
          Array.Resize(ref pallets, 3); // KEY: 減少陣列個數
          Console.WriteLine($"Resizing 3 ... Count : {pallets.Length}..");
          foreach(var pallet in pallets)
          {
            Console.WriteLine($" --- {pallet}");
          }

        //Can we remove null elements from an array?(沒有, 無預設函式可以將陣列中的NULL值刪除; 有建議作法, 請見內容..)

        > (如何挑出一個摻雜NULL項目元素的陣列?) 微軟建議作法 <
          1. count the number of non-null elements by iterating through each item 
              and increment a variable (a counter). 
              註: 累計NON-NULL元素個數值.
          2. create a second array that is the size of the counter variable.
              註: 以<累計NON-NULL元素個數值>, 新增第2個陣列
          3. loop through each element in the original array and copy non-null values into the new array.
              註: 依次讀取原始陣列, 將NON-NULL元素 複製到 第2個陣列(新增)

      * Recap(重點回顧)
        1. Array.Clear(array,index,number); //Array.Clear() 類法方法可以array內容, 值清除後空間還在, 變為null.
        2. Array.Resize(ref array, size); 
            //Array.Resize() 類法方法可以調整array項目大小, 從陣列最末端刪除或新增項目
        3. <新的陣列項目>及<被消除的陣列項目> 是 null(空值), 表示它未指向記憶體中的任何值.

      > Unit 4 of 10 - Exercise - Split() and Join() 2021/12/29 常用於接收外部資料, 拆解為更小的資料區塊

        string data type's Array methods 字串資料型態有內建許多的陣列函式, 可以使用
        
        // Step 1 - Use the ToCharArray() to reverse a string (字串轉為"字元陣列", use string.ToCharArray())
          // 將字串反轉為字元陣列
          
          // Sample Code
          string value = "value123";
          char[] aryValue = value.ToCharArray();

        // Step 2 - Reverse, then combine the char array into a new string (直接將"字元陣列"併為字串, new string( char[] ))
          // 先將 "字元陣列" 反轉 Array.Reverse(array);
          // 再將 "字元陣列" 合併為字串 new string( char[] ) <= 將"字元陣列"丟入即可

          // Sample code
          string value = "value123";
          char[] aryValue = value.ToCharArray();
          Console.WriteLine($"..Before reverse");
          foreach (var c in aryValue)
          {
              Console.WriteLine($"{c}");
          }

          Array.Reverse(aryValue); // 先將 "字元陣列" 反轉 Array.Reverse(array);

          Console.WriteLine($"..after reverse");
          foreach (var c in aryValue)
          {
              Console.WriteLine($"{c}");
          }

          string combinedValue = new string(aryValue); //KEY IS HERE // 再將 "字元陣列" 合併為字串 new string( char[] ) <= 將"字元陣列"丟入即可
          Console.WriteLine($"combinedValue: {combinedValue}");

        // Step 3 - Combine all of the chars into a new comma-separated-value string using Join (利用 String.Join(",", 字元陣列)併為以逗號分隔字串)

          //有時候, 我們需要將 "字元陣列" 使用逗號作分隔再合併為字串, 當資料被視為 ASCII text時.
          //這時候, 我們利用 String.Join(",", 字元陣列);

          // Sample code
          string value = "value123";
          char[] aryValue = value.ToCharArray();
          Array.Reverse(aryValue);

          string output = String.Join(",", aryValue); //範例重點
          Console.WriteLine($"Output :{output}");

        // Step 4 - Split the new comma-separated-value string into an array of strings (利用 String.Split(",")將以 "," 分隔的長字串拆解為"短字串陣列")

          // Sample code
          string value = "value123";
          char[] aryValue = value.ToCharArray();
          Array.Reverse(aryValue);

          string output = String.Join(",", aryValue);
          Console.WriteLine($"Output :{output}");
          
          string[] items = output.Split(","); //範例重點(X, error CS1503: Argument 1: cannot convert from 'string' to 'char')
          string[] items = output.Split(','); //範例重點(O)
          Console.WriteLine($"..after Split..");
          foreach (var item in items)
          {
              Console.WriteLine($"{item}");
          }
      
      * Recap(重點回顧)
        1. 有許多內建函式, 可以讓"字串"與"陣列"間轉換
        2. 字串轉陣列, 可使用 string.ToCharArray() 或 string.Split(',') 等函式, 回傳字元陣列
        3. 陣列併為字串, 可使用 String.Join("字串分隔符號(optional)", char[]) 或 new string( char[] ) 等函式, 回傳字串

      > Unit 5 of 10 - First challenge 2021/12/29 (Word reversal challenge)

        Word reversal challenge => 字串反轉挑戰(不太容易, 要想一下) <=
        //Step 1: Delete all of the code in the .NET Editor from the earlier exercise

        //Step 2: Write code in the .NET Editor to reverse each word in a message
          
          string pangram = "The quick brown fox jumps over the lazy dog"; // 挑戰前(反轉前)
          string output = "ehT kciuq nworb xof spmuj revo eht yzal god"; // 挑戰結果(反轉後)

          //我的作法
            string pangram = "The quick brown fox jumps over the lazy dog";
            Console.WriteLine($"Original: = {pangram}");    

            char[] aryLetters = pangram.ToCharArray();  //使用反轉功能,才轉為陣列
            Array.Reverse(aryLetters); 

            string reversedPangram = new string (aryLetters); //方法1: *char[]
            //string reversedPangram = String.Join("",aryLetters); //方法2:string

            Console.WriteLine($"First Phase = {reversedPangram}"); //第1階段: 字元反轉結果(字正確, 但順序不對) => god yzal eht revo spmuj xof nworb kciuq ehT

            string[] aryItems = reversedPangram.Split(' '); //第2階段: 利用空白字串" "分割陣列, 再反轉1次
            Array.Reverse(aryItems);

            /* 測試用(順序是否正確)
            foreach(var item in aryItems)
            {
                Console.WriteLine($"item = {item}, {aryItems.Length}");    
            }
            */

            string result = String.Join(" ", aryItems); //第3階段: 順序正確後, 再合併回字串並顯示.
            Console.WriteLine($"Output: = {result}");    
          
          //官方作法(不錯哦~~很直接, 利用空白字串" "分割陣列, 逐一讀取反轉後, 放入新陣列, 最後再把新陣列合併回字串)
            string pangram = "The quick brown fox jumps over the lazy dog";

            string[] message = pangram.Split(' ');
            string[] newMessage = new string[message.Length];

            for (int i = 0; i < message.Length; i++)
            {
                char[] letters = message[i].ToCharArray();
                Array.Reverse(letters);
                newMessage[i] = new string(letters);
            }

            string result = String.Join(" ", newMessage);
            Console.WriteLine(result);

      > Unit 6 of 10 - First solution
          //官方作法(不錯哦~~很直接, 利用空白字串" "分割陣列, 逐一讀取反轉後, 放入新陣列, 最後再把新陣列合併回字串)
            string pangram = "The quick brown fox jumps over the lazy dog";

            string[] message = pangram.Split(' ');
            string[] newMessage = new string[message.Length];

            for (int i = 0; i < message.Length; i++)
            {
                char[] letters = message[i].ToCharArray();
                Array.Reverse(letters);
                newMessage[i] = new string(letters);
            }

            string result = String.Join(" ", newMessage);
            Console.WriteLine(result);

      > Unit 7 of 10 - Second challenge

        // 挑出B開頭的訂單項目

        string orderStream = "B123,C234,A345,C15,B177,G3003,C235,B179";
        string[] aryOrders = orderStream.Split(',');
        string[] aryOrdersForB = {}; //複製出B訂單用
        Console.WriteLine(aryOrdersForB.Length);
        Array.Sort(aryOrders);
        
        string tempFirstLetter = "B";
        int count = 0;
        foreach(var order in aryOrders)
        {
            //Console.WriteLine(order);
            //Console.WriteLine(order.Substring(0,1));
            
            if (order.Substring(0,1) == tempFirstLetter)
            {
                Console.WriteLine(order);
                count++;

                // Add B Order into aryOrdersForB(自己新增的練習)
                Array.Resize(ref aryOrdersForB, aryOrdersForB.Length+1);  //空間加至最末位
                aryOrdersForB[aryOrdersForB.Length-1] = order; //最末位設值
            }
        }

        Console.WriteLine("> 複製出B訂單 <");
        //Console.WriteLine($"B orders count is {count}");
        foreach(var orderBeginFromB in aryOrdersForB)
        {
            Console.WriteLine(orderBeginFromB);
        }
        Console.WriteLine(aryOrdersForB.Length);

      > Unit 8 of 10 - Second solution

        // 官方作法(這題較容易點)
        string orderStream = "B123,C234,A345,C15,B177,G3003,C235,B179";
        string[] items = orderStream.Split(',');

        foreach (var item in items)
        {
            if (item.StartsWith("B"))
            {
                Console.WriteLine(item);
            }
        }

      > Unit 9 of 10 - Knowledge Check

        1. 可改變Array項目順序的函式 = Array.Sort()
        2. 什麼是NULL? (What is null?) = A value that indicates a variable points to nothing in memory.

      > Unit 10 of 10 - Summary(全重點回顧)

        0. 在這個模組內, 我們利用函式更有效率地使用 "陣列"
        1. Array.Sort(array) and Array.Reverse(array), 調整 "陣列" 順序
        2. Array.Clear(array, index, size), 清除 "陣列" 內容
        3. Array.Resize(ref array, size), "陣列" 項目 新增/刪除
        4. "字串"與"陣列"間轉換
          a. 字串轉陣列, 可使用 string.ToCharArray() 或 string.Split(',') 等函式, 回傳字元陣列
          b. 陣列併為字串, 可使用 String.Join("字串分隔符號(optional)", char[]) 或 new string( char[] ) 等函式, 回傳字串

    Module4: Format alphanumeric data for presentation in C# (2021/12/29~2021/12/30) https://docs.microsoft.com/en-us/learn/modules/csharp-format-strings/

      Use C# to format strings with white space, special characters, padding, and alignment. Give context to numeric data like currency, percentages, and numbers with decimals.
      
      > Unit 1 of 8 - Introduction

        這個單元著重在 "data output" 資料輸出的樣式(例: 對齊, 空格, 貨幣, 小數點位置, )
        例: 我們在市場行銷部門, 著眼全球市場, 須配合客戶當地閱讀習慣, 調整輸出格式.
        這個單元學習到使用 "字串" 和 "數值" 資料解決真實世界的企業問題.

        目標 => 新增 "產品銷售單收據-範本(mockup)"
        目標 => 合併資料, 寄送 "專屬市場訊息" 給客戶.

        學習目標
          1. 合併字串模板(template)與變數, 使用組合式格式
          2. 使用不同的格式指示詞, 適當地顯示 "比率", "貨幣", "數字"
          3. 使用填充函式(padding), 適當地讓字串 "往左", "往右" 靠

      > Unit 2 of 8 - String formatting basics (用法1: string.Format("{0}..{1}", firstValue, secondValue); 用法2(再加上格式): String.Format("{0:C}", currentProfit)/String.Format("{0:P}", currentReturn))

        更簡潔(succinctly)的方式達到 string concatenation(字串連結) 效果.

        What is Composite Formatting? (什麼是組合格式化) <=過時, 相較於 string interpolation(字串插補)=>
        
          //Sample Code
            string first = "Hello";
            string second = "World";
            string result = string.Format("{0} {1}", first, second); //註1:OK
            Console.WriteLine(result);

            string result1 = string.Format("{1}", first, second); //註1:OK
            Console.WriteLine(result1);

            /*
              string resultError = string.Format("{2} {1}", first, second); //註2:ERROR
              Console.WriteLine(resultError);
            */
            
            string resultReverse = string.Format("{1} {0}", first, second); //註3:
            Console.WriteLine(resultReverse);
            
            string resultDuplicateOmit = string.Format("{0} {0} {0}", first, second); //註4
            Console.WriteLine(resultDuplicateOmit);

          //程式碼註解
            註1. 索引值從{0}起算, 但可以不用於template字串格式中, 只用{1}也行.
            註2. "{0} {1}"內的索引值不能超出 "輸入參數"個數, 會丟出例外
                例: "輸入參數"個數 = 2 , 則可用索引值為{0} 或 {1}
            註3: 使用template字串格式時, 索引值擺放位置可依需求變動.
            註4: 使用template字串格式時, 索引值可以 "單次" 或 "多次" 併用.

        What is string interpolation? (什麼是字串插補)
          1. 在字串前加上前綴詞 '$'
          2. 在字串內放入以 '{}' 包裹的參數
          3. 使用上相對直覺且快速

            //Sample Code
              string first = "Hello";
              string second = "World";
              Console.WriteLine($"{first} {second}");
              Console.WriteLine($"{second} {first} ");
              Console.WriteLine($"{first} {first} {first}");

        Formatting currency (格式化貨幣)
          1. "Composite formatting" and "string interpolation" can be used 
              to format values for display given a specific language and culture.
          2. ":C" 為 貨幣格式指示詞
          3. 注意: ":C" 必須放在 '{}' 內, 緊跟在參數後面

            //Sample code
              decimal price = 123.45m;
              int discount = 50;
              Console.WriteLine($"Price: {price:C} (Save {discount:C})");

              // Output: Price: ¤123.45 (Save ¤50.00)
              // ¤ , 是一般的貨幣名稱, 不分區域別

        How the user's country and language impact string formatting (使用者國別及語言如何影響 字串格式)
          1. 字串格式 依賴於電腦的文化設定(culture code)
          2. 文化設定(culture code) 由 5碼所組成 (例:zh-TW, en-US, fr-FR)
          3. 文化設定(culture code) 影響範圍很廣, 有輸入法, 日曆, 字串順序, 日期和數字順序..
          
          4. 注意: 要讓程式碼在所有電腦上運作正常是個大課題, 又稱為 "本地化"/"全球化"

        Formatting numbers (數值格式化)
          1. 將數值格式化的目標在於讓數字易於閱讀 (例:加小數點, 千分位..)
          2. ":N" 為 數值格式指示詞, (預設為小數點下2位).
          3. ":N4" 將 精確度增為4位

            //Sample Code
              decimal measurement = 123456.78912m;
              Console.WriteLine($"measurement: {measurement:N} units");
              Console.WriteLine($"measurement: {measurement:N4} units");

        Formatting percentages (百分比格式化)
          1. 呈現數值比例時使用, 加上小數點, 再加上 % 符號
          2. ":P" 為 百分比格式指示詞, (預設顯示為小數點下2位).
          3. ":P4" 將 小數點精確度增為4位

            //Sample Code
              decimal tax = 0.34567m;
              Console.WriteLine($"Tax rate: {tax:P}");
              // Output => Tax rate: 34.57 %

        * Recap(重點回顧)
          1. You can use composite formatting or string interpolation to format strings.
          2. With "composite formatting", 
              you use a string template containing one or more replacement tokens in the form {0}. You also supply a list of arguments that are matched with the replacement tokens based on their order. 
              Composite formatting works when using string.Format() or Console.WriteLine().
          3. With string interpolation, 
              you use a string template containing the variable names you want replaced surrounded by curly braces. Use the $ directive before the string template to indicate you want the string to be interpolated.
          4. Format currency using a ':C' specifier.
          5. Format numbers using a ':N' specifier. Control the precision (number of values after the decimal point) using a number after the :N like {myNumber:N3}.
          6. Formatting currency and numbers depends on the end user's culture, a five character code that includes the user's country and language (per the settings on their computer).

      > Unit 3 of 8 - Exercise - string interpolation(插值)

        Step 1 - Display the invoice number using string interpolation

          //說明
            1. 我們的秤 單位是 microgram
            2. 我們的價格 單位是 milligram
            2. gram > milligram > microgram
          
          //Step 1 - Display the invoice number using string interpolation
            int invoiceNumber = 1201;
            decimal productMeasurement = 25.4568m;
            decimal subtotal = 2750.00m;
            decimal taxPercentage = .15825m;
            decimal total = 3185.19m;

            Console.WriteLine($"Invoice Number: {invoiceNumber}");

          //Step 2 - Display the product measurement in milligrams

            Console.WriteLine($"Invoice Number: {invoiceNumber}");
            Console.WriteLine($"   Measurement: {productMeasurement:N3} mg"); //給客戶看到毫克 mg 單位

          //Step 3 - Display the subtotal that we'll charge the customer formatted as currency

            Console.WriteLine($"Invoice Number: {invoiceNumber}");
            Console.WriteLine($"   Measurement: {productMeasurement:N3} mg"); //給客戶看到毫克 mg 單位
            Console.WriteLine($"     Sub Total: {subtotal:C} "); //給客戶當地的貨幣單位

          //Step 4 - Display the tax charged on the sale formatted as a percentage

            Console.WriteLine($"Invoice Number: {invoiceNumber}");
            Console.WriteLine($"   Measurement: {productMeasurement:N3} mg"); //給客戶看<毫克 mg 單位>
            Console.WriteLine($"     Sub Total: {subtotal:C} "); //給客戶看<貨幣單位>
            Console.WriteLine($"           Tax: {taxPercentage:P} "); //給客戶看<稅率>

          //Step 5 - Finalize the receipt with the total amount due formatted as currency.

            Console.WriteLine($"Invoice Number: {invoiceNumber}");
            Console.WriteLine($"   Measurement: {productMeasurement:N3} mg"); //給客戶看<毫克 mg 單位>
            Console.WriteLine($"     Sub Total: {subtotal:C} "); //給客戶看<貨幣單位>
            Console.WriteLine($"           Tax: {taxPercentage:P} "); //給客戶看<稅率>
            Console.WriteLine($"     Total Due: {total:C} "); //給客戶看<貨幣單位>

      > Unit 4 of 8 - Exercise - padding(填充) and alignment(對準) (用法: 靠<左>對齊,空白要塞後面 => PadRight(); 靠<右>對齊,空白要塞前面 => PadLeft())

        //Formatting strings by adding whitespace before or after (PadLeft())
        
          //Sample Code
            string input = "Pad this";      
            Console.WriteLine(input.PadLeft(12)); //string.PadLeft(totalWidth)); totalWidth = 加入空白字串後, 總寬度

        //What is an overloaded method?
          函式多載, 函式有不同或額外參數, 讓功能微微地不同.
          例1: input.PadLeft(12); //補空白字串
          例2: input.PadLeft(12,'-'); //補'-'字元

        //Exercise - Working with padded strings
          實際案例: 將新系統轉至舊系統讀取使用(例: 銀行業的外部資料丟入帳務系統)
          註: 這類系統十分要求資料定位在特定行
          1. Column 01-06 PaymentID
          2. Column 07-30 PayeeName 
          3. Column 31-40 PaymentAmount (right-aligned/靠右對齊, 所以空白要補在前面, 用 PadLeft)

          //Step 0 - Add a char line for checking
            Console.WriteLine("1234567890123456789012345678901234567890");

          //Step 1 - Add the OrderId to the output
            string paymentId = "769";
            var formattedLine = paymentId.PadRight(6,'.');
            Console.WriteLine(formattedLine);

          //Step 2 - Add the payee name to the output
            string payeeName = "Mr. Oliver";
            formattedLine += payeeName.PadRight(24,'.'); //注意: 前面已佔6字元, payeeName最多只能放到30字元處
            Console.WriteLine(formattedLine);

          //Step 3 - Add the payment amount to the output
            string paymentAmount = "$5,000.00";
            formattedLine += paymentAmount.PadLeft(10,'.'); //注意: 前面已佔30字元
            Console.WriteLine(formattedLine);

        * Recap(重點回顧)
          1. right-aligned/靠右對齊, 所以空白要補在前面, 用 PadLeft
        
        "字串"資料型態內都有常用函式
          1. 新增空白字串(PadLeft(), PadRight())
          2. 方便字串比較(Trim(), TrimStart(), TrimEnd(), GetHashCode(), Length屬性)
          3. 識別哪些字元在字串內(Contains(), StartsWith(), EndsWith()) 或 存取字串部分內容(Substring())
          4. 改變字串內容(Replace(), Insert(), Remove())
          5. 將字串轉為字元陣列(string.ToCharArray())
          6. 將字串轉為字串陣列(string.Split())

      > Unit 5 of 8 - Challenge

        //我的作法
          string customerName = "Mr. Jones";
          string currentProduct = "Magic Yield";
          int currentShares = 2975000;
          decimal currentReturn = 0.1275m;
          decimal currentProfit = 55000000.0m;

          string newProduct = "Glorious Future";
          decimal newReturn = 0.13125m;
          decimal newProfit = 63000000.0m;

          // forCustomerMessage, 給客戶的訊息
          Console.WriteLine($"Dear {customerName}");
          Console.WriteLine($"As a customer of our {currentProduct} offering we are excited to tell you about a new financial product that would dramatically increase your return.\n");
          Console.WriteLine($"Currently, you own {currentShares:N} shares at a return of {currentReturn:P}.\n");
          Console.WriteLine($"Our new product, {newProduct} offers a return of {newReturn:P}.  Given your current volume, your potential profit would be {newProfit:C}.\n");

          Console.WriteLine("Here's a quick comparison:\n");

          string comparisonMessage = ""; //原來這個變數要用哦..呵呵..

          // 寫入兩行比較訊息作結尾(較喜歡自己的寫法)
          Console.WriteLine($"{currentProduct.PadRight(20)}{currentReturn:P}{"".PadRight(3)}{currentProfit:C}");
          Console.WriteLine($"{newProduct.PadRight(20)}{newReturn:P}{"".PadRight(3)}{newProfit:C}");

          Console.WriteLine(comparisonMessage);
        
        //Output(輸出結果)
          Dear Mr. Jones,
          As a customer of our Magic Yield offering we are excited to tell you about a new financial product that would dramatically increase your return.

          Currently, you own 2,975,000.00 shares at a return of 12.75 %.

          Our new product, Glorious Future offers a return of 13.13 %.  Given your current volume, your potential profit would be ¤63,000,000.00.

          Here's a quick comparison:

          Magic Yield         12.75 %   ¤55,000,000.00      
          Glorious Future     13.13 %   ¤63,000,000.00

      > Unit 6 of 8 - Solution

        //官方作法(其中一種)
          string customerName = "Mr. Jones";

          string currentProduct = "Magic Yield";
          int currentShares = 2975000;
          decimal currentReturn = 0.1275m;
          decimal currentProfit = 55000000.0m;

          string newProduct = "Glorious Future";
          decimal newReturn = 0.13125m;
          decimal newProfit = 63000000.0m;

          Console.WriteLine($"Dear {customerName},");
          Console.WriteLine($"As a customer of our {currentProduct} offering we are excited to tell you about a new financial product that would dramatically increase your return.\n");
          Console.WriteLine($"Currently, you own {currentShares:N} shares at a return of {currentReturn:P}.\n");
          Console.WriteLine($"Our new product, {newProduct} offers a return of {newReturn:P}.  Given your current volume, your potential profit would be {newProfit:C}.\n");

          Console.WriteLine("Here's a quick comparison:\n");

          string comparisonMessage = "";

          comparisonMessage = currentProduct.PadRight(20);
          comparisonMessage += String.Format("{0:P}", currentReturn).PadRight(10);
          comparisonMessage += String.Format("{0:C}", currentProfit).PadRight(20);

          comparisonMessage += "\n";
          comparisonMessage += newProduct.PadRight(20);
          comparisonMessage += String.Format("{0:P}", newReturn).PadRight(10);
          comparisonMessage += String.Format("{0:C}", newProfit).PadRight(20);

          Console.WriteLine(comparisonMessage);

      > Unit 7 of 8 - Knowledge check

        1. Which of the following options would you use to output data in a tab-delimited format (in other words, using a tab between each data element)?
          O, Use \t between the values
          X, Use PadRight or PadLeft or composite formatting.
        
        2. Which format specifier would you use to present a decimal value with the following format to an en-US audience: 12,345.67
          O, {0:N2} or {variableName:N2}
        
        3. Which character must you use as a directive to perform string interpolation?
          O, Console.WriteLine($"...{variableName} ??");

      > Unit 8 of 8 - Summary

        In this module, you will:
          1. Use character escape sequences to add tabs, new lines, and Unicode characters to our strings
          2. Create verbatim string literals, and escape common characters like backslash and double-quotes
          3. Merge templates with variables using composite formatting and string interpolation
          4. Include various format specifiers for percentages, currency, and numbers
      
    Module5: Modify the content of strings using built-in string data type methods in C# (2021/12/30 ~ 2022/01/02)

      Use built in methods to extract, remove, or replace data in strings.
      //此單元的學習目標有:
        1. 識別<字元|字串>在另一個字串內位置(index)
        2. 抓取(extract)部分字串
        3. 移除(remove)部分字串
        4. 以不同值取代(replace)字串內容

      > Unit 1 of 7 - Introduction (2021/12/31)

      > Unit 3 of 7 - Exercise - Use the Remove() and Replace() methods (2022/01/02)

        //string.Remove(startingIndex, removeCharLength); //從字串中移除字元
        //string.Replace(); //從字串中替代字元
        
        //Step 1 - Write code to remove characters in specific locations from a string (移除字串中, 特定位置的字元)

          //範例說明:
            1. 資料來源是舊系統, 長度是固定的
            2. 前5碼(0-4) = customer identification number(ID)
            3. 後20碼(5-24) = customer's name(名稱)
            4. 後6碼(25-30) = customer's latest invoice amount(數量)
            5. 最後3碼 = the number of items ordered on that invoice(品項)

            //Sample Code(先把'名稱'移除, 僅保留訂單資料)
              string data = "12345John Smith          5000  3  ";
              string updatedData = data.Remove(5,20);
              Console.WriteLine(updatedData);

        //Step 2 - Write code to remove characters no matter where they appear in a string (移除字串中, 特定字元, 無論有1組或多組, 利用 Replace(0,''); //使用'空字元'作取代)

          //Sample Code(使用'空字元'作取代)
            string message = "This--is--ex-amp-le--da-ta";
            message = message.Replace("--", " ");
            message = message.Replace("-", "");
            Console.WriteLine(message);

        * Recap(重點回顧)
          1. Remove()函式用法和 Substring()函式類似, 除了Remove()刪除指示字元後並回傳, 而Substring()擷取部分字串後回傳.
          2. Replace()函式 交換(swap) 所有實例, 以取代後的字串.
      
      > Unit 4 of 7 - Challenge

        //挑戰目標: 處理包含HTML段落
          1. 從HTML段落中萃取資料
          2. 取代某些內容 & 移除某些內容
          3. 獲取所需輸出結果

        //Step 1: Delete all of the code in the .NET Editor from the earlier exercise.
          //OK
        
        //Step 2: Write code in the .NET Editor to extract data, replace data, and remove data from an input string.

          //<Input Code>
            const string input = "<div><h2>Widgets &trade;</h2><span>5000</span></div>";

            string quantity = "";
            string output = "";

            // 1. Get quantity from input in <span>..</span> tags
            // 2. Get tempString from input in 
            // 3. replace trade to reg, then output to console

            Console.WriteLine(quantity);
            Console.WriteLine(output);

          //<Output result>
            Quantity: 5000
            Output: <h2>Widgets &reg;</h2><span>5000</span>

      > Unit 5 of 7 - Solution (2022/01/02)

        * 重點: const 指示詞要放在最前面
        
        //我的作法(只用到 IndexOf & Substring & Replace 函式解決)
          const string input = "<div><h2>Widgets &trade;</h2><span>5000</span></div>";

          const string opTagSpan = "<span>";
          const string clTagSpan = "</span>";

          const string opTagDiv = "<div>";
          const string  clTagDiv = "</div>";

          string quantity = "";
          string output = "";

          // 1. Get quantity from input in <span>..</span> tags
          int opIndexSpan = input.IndexOf(opTagSpan);
          opIndexSpan += opTagSpan.Length;
          int clIndexSpan = input.IndexOf(clTagSpan);
          int lengthSpan = clIndexSpan - opIndexSpan;
          quantity = String.Format("Quantity: {0}", input.Substring(opIndexSpan, lengthSpan));

          // 2. Get tempString from input in 
          int opIndexDiv = input.IndexOf(opTagDiv);
          opIndexDiv += opTagDiv.Length;
          int clIndexDiv = input.IndexOf(clTagDiv);
          int lengthDiv = clIndexDiv - opIndexDiv;
          output = String.Format("Output: {0}", input.Substring(opIndexDiv, lengthDiv));

          // 3. replace trade to reg, then output to console
          output = output.Replace("trade","reg");

          Console.WriteLine(quantity);
          Console.WriteLine(output);

        //官方作法(用到 IndexOf & Substring & Remove & Replace 函式解決)
          const string input = "<div class='product'><h2>Widgets &trade;</h2><span>5000</span></div>";

          string quantity = "";
          string output = "";

          // Your work here

          const string spanTag = "<span>";

          // Extract the quantity
          int quantityStart = input.IndexOf(spanTag);
          int quantityEnd = input.IndexOf("</span>");
          quantityStart += spanTag.Length;
          int quantityLength = quantityEnd - quantityStart;
          quantity = input.Substring(quantityStart, quantityLength);

          // Set output to input, replacing the trademark symbol with the registered trademark symbol
          output = input.Replace("&trade;", "&reg;");

          // Remove the opening <div> tag
          int divStart = input.IndexOf("<div");
          int divEnd = input.IndexOf(">");
          int divLength = divEnd - divStart;
          divLength += 1;
          output = output.Remove(divStart, divLength);

          // Remove the closing <div> tag
          int divCloseStart = output.IndexOf("</div");
          int divCloseEnd = output.IndexOf(">", divCloseStart);
          int divCloseLength = divCloseEnd - divCloseStart;
          divCloseLength += 1;
          output = output.Remove(divCloseStart, divCloseLength);

          Console.WriteLine($"Quantity: {quantity}");
          Console.WriteLine($"Output: {output}");

      > Unit 6 of 7 - Knowledge check (2022/01/02)

        1. You want to find the next index of either the - char, the = char, or the _ char. 
          Which method should you use? 想要在多個字元中, 找到下個吻合項目
          IndexOfAny(char[] {'-','=','_'})

        2. What is a constant variable?
          什麼是常數?
          常數 = 一旦它的值被初始化後, 就無法被改變.

      > Unit 7 of 7 - Summary (2022/01/02)

        Our goal was to extract, remove, and replace values in strings. 
        At the outset, we said that often the data we receive has extraneous data or characters that we'll need to avoid or eliminate before we can use the target data.

        Utilizing the IndexOf() method, we could identify the position of a character or string within another string. 
        This was the first building block to using the Substring() method to extract a portion of a string given the starting position 
          and the number of characters to extract (the length). 
          
        It also enabled us to use the Remove() method to eliminate characters from a string given the starting position and the length. 

        We learned of variations like LastIndexOf() method to find the last position of a character of string within another string, 
          and the IndexOfAny() to find the position of any value of a given char array. 
          
        We used the while statement to iterate through a longer string to find and extract all instances of a character or string within a larger source string. 
        Finally, we used the Replace() method to swap all instances of a character or string inside of a larger string.

        While it might be possible to perform these kinds of operations using a char array, 
          iterating through each char to find matches, keeping track of the starting and ending points we wanted to locate, and so on. It would take many more steps to accomplish what these string helper methods can accomplish in a single call.
    
    Module5: Unit 2 of 7 - Exercise - Use the string's IndexOf() and Substring() helper methods (2021/12/31) (重要章節/IndexOf/Substring)

      * 重點回顧/常見用法
        方法1. 先利用 IndexOf() 資料索引位置, 再利用 Substring() 抓出指定索引(含)後的資料(剩餘全部資料)
        方法2. 直接利用 Substring() 多載方法, 設定字元個數(長度) 回傳指定索引(含)後的資料(指定長度)

        string message = "I was born in ILan city";
        int startIndex = 14;
        Substring 常用用法1: message.Substring(startIndex); //Output: ILan city
        Substring 常用用法2: message.Substring(startIndex, 4); //Output: ILan

        //Step 1 - Write code to find an opening '(' and closing ')' parenthesis embedded in a string (定位指定字元位置)
          
          //Sample Code
            string message = "Find what is (inside the parentheses)";

            int openingPosition = message.IndexOf('(');
            int closingPosition = message.IndexOf(')');

            Console.WriteLine(openingPosition); //13, 位置排第14位, 因為從0起算
            Console.WriteLine(closingPosition); //36, 位置排第37位

        //Step 2 - Add code to retrieve the value between two parenthesis characters (錯誤示範版)

          //Sample Code
            string message = "Find what is (inside the parentheses)";

            int openingPosition = message.IndexOf('(');
            int closingPosition = message.IndexOf(')');

            int length = closingPosition - openingPosition;
            Console.WriteLine(message.Substring(openingPosition, length));

            //Output: (inside the parentheses 
            //多了一個前括號

          * 重點回顧(解法): 修改 openingPosition索引至正確位置, 同時得到正確的擷取長度(length)

        //Step 3 - Update the code to modify the starting position of the sub string (正確版, 將openIndex依<符號長度>往後移)

          //Sample Code
            string message = "Find what is (inside the parentheses)";

            int openingPosition = message.IndexOf('(');
            int closingPosition = message.IndexOf(')');

            openingPosition += 1; //'('位置上, 往後移1位才是抓值起始點
            int length = closingPosition - openingPosition;

            Console.WriteLine(message.Substring(openingPosition, length));
          
        * 重點回顧(解法): openingPosition += 1;的原因在於 '(' 寬度為1
            例1: Opening位置要抓的是"<span>", 則會 "+6"
            例2: Opening位置要抓的是"<div>", 則會 "+5"

        * 重點: Avoid magic values(如何避免神奇數值出現, 在實際執行時) 
            > 情境
              1. "<span>" 拼成 "<sapn>", 拼錯
              2. 有可能某天, "<span>" 必須改為 "<div>", 但 "+6" 忘記改為 "+5", 就錯了..

            > 解法
              1. 利用 const 指示詞, 不允許他人修改
              2. 利用 const 指示詞, 變數只須定義1次 & 如果拼錯, 編譯器會抓出來, 不會等到執行階段才出例外

            > 官方建議作法(程式碼範例)
              
              string message = "What is the value <span>between the tags</span>";

              const string openSpan = "<span>";
              const string closeSpan = "</span>";

              int openingPosition = message.IndexOf(openSpan);
              int closingPosition = message.IndexOf(closeSpan);

              openingPosition += openSpan.Length; //記得往後移

              int length = closingPosition - openingPosition;
              Console.WriteLine(message.Substring(openingPosition, length));

        //Step 4 - Write code to retrieve the last occurrence of a sub string (擷取最後1次發生的部分字串)

        * 重點: string.LastIndexOf() 可以抓取指定字元或字串, 最後1次出現的索引位置.

          //message.LastIndexOf('');

          //Sample Code
            string message = "(What if) I am (only interested) int the last (set of parentheses)?";
            int openingPosition = message.LastIndexOf('(');
            openingPosition += 1;
            
            int closingPosition = message.LastIndexOf(')');
            int length = closingPosition - openingPosition;
            Console.WriteLine(message.Substring(openingPosition, length));

        //Step 5 - Update the code example to retrieve any value between one or more sets of parentheses in a string (抓出被指定<符號>包住的所有資料, 無論有1組或多組)

        * 重點: 每組抓完後, 只保留未擷取的部分字串, 再下一輪抓取動作, 直到無法定位<起始符號>, 結束迴圈

          string message = "(What if) there are (more than) one (set of parentheses)?";

          while(true)
          {
            int openingPosition = message.IndexOf('(');
            if (openingPosition == -1) break; //終止條件 = 無下個 '(' 符號

            openingPosition += 1;

            int closingPosition = message.IndexOf(')');
            int length = closingPosition - openingPosition;

            Console.WriteLine(message.Substring(openingPosition, length));

            message = message.Substring(closingPosition + 1 ); //只保留未擷取的部分字串, 在 ')'後面1格, 所以要+1
          }

        //Step 6 - Update the code example to work with different types of symbol sets (使用多組<符號>擷取資料, 不只1種. 稍微困難一點..) (2021/12/31..)

        * 重點1: 範例中也有用到迴圈, 但這次不是用 Substring(startIndex), 而是利用 IndexOf(value, startIndex)的多載函式, 把closingPosition作為下個迴圈的startIndex
        * 重點2: string.IndexOf(char value, int startIndex) / string.IndexOfAny(char[] anyOf, int startIndex)
            已知: 字串中可能的指定<符號>種類, 例如: {'[', '{', '('}
            未知: 不確定 指定<符號>先碰到哪個, (前)<符號>再確認(後)<符號>, 再來擷取(前)***(後)<符號>中間的值
        * 重點3: 因為它要找出對應的(前後)<符號>, 才能擷取<符號>中間的值, 所以它會1個1個字元抓.

          //Sample Code
          string message = string message = "(What if) I have [different symbols] but every {open symbol} needs a [matching closing symbol]?";

          char[] openSymbols = {'[', '{', '('};

          int closingPosition = 0;

          while(true)
          {
            int openingPosition = message.IndexOfAny(openSymbols, closingPosition); //KEY 1
            if (openingPosition == -1) break;

            string currentSymbol = message.Substring(openingPosition, 1); //目前字元
            char matchSymbol = ' '; //後符號字元暫存用

            switch(currentSymbol)
            {
              case "[":
                matchSymbol = ']';
                break;
              case "{":
                matchSymbol = '}';
                break;
              case "(":
                matchSymbol = ')';
                break;
            }

            openingPosition += 1;
            closingPosition = message.IndexOf(matchSymbol, openingPosition); //KEY 2
            int length = closingPosition - openingPosition;

            Console.WriteLine(message.Substring(openingPosition, length));
          }

      * Recap(重點回顧)        
        1. IndexOf() gives us the first position of a character or string inside of another string.
        2. IndexOf() returns -1 if it can't find a match.
        3. Substring() returns just the specified portion of a string, using a starting position and optional length.
        4. LastIndexOf() returns the last position of a character or string inside of another string.
        5. IndexOfAny() returns the first position of an array of char that occurs inside of another string.
        6. There's often more than one way to solve a problem. We used two separate techniques to find all instances of a given character or string.
        7. Avoid hardcoded magic values. Instead, define a const variable. A constant variable's value can't be changed after initialization.

  學習路徑 - 使用 C# 新增邏輯到您的應用程式 (Add logic to your applications with C#) (OK)
      參考資料: https://docs.microsoft.com/en-us/learn/paths/csharp-logic/
      Module1: Evaluate Boolean expressions to make decisions in C# 
        https://docs.microsoft.com/en-us/learn/modules/csharp-evaluate-boolean-expressions/

    Module2: 在 C# 中使用程式碼區塊控制變數範圍和邏輯 (Control variable scope and logic using code blocks in C#)  
        https://docs.microsoft.com/en-us/learn/modules/csharp-code-blocks/

        [學習目標]
        在此課程模組中，您將會：
          了解在程式碼區塊內部和外部宣告和初始化變數的影響。
          當程式碼區塊的主體中只有一行程式碼時，請移除 if 陳述式中的程式碼區塊，以改善可讀性。
          識別程式碼中的命名空間、類別和方法。
          了解將方法移至新類別以及將類別移至新命名空間如何影響程式碼的可見度。
          了解如何使用 using 陳述式，指示編譯器在何處尋找程式碼中所參考的類別。
      
        1. 程式碼區塊和變數範圍

          //OK
          bool flag = true;
          if (flag)
          {
            int value = 10;
            Console.WriteLine($"Inside of the code {value}");
          }

          //Error: 問題在於程式碼區塊中定義的變數只有在該程式碼區塊內部才可存取 (或可見)。 無法在其定義所在之程式碼區塊外部存取變數。
          bool flag = true;
          if(flag)
          {
            int value = 10;
            Console.WriteLine($"Inside of the code {value}");
          }
          Console.WriteLine($"Outside of the code {value}"); //Error

          //OK
          bool flag = true;
          int value = 0;
          if(flag)
          {
            value = 10;
            Console.WriteLine($"Inside of the code {value}");
          }
          Console.WriteLine($"Outside of the code {value}"); //Error   
        2. 程式碼區塊會定義方法(method)、類別(class)和命名空間(namespace)

          using System;

          namespace MyNewApp
          {
            class Program
            {
              static void Main(string[] args) //程式起始點.
              {

              }
            }
          }

          方法(method) 是執行區塊的最小單位.
          類別(class)和命名空間(namespace) 則是用來組織方法.

          「方法」是一個執行單位的程式碼區塊。 換句話說，一旦依方法的名稱呼叫該方法之後，整個方法將會執行，直到：
            執行階段遇到 return 關鍵字，或
            執行階段遇到例外狀況且無法繼續，或
            執行階段成功執行方法中的每一行程式碼

          「類別」是適用於方法、屬性、事件、欄位等成員的容器。 
            在「使用 C# 從 .Net Class Library 呼叫方法」課程模組中，
            您已了解如果您想要呼叫需要狀態 (或執行個體方法) 的方法，
            則必須使用 new 關鍵字來建立類別的執行個體。
            否則，您可以呼叫不具狀態的方法，而不需要先建立類別的執行個體 (或靜態方法)。

          「命名空間」會釐清類別名稱。 
            在「使用 C# 從 .NET 類別庫呼叫方法」課程模組中，
            您已了解 .NET 類別庫中有這麼多類別，而其中可能具有兩個相同名稱的類別。 
            命名空間確保您可以藉由指定命名空間，指示編譯器要使用哪些類別和方法。
            命名空間可以擁有子命名空間. ex. namespace MyNewApp.Data
        3.呼叫相同類別中的方法, 不用加上類別名稱
          using System;
          namespace MyNewApp
          {
            class Program
            {
              static void Main(string[] args)
              {
                string value = "SHEICO learn";
                string reversedValue = Reverse(value); //呼叫相同類別中的方法, 不用加上類別名稱
                Console.WriteLine($"Secret Message:{reversedValue}");
              }

              static string Reverse(string message)
              {
                char[] letters = message.ToCharArray();
                Array.Reverse(letters);
                return new string(letters);
              }
            }
          }
        4.呼叫不同類別中的方法, 必須加上類別名稱
          using System;
          namespace MyNewApp
          {
            class Program
            {
              static void Main(string[] args)
              {
                string value = "SHEICO learn";
                string reversedValue = Utility.Reverse(value); //呼叫外部類別中的方法,  必須加上類別名稱
                Console.WriteLine($"Secret Message:{reversedValue}");
              }
            }

            class Utility
            {
              public static string Reverse(string message) //要加上public,否則無法被外部存取.
              {
                char[] letters = message.ToCharArray();
                Array.Reverse(letters);
                return new string(letters);
              }
            }

          }
        5.using 陳述式可協助編譯器解析命名空間，但所需的按鍵更少

          //using 使用前
          string reversedValue = MyNewApp.Utilities.Utility.Reverse(value);

          //using 使用後
          using MyNewApp.Utilities;
          string reversedValue = Utility.Reverse(value);

    重點回顧:
    <= 程式碼區塊會定義較高層級的結構，例如，命名空間、類別和方法。
    <= 就像程式碼區塊會影響較低層級結構 (例如，決策和反覆運算陳述式) 內部所定義的變數可見度，程式碼區塊也會影響類別之間的方法以及命名空間之間的類別的可見度。
    <= using 陳述式可以加入至程式碼檔案，指示編譯器在何處尋找類別的參考。
      6. 移除 if 陳述式中不必要的程式碼區塊
        //Version1
        bool flag = true;
        if(flag)
        {
          Console.WriteLine(flag);
        }

        //Version2
        bool flag = true;
        if(flag) Console.WriteLine(flag);
    重點回顧:
    <= 如果您意識到程式碼區塊中只有一行程式碼，即可移除大括弧和空白字元。
    <= 只有在可讓 {程式碼更容易閱讀} 時，才能移除程式碼區塊, 才能移除換行字元。

      7. 程式挑戰

        //有問題的CODE
        int[] numbers = { 4, 8, 15, 16, 23, 42 };
        foreach (int number in numbers)
        {
            int total;
            total += number;
            if (number == 42)
            {
              bool found = true;
            }
        }
        if (found) 
        {
            Console.WriteLine("Set contains 42");
        }
        Console.WriteLine($"Total: {total}");

        //修正後的CODE
        int[] numbers = { 4, 8, 15, 16, 23, 42 };
        int total = 0;
        bool found = false;
        foreach (int number in numbers)
        {
            total += number;
            if (number == 42)
            {
              found = true;
            }
        }
        if (found) 
        {
            Console.WriteLine("Set contains 42");
        }
        Console.WriteLine($"Total: {total}");

    Module3: 在 C# 中使用 switch-case 建立程式碼流程分支 (Branch the flow of code using the switch-case construct in C#)
      https://docs.microsoft.com/en-us/learn/modules/csharp-switch-case/

      string type = "";
      switch (product[0])
      {
        case "01":
          type = "Sweet shirt";
          break;
        default;
          type = "other";
          break;
      }

      知識檢定:
      1.關於 switch-case 建構的下列陳述何者正確？
        (O)單一 switch 區段可以有多個案例標籤。
        (X)switch 建構必須包括預設 switch 區段。 <= default: 不一定要有
        (X)兩個案例標籤可以有相同的比對模式。 <= 比較項目必須都不同.
        (X)案例標籤結尾的冒號是選擇性的。 <= case 標籤結尾的 : 是必要的.
      
      2. break 的用途是:
        (O)告知執行階段停止評估 switch 建構中的其他case.
    重點回顧:
    1. if-elseif-else 決策陳述式、
    2. switch-case 決策陳述式與
    3. 條件運算子 (?:) 提供三種方式來建立程式碼邏輯分支。 

    Module4: Iterate through a code block using for statement in C# 
      https://docs.microsoft.com/en-us/learn/modules/csharp-for/

      //基本的 for 陳述式
      for(int i=0; i<10; i++)
      {
        Console.WriteLine(i); //順序
      }

      for(int i=10; i>=0; i--)
      {
        Console.WriteLine(i); //反序
      }

      for(int i=0; i<10; i+=3)
      {
        Console.WriteLine(i); //順序 +3
      }

      //想要中斷反覆執行, break;
      for(int i=0; i<10; i++)
      {
        Console.WriteLine(i); //順序
        if(i==7) break;
      }

      //foreach 可快速查詢陣列元素值, 但 for 可以更自由的操作
      //foreach 只能順向跑, for 可以逆向跑.
      string[] names = {"Alex","John","Tim","Oliver"};
      for(int i = names.Length - 1; i>=0; i--)
      {
        Console.WriteLine(names[i]);
      }

      //foreach 無法更新陣列元素值, 但 for 就可以
      string[] names = {"Alex","John","Tim","Oliver"};
      foreach(var name in names)
      {
        if (name == "John") name = "Judy"; //(4,27): error CS1656: Cannot assign to 'name' because it is a 'foreach iteration variable'
      }

      string[] names = {"Alex","John","Tim","Oliver"};
      for(int i = names.Length - 1; i>=0; i--)
      {
        if (names[i] == "John") names[i] = "Judy";
      }
      foreach(var name in names)
      {
        Console.WriteLine(name);
      }
    重點回顧:說明 for 用法
    1. for 可以順序, 反序跑執行; foreach 只能順序執行.
    2. for 可以跳著執行, 例: 每次跳3個值; foreach 只能逐一列舉
    3. for 可以同時取值並改變內容; foreach 只能取值, 若改變內容會抛例外
    4. for 預期知道反覆執行次數
    5. for 可以讓你控制想要如何逐一查看陣列中的每個項目時使用
    6. for 可以讓你藉由改變括弧內下列三個條件來控制反覆項目機制的每個層面：初始設定式、條件和迭代器。
    7. for(初始設定式; 條件; 迭代器), 這3個區段都是 optional.

    Module5: Add looping logic to your code using the do-while and while statements in C# 
      https://docs.microsoft.com/en-us/learn/modules/csharp-do-while/
    重點回顧:說明 while or do-while 用法
    1. do-while 最後面記得加上 ';'.
    2. do-while 至少會執行1次, 若符合 while(條件) 時, 再繼續執行.
    3. do-while 常作為等待使用者預期結果的反覆作法.
    4. while 比較像 '閘道', 若符合 while(條件) 時, 則執行程式碼.
    5. continue 會略過後續程式碼, 跳至下個反覆; break 會終止所有反覆, 離開此迴圈.

官方技術文件(測試) - <UnitTest> in .Net Core by MSTest, NUnit, XUnit
  資料來源: https://docs.microsoft.com/zh-tw/dotnet/core/testing/

  單元測試
    單元測試應該只測試開發人員控制項內的程式碼。
    它們並不會測試基礎結構的考慮。(例: 與資料庫、檔案系統和網路資源的互動)
  
  整合測試
    整合測試與單元測試不同之處在于，它會演練兩個或多個軟體元件的功能，也稱為「整合」。
    這些測試會在較廣泛的受測系統上運作，而單元測試則著重于個別的元件。
    整合測試通常會包含基礎結構考慮。(例: 與資料庫、檔案系統和網路資源的互動)
    (註: 整合測試 = 單元測試 + 多個元件間的功能測試 + 基礎結構合併測試)
  
  負載測試
    負載測試的目標是要判斷系統是否可以處理指定的負載，
    (例如: 使用應用程式的並行使用者數目，以及應用程式處理互動佳的能力。) 
    如需有關 web 應用程式負載測試的詳細資訊，
    請參閱ASP.NET Core 負載/壓力測試。
    (https://docs.microsoft.com/zh-tw/aspnet/core/test/load-tests?view=aspnetcore-6.0)

  測試中常用的術語: Fake, Mock, Stub.
    Fake - 假
      A fake is a generic term that can be used to describe either a stub or a mock object. 
        (1個fack是個一般用語, 可用來描述 '1個stub' 或 '1個mock' 物件.)
      Whether it's a stub or a mock depends on the context in which it's used. 
        (至於它是 '1個stub' 或 '1個mock' 物件, 須依據使用它的上下文[語境=context]而定)
      So in other words, a fake can be a stub or a mock.
        (換句話說，1個fack 可以是 '1個stub' 或 '1個mock')

    Mock - 模擬
      A mock object is a fake object in the system that decides whether or not a unit test has passed or failed. 
        (模擬[mock]物件是系統中的假[fake]物件，用於確定單元測試是否已通過或失敗。)
      A mock starts out as a Fake until it's asserted against.
        (模擬[mock]會視從假[fake]開始, 直到它被斷言.[評估成功或失敗])

    Stub - 存根(可替換項目)
      A stub is a controllable replacement for an existing dependency (or collaborator) in the system. 
        (存根是系統中現有依賴項（或協作者）的可控替代項。)
      By using a stub, you can test your code without dealing with the dependency directly. 
        (通過使用存根[stub]，您可以測試代碼，而無需直接處理依賴項。)
      By default, a stub starts out as a fake.
        (預設, 存根[stub]開始時是假的[fake])

    程式碼範例:

      =TestCase1(怪怪的)=
        // Arrange
        var mockOrder = new MockOrder();
        var purchase = new Purchase(mockOrder);

        // Act
        purchase.ValidateOrders();

        // Assert
        Assert.IsTrue(purchase.CanBeShipped);

      =TestCase2(好一些)=
        // Arrange
        var stubOrder = new FakeOrder(); //這裡作調整
        var purchase = new Purchase(stubOrder);

        // Act
        purchase.ValidateOrders();

        // Assert
        Assert.IsTrue(purchase.CanBeShipped);

      =TestCase3(如果要把 Fake視為 Mock時)=
        // Arrange
        var mockOrder = new FakeOrder(); //這裡作調整
        var purchase = new Purchase(mockOrder);

        // Act
        purchase.ValidateOrders();

        // Assert
        Assert.IsTrue(purchase.Validated);



    (註: 總結是利用 Mock<Interface> 作為 '測試專案' 與 '被測試專案' 間的接縫[Seam], 
         其中的<Interface>就是Stub,
         設計「測試案例」時, 就能依需求抽換值, 且不受到 '被測試專案' 系統環境的影響.
         實作案例 => 詳:  # 虛擬靜態參考 (Stub static references) # 段落.)

    (註: 要記得的是 => Mocks 就像是 Stubs, 但斷言[Assert]的對象是 'Mock物件', 而非 'Stub物件')

  .NET Core 和 .NET Standard 的 '單元測試' 最佳做法
    資料來源: https://docs.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-best-practices

    # 為何要執行 '單元測試'？
      1. 執行功能測試的時間較少
      2. 對於迴歸的保護(讓您確信新的程式碼不會中斷現有的功能。)
      3. 可執行的文件(如果您有一套妥善命名的單元測試，每個測試都應該能清楚說明給定輸入的預期輸出。
          TestMethod的命名很重要, 讓人對測試的目的一目瞭然
          此外，應該還能確認它實際上可正常運作。)
      4. 低耦合程式碼(使用程式更容易測試)
    
    # 良好單元測試的特性
      1. <快速>
          具有數千個單元測試的成熟專案並不罕見(十分常見..)。 
          單元測試應只需要極少的時間執行(ms)。
    
      2. <隔離>
          單元測試是獨立的，可以單獨執行，
          並且對所有外部因素 (例如檔案系統或資料庫) 沒有任何相依性。
    
      3. <可重複執行>
          執行單元測試應該與其結果一致，
          亦即，如果您未變更回合之間的任何項目，會一律傳回相同的結果。
    
      4. <自我檢查>
          測試應該能夠自行偵測到通過或失敗，不需要任何人為互動。
  
      5. <及時>
          相較於所測試的程式碼，單元測試不應耗費不成比例的冗長時間來撰寫。 相較於撰寫程式碼，
          如果您發現測試程式碼花費大量時間，請考慮使用更易於測試的設計。

    # 最佳作法
      1. 請試著不要在撰寫單元測試時於基礎結構導入相依性。 
         這些測試會使測試變慢和脆弱，而且應該保留給整合測試。 
      
      2. 您可以遵循 Explicit Dependencies Principle (明確相依性準則) 的內容，
         並使用 Dependency Injection (相依性注入)，來在應用程式中避免這些相依性。 
      
      3. 可以將 '單元測試' 保留在 '個別專案' 中，和 '整合測試' 分開。 
         這可確保您的'單元測試專案'不具有基礎結構封裝的參考或相依性。

    # 測試方法的<命名>原則 or 慣例 or 標準.
      1. 所測試的方法名稱。(Method)
      2. 用以測試的案例。(Case)
      3. 叫用案例時的預期行為。(Expected Behavior)

      !!重點: 為什麼要遵循 "測試方法的<命名>原則" 的原因在於 => 
          a. 測試不只要確定您的程式碼能夠運作，還會提供文件。 
          b. 只要查看這套單元測試，
          c. 您應能推斷程式碼的行為，甚至無需查看程式碼本身。

    # 測試方法的<實作>原則.
      1. Arrange(排列), 建立並設定所需物件
      2. Act(行動), 執行物件內方法
      3. Assert(判定), 判定結果是否如預期

      !!重點: 為什麼要遵循 "測試方法的<實作>原則" 的原因在於 => 
          a. 可清楚地分隔出 Arrange / Act / Assert
          b. 使得 Act / Assert 程式碼相互摻雜機率降低.
          c. <可讀性> 是撰寫測試時最重要的要素之一.

    # 測試方法的<測試值輸入>原則.
      1. 撰寫最單純/最簡單的測試

      !!重點: 為什麼要遵循 "測試方法的<測試值輸入>原則" 的原因在於 => 
          a. 重點在於驗證行為正確性的驗證.
          b. 測試對程式碼基底的未來變更變得更具復原性.
          c. 更接近測試行為而不是實作.
          d. 如果測試包含的資訊比通過測試所需還要多，
             更有可能會將錯誤帶進測試中，且會讓測試的意圖較不清楚。
          e. 撰寫測試時，您想要專注于行為。

    # 測試方法內, 避免 <魔術字串> (註: 讓人無法立即得知意圖的值?)
      1. 相較於在生產環境程式碼中為變數命名，在單元測試中為變數命名的重要性有過之而無不及。 
      2. 單元測試不應該包含魔術字串。(註: 如果必須存在, 請用<有意義常數>取代.)

      !!重點: 為什麼測試方法內, 要避免 <魔術字串> 的原因在於 => 
        a. 避免測試的讀者為了找出使該值變得特殊的原因, 而需要檢查生產環境程式碼。
        b. 明確地顯示您想要「證明」的項目，而不是嘗試「完成」的項目。
        c. <魔術字串> 可能會對測試的讀者造成混淆.
        d. 如果 <魔術字串> 必須存在, 請用<有意義命名的常數>取代.

    # 測試方法內, 避免 <使用邏輯> (註: 更容易出錯, 讓測試結果不再令人信任)
      1. 請避免使用手動字串串連和邏輯條件，例如 if、while、for、switch 等等
      
      !!重點: 為什麼測試方法內, 避免 <使用邏輯> 的原因在於 => 
        a. 在測試內帶進 Bug 的機率更低。
        b. 著重最終結果，而不是實作詳細資料。
        c. 如果 <多種存件> 必須存在, 請 <分割為多個測試案例> 取代.

    # 請慣用Helper方法, 完成測試方法執行前的設定(Setup), 與執行後的終止(TearDown)工作.
      !!重點: 原因在於 =>  
        1. 讀取測試時混淆較少，因為在每個測試內都可以看見所有的程式碼。
          (註: 它最後通常會導致測試過大且難以閱讀)
        2. 對於給定的測試，設定太多或太少的機率更低。
        3. 測試之間的共用狀態比較少，這會在兩者之間建立不必要的相依性。
        4. 自 2.x 版開始，xUnit 已移除 Setup 及 TearDown 這兩者
    
    # 測試方法內, 避免 <使用多個Act> (註: 不然失敗時, 不知道哪個造成的.)

      !!重點1: 如果有必要 <使用多個Act>, 請以下列方式解決:
        1. 為每個動作建立個別測試。
        2. 使用參數化測試。(詳閱: Better - Example - <使用邏輯>)

      !!重點2: 避免 <使用多個Act> 的原因在於:
        1. 當測試失敗時，並不清楚哪個動作失敗。
        2. 確保測試只會著重單一案例。
        3. 為您提供測試失敗原因的全貌, 會讓人摸不著頭緒。

    # 測試方法內, 應該關注的是呼叫私用方法的 <公用方法最終結果>, 而非直接測試私有方法(private)

      !!重點: 關注的是呼叫私用方法的 <公用方法最終結果> 的原因在於:
        1. 私用方法是實作詳細資料
        2. 私用方法永遠不會單獨存在
        3. 在某個時間點, 將有一個公用方法(public)呼叫私用方法(private)作為其實作的一部份.
            因此, 應該關注的是呼叫私用方法的 <公用方法最終結果>, 而非直接測試私有方法(private).
        4. 私用方法傳回預期結果，並不表示最終呼叫私用方法的系統會正確地使用結果。

    # 虛擬靜態參考 (Stub static references) # 
    (註1: 引用 seam[接縫] 概念, 利用 interface[介面]作為接縫, 正式環境程式碼依賴 interface[介面])
    (註2: 測試呼叫方法時, 就能 Stub 任何值進入.)

      1. 單元測試的其中一個原則是「測試時, 必須擁有系統的完全主控權」.
        但這在營運環境中呼叫靜態參考(例: DateTime.Now)時, 會無法符合上述原則 或 會有問題發生的.

        問題: 
         a. 如果在週二執行, 則 測試案例2-成功, 測試案例1-失敗.
         b. 如果非週二執行, 則 測試案例2-失敗, 測試案例1-成功.

          //待測方法(須重構的CODE)
          public int GetDiscountedPrice(int price)
          {
            if(DateTime.Now.DayOfWeek == DayOfWeek.Tuesday)
            {
              return price / 2; //星期二有半價優惠
            }
            else
            {
              return price;
            }
          }

          //測試案例1: 非週二, 原價
          public void GetDiscountedPrice_NotTuesday_GetFullPrice()
          {
            var priceCalculator = new PriceCalculator();

            var actual = priceCalculator.GetDiscountedPrice(2);

            Assert.Equals(2, actual); 
          }

          //測試案例2: 週二, 半價
          public void GetDiscountedPrice_Tuesday_GetHalfPrice()
          {
            var priceCalculator = new PriceCalculator();

            var actual = priceCalculator.GetDiscountedPrice(2);

            Assert.Equals(1, actual);
          }

        解法: 引用 seam[接縫] 概念, 
          利用 interface[介面]作為接縫, 而正式環境程式碼depend on that interface
          (註: 它有引入MOCK的概念進來, 由測試案例擁有完全主控權, 指定今天是週二就是週二, 不會因測試執行時間不同而改變)

            //新增介面, For Seam Interface
            public interface IDateTimeProvider
            {
              DayOfWeek DayOfWeek();
            }
            //待測試方法.
            public int GetDiscountedPrice(int price, IDateTimeProvider dateTimeProvider)
            {
              if(dateTimeProvider.DayOfWeek == DayOfWeek.Tuesday)
              {
                return price / 2;
              }
              else
              {
                return price;
              }
            }

            //測試案例1: 非週二原價
            public void GetDiscountedPrice_NotTuesday_GetFullPrice()
            {
              // Arrange
              var priceCalculator = new PriceCalculator();
              var dateTimeProvider = new Mock<IDateTimeProvider>();
              //固定為非週二
              dateTimeProvider.Setup(dtp => dtp.DayOfWeek()).Returns(DayOfWeek.Monday); 

              // Act
              var actual = priceCalculator.GetDiscountedPrice(2, dateTimeProvider);

              // Assert
              Assert.Equals(2, actual);
            }

            //測試案例2: 週二半價
            public void GetDiscountedPrice_Tuesday_GetHalfPrice()
            {
              // Arrange
              var priceCalculator = new PriceCalculator();
              var dateTimeProvider = new Mock<IDateTimeProvider>();
              //固定為週二
              dateTimeProvider.Setup(dtp => dtp.DayOfWeek()).Returns(DayOfWeek.Tuesday); 

              // Act
              var actual = priceCalculator.GetDiscountedPrice(2, dateTimeProvider);

              // Assert
              Assert.Equals(1, actual);
            }

TODO: 延伸閱讀: # How YOU can Learn Mock testing in .NET Core and C# with Moq(MOCK)
    完整的ASP.NET Core API Test Example
    https://softchris.github.io/pages/dotnet-moq.html#introduction

    <實際測試案例 - 應該關注的是呼叫私用方法的 <公用方法最終結果>, 而非直接測試私有方法(private)>

      public string ParseLogLine(string input) //公用方法
      {
        var santizedInput = TrimInput(input);
        return santizedInput
      }

      private string TrimInput(string input) //私用方法
      {
        return input.Trim();
      }

      //Better - TestCase
      public void ParseLogLine_StartsAndEndsWithWhiteSpace_RetrunsTrimmedResult()
      {
        // Arrange
        var parse = new Parse();

        //Act
        var actual = parse.ParseLogLine(" a ");
        
        //Assert
        Assert.Equals("a", actual);
      }


      Q: 這時, 要對 ParseLogLine() or TrimInput() 哪個方法寫測試案例呢??
      A: 實際的測試應該針對公眾對應方法 ParseLogLine 執行，因為這才是您最應關注的項目。

    <NotGood - 範例 - 避免 <使用多個Act>>    
      [Fact]
      public void Add_EmptyEntries_ShouldBeThreatedAsZero()
      {
        // Act
        var actual1 = stringCalculator.Add("");
        var actual2 = stringCalculator.Add(",");

        // Assert
        Assert.Equal(0, actual1);
        Assert.Equal(0, actual2);
      }
    <Better - 範例 - 避免 <使用多個Act>>    
      [Theory]
      [InlineData("",0)]
      [InlineData(",",0)]
      public void Add_EmptyEntries_ShouldBeThreatedAsZero(string input, string expected)
      {
        // Arrange
        var stringCalculator = new StringCalculator();

        // Act
        var actual = stringCalculator.Add(input);

        // Assert
        Assert.Equal(expected, actual);
        
      }
    <NotGood - 範例 - 慣用Helper方法, 完成測試方法執行前的設定(Setup), 與執行後的終止(TearDown)工作>  
      private readonly StringCalculator stringCalculator;
      public StringCalculatorTests() //Setup
      {
        stringCalculator = new StringCalculator();
      }
      ...許多的測試案例(都有用到StringCalculator)...
      [Fact]
      public void Add_TwoNumbers_ReturnsSumOfNumbers()
      {
        var result = stringBuilder("0,1");

        Assert.Equal(1, result);
      }
    !! 這種寫法漂亮許多..
    <Better - 範例 - 慣用Helper方法, 完成測試方法執行前的設定(Setup), 與執行後的終止(TearDown)工作>
      public void Add_TwoNumbers_ReturnsSumOfNumbers()
      {
        var stringCalculator = CreateDefaultStringCalculator();

        var actual = stringCalculator.Add("1,0");

        Assert.Equal(1, actual);
      }
      ...許多的測試案例(都有用到StringCalculator)...
      public StringCalculator CreateDefaultStringCalculator()
      {
        return new StringCalculator();
      }
    <NotGood - 範例 - 命名原則>
      [Fact]
      public void Test_Single() //違反命名原則
      {
        var stringCalculator = new StringCalculator();

        var actual = stringCalculator.Add("0");

        Assert.Equal(0, actual); //(預期值, 實際值)
      }
    <Better - 範例 - 命名原則>
      [Fact]
      public void Add_SingleNumber_ReturnsSameNumber() //原則: 方法_案例_預期結果
      {
        //Arrange
        var stringCalculator = new StringCalculator();

        //Act
        var actual = stringCalculator.Add("0");

        //Assert
        Assert.Equal(0, actual); //(預期值, 實際值)
      }
    <NotGood - 範例 - 測試實作方式>
      [Fact]
      public void Add_EmptyString_ReturnsZero() //命名OK
      {
        //Arrange
        var stringCalculator = new StringBuilder();

        //Action

        //Assert
        Assert.Equals(0, stringCalculator("")); //Not Good
      }
    <Better - 範例 - 測試實作方式>
      [Fact]
      public void Add_EmptyString_ReturnsZero() //命名OK
      {
        //Arrange
        var stringCalculator = new StringBuilder();

        //Action
        var actual = stringCalculator("");

        //Assert
        Assert.Equals(0, actual); //Better
      }
    <NotGood - 範例 - 測試值輸入>
      [Fact]
      public void Add_SingleNumber_ReturnsSameNumber()
      {
        //Arrange
        var stringCalculator = new StringCalculator();

        //Act
        var actual = stringCalculator("42"); //這裡放"42"很怪, 為什麼不放 15, -9, 876...

        //Assert
        Assert.Equals(42, actual);
      }
    <Better - 範例 - 測試值輸入>
      [Fact]
      public void Add_SingleNumber_ReturnsSameNumber()
      {
        //Arrange
        var stringCalculator = new StringCalculator();

        //Act
        var actual = stringCalculator("0"); //Better, more pure

        //Assert
        Assert.Equals(0, actual);
      }
    <NotGood - Example - MagicNumber>
      [fact]
      public void Add_BigNumber_ThrowsException()
      {
        var stringCalculator = new StringCalculator();

        Action actual = () => stringCalculator("1001"); //Magic Number is here.

        Assert.Throws<OverflowException>(actual);
      }
    <Better - Example - MagicNumber>
      [fact]
      public void Add_BigNumber_ThrowsException()
      {
        var stringCalculator = new StringCalculator();
        const string MAXIMUM_RESULT = "1001";

        Action actual = () => stringCalculator(MAXIMUM_RESULT); //Better Solution.

        Assert.Throws<OverflowException>(actual);
      }
    <NotGood - Example - <使用邏輯>>
      [Fact]
      public void Add_MultipleNumbers_ReturnsCorrectResults()
      {
        var stringCalculator = new StringCalculator();
        int expected = 0;
        var testCases = new[]
          {"0,0,0"
          ,"0,1,2"
          ,"1,2,3"};

        foreach(var test in testCases)
        {
          Assert.Equal(expected, stringCalculator.Add(test));
          expected += 3;
        }
      }
    <Better - Example - <使用邏輯>>
        [Theory]
        [InlineData("0,0,0",0)]
        [InlineData("0,1,2",3)]
        [InlineData("1,2,3",6)]
        public void Add_MultipleNumbers_ReturnsCorrectResults(string input, int expected)
        {
          var stringCalculator = new StringCalculator();

          var actual = stringCalculator.Add(input);

          Assert.Equal(expected, actual);
        }

  使用 dotnet test 與 xUnit 為 .NET Core 中的 C# 進行單元測試 (簡易專案的作法)
    資料來源: https://docs.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-with-dotnet-test

  使用 .NET CLI 組織和測試專案 by xUnit (複雜專案的作法 - 利用資料夾組織檔案.)
    資料來源: https://docs.microsoft.com/zh-tw/dotnet/core/tutorials/testing-with-cli

  使用 MSTest 和 .NET 進行 C# 單元測試
    資料來源: https://docs.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-with-mstest

  執行選擇性單元測試

  排序單元測試

  單元測試程式碼涵蓋範圍

  單元測試發佈的輸出

TODO: C# OOP - 寫的淺顯易懂, 超棒的..
  資料來源: https://www.w3schools.com/cs/cs_oop.php

TODO: Learn 模組 - C# testing in Visual Studio by MSTest
  資料來源: https://docs.microsoft.com/en-us/learn/modules/visual-studio-test-tools/

TODO: Learn 模組 - Null safety in C#
  資料來源: https://docs.microsoft.com/en-us/learn/modules/csharp-null-safety/

TODO: 官方技術文件 - <LINQ>
  資料來源: https://docs.microsoft.com/zh-tw/samples/dotnet/try-samples/101-linq-samples/

TODO: 官方技術文件 - Lambda 運算式 (C# 參考)
  資料來源: https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/lambda-expressions

TODO: Learn 學習路徑 - Introduction to version control with Git
  資料來源: https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/

/*== C# 實作經驗 ==*/

  <如何存取DC控制域, 完成使用者認證>
    1.DC(Domain Controller)只能作使用者認證用, 無法作授權.
    2.檔案系統的存取權限, 則可以指定至使用者或群組上, 經DC認證有效 & 具檔案系統的存取權限的使用者則可正常存取該資料夾及內部檔案.

    //程式範例//
      using System;
      using System.Collections.Generic;
      using System.Linq;
      using System.Text;
      using System.Threading.Tasks;
      using System.DirectoryServices; //要記得加入參考

      namespace Demo_UseDCInfo
      {
          class Utility
          {
              static public bool AuthenticateUser(string LDAP_Path, string userName, string passWord , ref string Errmsg)
              {
                  Errmsg = "";

                  DirectoryEntry entry = new DirectoryEntry(LDAP_Path, userName, passWord);
                  entry.AuthenticationType = AuthenticationTypes.Secure;
                  try
                  {
                      DirectorySearcher search = new DirectorySearcher(entry);
                      search.Filter = "(SAMAccountName=" + userName + ")";

                      var properties = search.PropertiesToLoad;
                      SearchResult result = search.FindOne();

                      if (result == null)
                          return false;
                      else
                          return true;
                  }
                  catch (Exception ex)
                  {
                      Errmsg = ex.Message;
                      return false;
                  }
                  finally
                  {
                      entry.Close();
                  }
              }
          }

          class Program
          {
              static void Main(string[] args)
              {
                  string userName = "";
                  string userPassword = "";
                  string errMessage = "";

                  for ( ; ; )
                  {
                      Console.Write("輸入帳號: ");
                      userName = Console.ReadLine();

                      Console.Write("輸入帳號: ");
                      userPassword = Console.ReadLine();

                      if (Utility.AuthenticateUser("LDAP://DC=sheico,DC=com,DC=tw", userName, userPassword, ref errMessage))
                      {
                          Console.WriteLine("認證成功 !!");
                          
                          break;
                      }
                      else
                      {
                          Console.WriteLine(String.Format("認證失敗: {0}", errMessage));
                      }
                  }

                  //Example1
                  //string path = "LDAP://DC=sheico,DC=com,DC=tw";
                  ////string strAccountId = "SNADOMAIN\\oliver_cheng"; //不能用.
                  //string strAccountId = "oliver_cheng"; //可以用.
                  //string strPassword = "680916";
                  //bool bSucceeded;
                  //string strError;

                  //DirectoryEntry adsEntry = new DirectoryEntry(path, strAccountId, strPassword);

                  //DirectorySearcher adsSearcher = new DirectorySearcher(adsEntry);
                  //adsSearcher.Filter = "(sAMAccountName=" + strAccountId + ")";

                  //try
                  //{
                  //    SearchResult adsSearchResult = adsSearcher.FindOne();
                  //    bSucceeded = true;
                  //    strError = "User has been authenticated by Active Directory.";
                  //    adsEntry.Close();
                  //}
                  //catch (Exception ex)
                  //{
                  //    bSucceeded = false;
                  //    strError = ex.Message;
                  //    adsEntry.Close();
                  //}

                  //if (bSucceeded)
                  //{
                  //    Console.WriteLine("Great Success");
                  //}
                  //else
                  //{
                  //    Console.WriteLine("Great Fail");
                  //}
                  //Console.ReadLine();

              }
          }
      }

  <HOW TO: 排除開發環境無法連接SAP資料庫的異常 (OK, 2022/02/25) <= 加入 SAP Connector 2.0 dll 參考即可解決 =>>
    Question: "工單 BOM Component 長文查詢 & 裁剪單列印或轉PDF程式 & 成品模具油墨維護&整印單列印程式" 連接 SAP資料庫出現異常時, 該如何處置??
    Error Message : 其他資訊: 無法載入檔案或組件 'SAP.Connector, Version=2.0.0.0, Culture=neutral, PublicKeyToken=50436dca5c7f7d23' 或其相依性的其中之一。 系統找不到指定的檔案。
    Solution: 
      1. 先裝, NCo3017_Net40_x64.exe, 路徑: \\dataserver\software\05.授權軟體\01_SAPClient\SAP .NET Connector
      2. 再將, "SAP.Connector.dll" & "SAP.Connector.Rfc.dll" 兩支DLL加入 路徑: "C:\Program Files\SAP\SAP_DotNetConnector3_Net40_x64"
      3. 最後, "SAP.Connector.dll" & "SAP.Connector.Rfc.dll" 加入專案參考即可.

  <HOW TO: 排除開發環境無法開啟CrystalReport的異常 (OK, 2022/03/01) <= 安裝最新版CrystalReport 開發工具 & Runtime + 重新加入CrystalReport報表至專案 + 加入SAPRFC.dll參考 即可解決 =>>
    Question(2022/03/01): 可以查詢SAP資料庫, 但是產生CrystalReport時出現異常 
      說明: 秋雪使用的版本安裝的是 "英文版", 我裝的是 "中文版" => 重新安裝, 無效
      過程: 本身CrystalReport環境可正常瀏覽, 唯讀無法使用秋雪的程式.
      開發環境: 選單一樣是亂碼, 根本無法進行維護.

    Error Message: 無法將類型 COM 物件轉換為介面類型
    Solution: 
      1. 重新安裝CrystalReport 開發工具 & Runtime (安裝新版本CrystalReport, 不用安裝舊版)
      2. 開發環境專案內, 複製 "DLL檔 & 現存報表" ("SAPRFC.dll" & "*.RPT") 至暫存區 to (路徑: C:\Program Files\SAP\SAP_DotNetConnector3_Net40_x64)
      3. 開發環境專案內, 移除 "DLL參考 & 現存報表".
      4. 開發環境專案內, 重新加入 "現存報表"
      5. 加入"現存報表"後, 檢查開發專案參考是否自動加入 "DLL參考" ("CrystalDecisions.CrystalReports.Engine.dll" & "CrystalDecisions.ReportSource.dll" & "CrystalDecisions.Shared.dll" 三個DLL參考.)
      6. 開發環境專案內, 再加入參考 "SAPRFC.dll" 參考 from (路徑: C:\Program Files\SAP\SAP_DotNetConnector3_Net40_x64)
      
  <HOW TO:排除開發環境無法開啟圖片路徑的異常 (OK, 2022/03/03) <= 確認存放圖片路徑的存取權限 =>>
    Question:
      CrystalReport能預覽 & PDF能下載, 但報表內沒有圖片資料
    
    Error Message: 
      類型 'System.UnauthorizedAccessException' 的未處理例外狀況發生於 mscorlib.dll
      其他資訊: 拒絕存取路徑 '\\prd\SAP\MaterialPhoto\01_Garment\03_PRD689'。

    Solution:
      異常處理方式: 無圖片檔存取權限路徑, 暫時調整為讀取本機路徑, 標註須切換正式|測試環境(DEBUG)的路徑變數
      註(VIP): LogoPicPath & MarkPicPath & strImgPath, 請確認前述3個路徑變數(最重要的路徑變數)是否有存取權限, 以及路徑設定是否正確.

  <Question: 有關於"Windows Form程式存取檔案OR目錄的權限", 為什麼在本機執行程式存取外部路徑時, 會出現 "無路徑存取權限"異常, 但正式環境執行卻能成功呢?>
    
    Answer: 原因在於 "是否擁有存取檔案OR目錄的權限" 依 "執行程式的使用者而定", 
      若該使用者 "無 存取檔案OR目錄的權限", 儘管程式內的路徑正確, 依舊會因權限不足而擋住. 系統會知道程式執行者是誰~~

  /*== 程式碼內, 如何切換測試(DEBUG) OR 正式環境(RELEASE), 注意 DEBUG 區分大小寫, 而且IDE會依據目前組態變換顏色 ==*/
      
    作法1(OK): 使用前置指示詞, 切換 DEBUG Mode OR RELEASE Mode.
      https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives#conditional-compilation 
      
      前置指示詞(preprocessor-directives)
      * Conditional compilation (條件式編譯 by symbols)
        You use four preprocessor directives to control conditional compilation:
        #if: Opens a conditional compilation, where code is compiled only if the specified symbol is defined.
        #elif: Closes the preceding conditional compilation and opens a new conditional compilation based on if the specified symbol is defined.
        #else: Closes the preceding conditional compilation and opens a new conditional compilation if the previous specified symbol isn't defined.
        #endif: Closes the preceding conditional compilation.

      * Defining symbols (自行定義)
        You use the following two preprocessor directives to define or undefine symbols for conditional compilation:
        #define: Define a symbol.
        #undef: Undefine a symbol.

        預先定義的 symbols : "DEBUG", "TRACE", "Target Frameworks" SDK版本
        1. "DEBUG" 會依建置專案用的組態, 自動切換.

          #if DEBUG
            Console.WriteLine("Debug Mode");
          #else 
            Console.WriteLine("Release Mode");
          #endif

        * ConditionalAttribute => using System.Diagnostics;
          + 告訴編譯器, 是否要指 函式 或 類別 編譯進去. 
          + 有定義 symbol, 則編譯

          /*編譯進去*/
            #define TEST

            Method_Test(); //編譯進去

            [Conditional("TEST")]
            public static void Method_Test()
            {
                Console.WriteLine("EXEC TEST");
            }

          /*不編譯進去*/
            #define TEST1

            Method_Test(); //不編譯進去

            [Conditional("TEST")]
            public static void Method_Test()
            {
                Console.WriteLine("EXEC TEST");
            }

      * Defining regions (定義區域範圍)
        
        #region Method

          [Conditional("TEST")]
          public static void Method_Test()
          {
              Console.WriteLine("EXEC TEST");
          }

        #endregion

      https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-6.0 偵錯

    作法2(NO): 使用不同組態切換 => 測試(DEBUG)組態 OR 正式環境(RELEASE)組態 => 找不到切換方式作法, 決定不採用. 另外, 連接字串也會有洩漏風險.

  /*== 程式碼內, 發行(Deploy) & 建置(Build) ==*/
    1. 發行(Deploy), 要安裝
    2. 建置(Build), 不用安裝

  /*== 程式狀態(變更) ==*/
    0. Event執行成功, 才會變更狀態
    0. if currentMode != newMode, 才須異動畫面.

    1. Clear (Click Reset Button)
      Enable Input Object, Set Input Value = "", DataGridView = new DataTable();
    
    2. Edit (Click GridView by <dataGridView1_SelectionChanged> function)
      Disable all Input Object, Leave Grade Object Enabled for Editing.

    3. Query (Click Query Button)
      a. HasData
          dataGridView1_SelectionChanged => Edit => ChangeMode(Query) => Enable Input Object => Query
      b. NoData
          ChangeMode(Query) => Enable Input Object => Query

  /* C# 連接字串 的多種型態  */
    Persist Security Info=true;Integrated Security=true;Initial Catalog=NT101;Server=OliverCheng-W10\SQLEXPRESS
    
    Persist Security Info=true;User ID=sa;Password=680916;Initial Catalog=NT101;Server=OliverCheng-W10\SQLEXPRESS
    Persist Security Info=true;User ID=sa;Password=680916;Initial Catalog=Test;Server=OliverCheng-W10\SQLEXPRESS

    註1: Windows 驗證的優先順序高於 SQL Server 登入。如果您同時指定 Integrated Security=true 以及使用者名稱和密碼，系統就會忽略使用者名稱和密碼，而使用 Windows 驗證。
    註2: Persist Security Info=true; 擁有較高的機密性.

  /* C# 連接字串放在App.setting & 取值  */
    <configuration>
        <appSettings>
          <add key="connectionString" value="Data Source=OliverCheng-W10\SQLEXPRESS;Initial Catalog=Test;Persist Security Info=True;User ID=sa;Password=680916"/>
        </appSettings>
    </configuration>

    //註: 專案加入參考 [System.configuration] & 程式碼 [using System.Configuration] 後, 才能使用 ConfigurationManager
    string connString = ConfigurationManager.AppSettings["connectionString"];

  /*== UI強化(快捷鍵) ==
    Button的 Text值加上 &D => 可用 Alt+D 直接執行, 例: 查詢(&D) => 查詢(D)

  /* masked text 用的mask
    000.00
    .  

  <中文字串 & 英文字串長度大不同>
    1. 中文字串 = 2 bytes
    2. 英文字串 = 1 byte

    3. // 中文字元與英文字元視為等長, 若是DB欄位開CHAR(10), 寫入10個英文字元 OK, 寫入10個中文字元 Error(報錯: 發生資料截斷) //
       strLength = value.ToString().Length; //value = "中文" => 回傳2碼長
    
    4. //檢查長度(若夾雜中文字, 要用UNICODE轉換後再抓, 則是byte 長度) //
       using System.Text;
       Encoding unicode = Encoding.Unicode;
       strLength = unicode.GetByteCount(value.ToString()); //value = "中文" => 回傳4碼長

    5. char(1), 可放入1個 "英文字元" byte長的值(1)
       nchar(1), 可放入1個 "萬用字元" bytes長的值(2)

  <文字處理的較佳作法, 中文字串 & 英文字串 判斷>
    問題: 檢查長度(若夾雜中文字, String.Length中文字元與英文字元視為等長, 若是DB欄位開CHAR(10), 寫入10個英文字元OK, )
    
    前提: DB欄位用CHAR(10)開立, 非NCHAR(10), 1個中文字會佔2個CHAR, 所以CHAR(10)只能放5個中文字元, 寫入10個中文字元會報錯(發生資料截斷)
    
    Best Solution : using System.Text.RegularExpressions; isEnglishChar = Regex.IsMatch(s.ToString(), @"\p{IsBasicLatin}+");  
    //利用REGEX檢查, 是較佳作法 
    //pattern: 請參考 https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-classes-in-regular-expressions#supported-named-blocks

    Second Solution: int defaultLength = Encoding.Default.GetByteCount(value.ToString()); <=如有系統設定有問題, 不確定性高=>

    =========================================
    using System.Text.RegularExpressions;

    bool isEnglishChar = true;
    foreach (var s in value.ToString())
    {
        isEnglishChar = Regex.IsMatch(s.ToString(), @"\p{IsBasicLatin}+"); //是否為英文字元, 如果是視為1個CHAR, 否則為2個CHAR
        if (isEnglishChar)
        {
            strLength += 1;
        }
        else
        {
            strLength += 2;
        }
    }

  <數值格式處理, C# & DB>

    //<VIP>: 專指字元長度 {0,2:F2}, 表示整數長度2位, 小數長度2位, 和DB定義不同
       string strTestValue = String.Format("{0,2:F2}", testValue);  

    //DB
      Decimal(4,2), 表示總長度為4, 可存入2位小數 = 儲存上限 99.99
      Error : 150 無法存入
      OK: 12.99 可存入

  <資料庫參數長度限制, C# & DB>
    insertParas.Add(new SqlParameter("@FOAM", SqlDbType.Char, 1, "FOAM")); //若為CHAR OR STRING, Size 指的是字元長度 = 1
    insertParas.Add(new SqlParameter("@THICK_START", SqlDbType.Decimal, 3, "THICK_START")); //若為DECMIAL, Size 指的是Precision = 3 , Decimal(Precision, Scale)
    insertParas.Add(new SqlParameter("@THICK_END", SqlDbType.Decimal, 3, "THICK_END"));
    insertParas.Add(new SqlParameter("@LENGTH", SqlDbType.Int, 4, "LENGTH")); //若為INT指的是BINARY長度, 或不用指定, SqlSever 預設的INT Schema Size is Precision = 10, Scale= 0

    資料來源: https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlparameter.size?view=dotnet-plat-ext-6.0
   
  <SQL get OUTPUT parameter from SQL Server>
    1. 新增USP
      USE [NT101]
      GO
      /****** Object:  StoredProcedure [dbo].[TEST]    Script Date: 2022/1/26 上午 08:22:58 ******/
      SET ANSI_NULLS ON
      GO
      SET QUOTED_IDENTIFIER ON
      GO
      -- =============================================
      -- Author:		<Author,,Name>
      -- Create date: <Create Date,,>
      -- Description:	<Description,,>
      -- EXEC NT101.dbo.[usp_FOAM_Select] '', '111','','20'
      -- EXEC NT101.dbo.[usp_FOAM_Select] @FOAM = '' ,@E_SFABRIC = ''
      -- =============================================
      alter PROCEDURE [dbo].[usp_FOAM_Select]
        @FOAM CHAR(1) = ''
        , @E_SFABRIC CHAR(3) = ''
        , @I_SFABRIC CHAR(3) = ''
        , @THICK_MAX DECIMAL(2,1) = 0
        , @RowCount int OUTPUT
      AS
      BEGIN
        -- SET NOCOUNT ON added to prevent extra result sets from
        -- interfering with SELECT statements.
        SET NOCOUNT ON;

        --Query Result
      SELECT [FOAM]
            ,[E_SFABRIC]
            ,[I_SFABRIC]
            ,[THICK]
            ,[STREC_START_P]
            ,[STREC_END_P]
            ,[HORIZ_START_P]
            ,[HORIZ_END_P]
        FROM [NT101].[dbo].[NT101_FOAM]
        WHERE 1 = 1 
                      AND  ( '' = @FOAM          OR FOAM LIKE '%' +  @FOAM + '%' )  
                      AND  ( '' = @E_SFABRIC  OR E_SFABRIC LIKE '%' + @E_SFABRIC + '%' )
                      AND  ( '' = @I_SFABRIC   OR I_SFABRIC LIKE '%' + @I_SFABRIC + '%' )
                      AND  ( 0 = @THICK_MAX or THICK <= @THICK_MAX );

        --RowCount
        SELECT @RowCount = @@ROWCOUNT;

      END;
    2. 執行USP, 取出OUTPUT參數
      DECLARE @COUNT INT;
      EXEC NT101.dbo.usp_FOAM_Select  @RowCount = @COUNT OUTPUT;
      SELECT @COUNT AS 'Total Rows';

  <EventHandler - 如何在程式碼內建立 函式 與 事件 間的關聯性>
    
    this.Load += new EventHandler(Form1_Load); //Form1_Load 為事件處理常式.

    this.dvINSPEC.DataBindingComplete += dvINSPEC_DataBindingComplete;

  <SqlDataAdapter + SelectCommand + 查詢欄位 = 必須寫成 "預儲程序(StoredProcedure)", 不然遇到 <數值>查詢會掛掉>
    1. 最佳方式: 預儲程序(完整範例)

      <C# 程式碼>
        class QueryString
        {
            private string columnName;
            public string ColumnName
            {
                get { return columnName; }
                set { columnName = value; }
            }

            private object columnValue;
            public object ColumnValue
            {
                get { return columnValue; }
                set { columnValue = value; }
            }
        }
        
        private void GetData(List<QueryString> queryStrings, QueryType queryType)
        {
            try
            {
                // Populate a new data table and bind it to the BindingSource. (@@重點在這裡@@)
                using (SqlConnection connection = new SqlConnection(connString))
                {
                    
                    // Get Data from DB
                    dataAdapter = new SqlDataAdapter();
                    dataAdapter.SelectCommand = new SqlCommand(uspSelectSQLCommand, connection);
                    dataAdapter.SelectCommand.CommandType = CommandType.StoredProcedure;

                    // Create parameters for Query
                    string[] strQueryString = new string[queryStrings.Count];
                    for (int i = 0; i < queryStrings.Count; i++)
                    {
                        SqlParameter parameter = dataAdapter.SelectCommand.Parameters.AddWithValue("@" + queryStrings[i].ColumnName, queryStrings[i].ColumnValue);   
                        parameter.Direction = ParameterDirection.Input;
                    }
                
                    // Create a parameter for the ReturnValue.
                    SqlParameter parameterRowCount = dataAdapter.SelectCommand.Parameters.AddWithValue("@RowCount", 0);
                    parameterRowCount.Direction = ParameterDirection.InputOutput;

                    //Clear DataTable Content
                    dtDisplay = new DataTable();
                    dsResult = new DataSet();

                    //Fill Latest Data into DataTable
                    dataAdapter.Fill(dsResult, Convert.ToInt32(CurrentPage  * RowsInOnePage), RowsInOnePage, mainTableName);
                    dtDisplay = dsResult.Tables[0].Copy();

                    //更新 "總查詢筆數"
                    if (queryType == QueryType.ButtonClick)
                    {
                        //Get Output data from Stored Procedure
                        this.TotalRows = (Int32)dataAdapter.SelectCommand.Parameters["@RowCount"].Value;
                    }
                    else
                    {
                        //換頁時, 每次只回傳該頁筆數, 故不更新 "總查詢筆數"
                    }
                    
                    //(For DataError Event) 抓DB PK鍵 & 設定為 DataTable PK鍵, UI端違反資料攔住.
                    
                    //取得 "IndexColumns" 集合===========================
                    connection.Open();
                    DataTable dtSchema = connection.GetSchema("IndexColumns"); 
                    DataRow[] rows = dtSchema.Select(String.Format("table_name  = '{0}' and index_name like '{1}' ", mainTableName, "PK%"));
                    List<string> listPKColumnsName = new List<string>();
                    foreach (DataRow row in rows)
                    {
                        listPKColumnsName.Add(row["column_name"].ToString());
                    }

                    //加入PK限制條件==================================
                    List<DataColumn> PKColumns = new List<DataColumn>(); 
                    if (listPKColumnsName.Count > 0)
                    {
                        foreach (string colName in listPKColumnsName)
                        {
                            PKColumns.Add(dtDisplay.Columns[colName]);
                        }
                        dtDisplay.PrimaryKey = PKColumns.ToArray();
                    }

                    //(For CellValidating Event) 抓取 TableSchema Constraint(限制條件), 例: 必填, 長度...============
                    dsTableSchema = new DataSet(); //須清空內容, 再塞1次, 否則FillSchema會把新的TableSchema塞在後面
                    dataAdapter.FillSchema(dsTableSchema, SchemaType.Mapped); //存放 TableSchema 用, 作為輸入前資料檢查依據

                }

                //查詢資料放入中介層, 準備繫結至 DataGridView ================================
                bindingSource1.DataSource = dtDisplay; //Notice: 三個類別檔共用bindingSource1為中介層, 把查詢結果的資料&限制條件一起複製給bindingSource1(Error, 不然會出現 "找不到資料表 0" ERROR)                

            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message.ToString(), "例外訊息(資料查詢-GetData)", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }    

      <SQL 程式碼>

        USE [NT101]
        GO
        /****** Object:  StoredProcedure [dbo].[usp_FOAM_Select]    Script Date: 2022/1/27 上午 11:44:03 ******/
        SET ANSI_NULLS ON
        GO
        SET QUOTED_IDENTIFIER ON
        GO
        -- =============================================
        -- Author:		<Author,,Name>
        -- Create date: <Create Date,,>
        -- Description:	<Description,,>
        -- EXEC NT101.dbo.[usp_FOAM_Select] '', '111','','20'
        -- EXEC NT101.dbo.[usp_FOAM_Select] @FOAM = '' ,@E_SFABRIC = ''
        -- =============================================
        ALTER PROCEDURE [dbo].[usp_FOAM_Select]
          @FOAM CHAR(1) = ''
          , @E_SFABRIC CHAR(3) = ''
          , @I_SFABRIC CHAR(3) = ''
          , @THICK DECIMAL(2,1) = 0
          , @RowCount int OUTPUT
        AS
        BEGIN
          -- SET NOCOUNT ON added to prevent extra result sets from
          -- interfering with SELECT statements.
          SET NOCOUNT ON;

          --Query Result
        SELECT [FOAM]
              ,[E_SFABRIC]
              ,[I_SFABRIC]
              ,[THICK]
              ,[STREC_START_P]
              ,[STREC_END_P]
              ,[HORIZ_START_P]
              ,[HORIZ_END_P]
          FROM [NT101].[dbo].[NT101_FOAM]
          WHERE 1 = 1 
                        AND  ( '' = @FOAM          OR FOAM LIKE '%' +  @FOAM + '%' )  
                        AND  ( '' = @E_SFABRIC  OR E_SFABRIC LIKE '%' + @E_SFABRIC + '%' )
                        AND  ( '' = @I_SFABRIC   OR I_SFABRIC LIKE '%' + @I_SFABRIC + '%' )
                        AND  ( 0 = @THICK or THICK <= @THICK );

          --RowCount
          SELECT @RowCount = @@ROWCOUNT;

          END;
    2. 較差方式: 參數化查詢
      <SqlDataAdapter, 預儲程序 or 的問題, 終於解決了.>
      // LIKE 用的 % 要用 '' 包起來, 詳下例
      string cmdText = "SELECT [THICKTYPE_NO] as '厚度類別代碼(2碼)', [THICKTYPE_NAME] as '厚度類別名稱(10碼)' " +
                      "FROM NT101_THICKTYPE " +
                      " WHERE 1 = 1  " +
                      " AND  THICKTYPE_NO LIKE '%' + @NO + '%' " + 
                      " AND  THICKTYPE_NAME LIKE '%' + @NAME + '%' ";

      queryNo = this.txtID.Text.ToString().Trim();
      queryName = this.txtName.Text.ToString().Trim();

      dataAdapter.SelectCommand = new SqlCommand(cmdText, new SqlConnection(connString));
      dataAdapter.SelectCommand.Parameters.AddWithValue("@NO", queryNo);
      dataAdapter.SelectCommand.Parameters.AddWithValue("@NAME", queryName);

      
      //SQL Server参数化SQL语句中的like和in查询的语法(C#)
        原理解释：
        SQL参数化查询，其实是可以在SQL的IDE（Microsoft SQL Server Management Studio）中测试的。
        打开Microsoft SQL Server Management Studio，新建查询，在窗口中写入以下命令：

        -- Like参数化查询命令
        DECLARE @word VARCHAR(255);
        SET @word='123';
        SELECT * from users where user_name like '%'+@word+'%' or mobile like '%'+@word+'%';
        这就是Like参数化查询的等效命令；

        同理，以下是In参数话查询命令：
        DECLARE @user_ids VARCHAR(255);
        SET @user_ids='1001,1002,1006';
        exec('select * from users where user_id in ('+@user_ids+')');

        文章参考：
        http://blog.csdn.net/changhong009/article/details/7396005

  <SqlDataAdapter, 換頁功能>
    * 不要全部載入所有資料, 而是只載入首頁前10筆
    * 利用 pagingAdapter.Fill(pagingDS, scrollVal, 5, "authors_table");
        //scrollVal = 0 註: 起始記錄之以零起始的索引
        //maxRecords = 5 註: 每次翻頁筆數
    * 加上翻頁功能 [ |< 移到最前頁, < 移到上一頁, {0} 目前頁數, /{0} 總頁數, > 移到下一頁, >| 移到最後頁 ]

  <SqlDataAdapter + Fill + Update - 預儲程序 - 更新時會偵測資料列的資料版本, 作為異動時抓值依據>
    public static SqlDataAdapter CreateCustomerAdapter(
        SqlConnection connection)
    {
        SqlDataAdapter adapter = new SqlDataAdapter();

        // Create the SelectCommand.
        SqlCommand command = new SqlCommand("SELECT * FROM Customers " +
            "WHERE Country = @Country AND City = @City", connection);

        // Add the parameters for the SelectCommand.
        command.Parameters.Add("@Country", SqlDbType.NVarChar, 15);
        command.Parameters.Add("@City", SqlDbType.NVarChar, 15);

        adapter.SelectCommand = command;

        // Create the InsertCommand.
        command = new SqlCommand(
            "INSERT INTO Customers (CustomerID, CompanyName) " +
            "VALUES (@CustomerID, @CompanyName)", connection);

        // Add the parameters for the InsertCommand.
        command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
        command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");

        adapter.InsertCommand = command;

        // Create the UpdateCommand.
        command = new SqlCommand(
            "UPDATE Customers SET CustomerID = @CustomerID, CompanyName = @CompanyName " +
            "WHERE CustomerID = @oldCustomerID", connection);

        // Add the parameters for the UpdateCommand.
        command.Parameters.Add("@CustomerID", SqlDbType.NChar, 5, "CustomerID");
        command.Parameters.Add("@CompanyName", SqlDbType.NVarChar, 40, "CompanyName");
        SqlParameter parameter = command.Parameters.Add(
            "@oldCustomerID", SqlDbType.NChar, 5, "CustomerID");
        parameter.SourceVersion = DataRowVersion.Original;

        adapter.UpdateCommand = command;

        // Create the DeleteCommand.
        command = new SqlCommand(
            "DELETE FROM Customers WHERE CustomerID = @CustomerID", connection);

        // Add the parameters for the DeleteCommand.
        parameter = command.Parameters.Add(
            "@CustomerID", SqlDbType.NChar, 5, "CustomerID");
        parameter.SourceVersion = DataRowVersion.Original;

        adapter.DeleteCommand = command;

        return adapter;
    }

  <SqlDataAdapter + Fill + INSERT - 預儲程序 StoredProcedure - Return RowCount更新筆數回傳- 設定參數方式>
    using System;
    using System.Data;
    using System.Data.SqlClient;

    class Program
    {
        static void Main()
        {
            string connectionString = GetConnectionString();
            ReturnIdentity(connectionString);
            // Console.ReadLine();
        }

        private static void ReturnIdentity(string connectionString)
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                // Create a SqlDataAdapter based on a SELECT query.
                SqlDataAdapter adapter = new SqlDataAdapter("SELECT CategoryID, CategoryName FROM dbo.Categories", connection);

                // Create a SqlCommand to execute the stored procedure.
                adapter.InsertCommand = new SqlCommand("InsertCategory", connection);
                adapter.InsertCommand.CommandType = CommandType.StoredProcedure;

                // Create a parameter for the ReturnValue.
                SqlParameter parameter = adapter.InsertCommand.Parameters.Add("@RowCount", SqlDbType.Int);
                parameter.Direction = ParameterDirection.ReturnValue;

                // Create an input parameter for the CategoryName.
                // You do not need to specify direction for input parameters.
                adapter.InsertCommand.Parameters.Add("@CategoryName", SqlDbType.NChar, 15, "CategoryName");

                // Create an output parameter for the new identity value.
                parameter = adapter.InsertCommand.Parameters.Add("@Identity", SqlDbType.Int, 0, "CategoryID");
                parameter.Direction = ParameterDirection.Output;

                // Create a DataTable and fill it.
                DataTable categories = new DataTable();
                adapter.Fill(categories);

                // Add a new row.
                DataRow categoryRow = categories.NewRow();
                categoryRow["CategoryName"] = "New Beverages";
                categories.Rows.Add(categoryRow);

                // Update the database.
                adapter.Update(categories);

                // Retrieve the ReturnValue.
                Int32 rowCount = (Int32)adapter.InsertCommand.Parameters["@RowCount"].Value;

                Console.WriteLine("ReturnValue: {0}", rowCount.ToString());
                Console.WriteLine("All Rows:");
                foreach (DataRow row in categories.Rows)
                {
                        Console.WriteLine("  {0}: {1}", row[0], row[1]);
                }
            }
        }

        static private string GetConnectionString()
        {
            // To avoid storing the connection string in your code,
            // you can retrieve it from a configuration file.
            return "Data Source=(local);Initial Catalog=Northwind;Integrated Security=true";
        }
    }

  <SqlDataAdapter + Update 觸發的事件>
    當程式碼使用 dataAdapter.Update(dataTable) 後, 的執行順序為:
      1. The values in the DataRow are moved to the parameter values (DataRow的值會移至參數值)
      2. The "OnRowUpdating" event is raised. (觸發事件: 資料更新中)
      3. The command executes. (執行資料庫更新)
      4. If the command is set to "FirstReturnedRecord"
         , then the first returned result is placed in the DataRow (常用於更新後, 回傳的 IDENTITY值)
      5. If the command is set to "OutputParameters"
         , they are placed in the DataRow (常用於更新後, 回傳的 IDENTITY值)
      6. The "OnRowUpdated" event is raised. (觸發事件: 資料更新完成)

  <DataPropertyName & DataMember間的差異>
    DataGridViewColumn.DataPropertyName Property <= 指的是資料列對應資料來源的欄位名稱, 只須使用在 AutoGenerateColumns = false, 自動產生欄位時. 因為AutoGenerateColumns = true, 系統會自動對應.
    DataGridView.DataMember Property <= 用於DataGridView資料來源中, 有多個列表(array[])或資料表(DataSet)時, 須指定 其中一個 TableName.

  <如何 讓 datagridview 出現捲軸>
    <VIP>如果 DataGridView.Dock = Fill 時 & 而且DataGridView放在容器內, 此設定會失效, 捲軸出不來
    1. DataGridView.Dock = None;
    2. DataGridView.ScrollBars = Both;

  <How to add DataGridViewComboBoxColumn manually 如何手動新增欄位>
    DataGridViewComboBoxColumn colTHICKTYPE_NO = new DataGridViewComboBoxColumn();
    colTHICKTYPE_NO.HeaderText = "厚度類別代碼";
    colTHICKTYPE_NO.DataSource = GetComboBoxData(ComboBoxType.THICKTYPE);
    colTHICKTYPE_NO.DataPropertyName = "THICKTYPE_NO";
    colTHICKTYPE_NO.DisplayMember = "THICKTYPE_NO";
    colTHICKTYPE_NO.ValueMember = "THICKTYPE_NO";
    //colTHICKTYPE_NO.Items.Add("請選擇"); //<VIP>有指定DataSource, 則無法再手動新增項目
    colTHICKTYPE_NO.DefaultCellStyle.NullValue = "請選擇"; //未選擇顯示項目
    dvFABRIC.Columns.Add(colTHICKTYPE_NO);

  <How to let all Columns fill the size of DataGridView 如何讓手動新增欄位, 自動塞滿 DataGridView 寬度>
    gridView.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.Fill;

  <手動新增欄位 DataGridView 超實用範例>
    https://docs.microsoft.com/en-us/dotnet/desktop/winforms/controls/column-fill-mode-in-the-windows-forms-datagridview-control?view=netframeworkdesktop-4.8

    using System;
    using System.ComponentModel;
    using System.Reflection;
    using System.Windows.Forms;

    public class Form1 : Form
    {
        [STAThread]
        public static void Main()
        {
            Application.Run(new Form1());
        }

        private DataGridView dataGridView1 = new DataGridView();

        public Form1()
        {
            dataGridView1.Dock = DockStyle.Fill;
            Controls.Add(dataGridView1);
            InitializeDataGridView();
            Width *= 2;
            Text = "Column Fill-Mode Demo";
        }

        private void InitializeDataGridView()
        {
            // Add columns to the DataGridView, binding them to the
            // specified DataGridViewColumn properties.
            AddReadOnlyColumn("HeaderText", "Column");
            AddColumn("AutoSizeMode");
            AddColumn("FillWeight");
            AddColumn("MinimumWidth");
            AddColumn("Width");

            // Bind the DataGridView to its own Columns collection.
            dataGridView1.AutoGenerateColumns = false;
            dataGridView1.DataSource = dataGridView1.Columns;

            // Configure the DataGridView so that users can manually change
            // only the column widths, which are set to fill mode.
            dataGridView1.AllowUserToAddRows = false;
            dataGridView1.AllowUserToDeleteRows = false;
            dataGridView1.AllowUserToResizeRows = false;
            dataGridView1.RowHeadersWidthSizeMode =
                DataGridViewRowHeadersWidthSizeMode.DisableResizing;
            dataGridView1.ColumnHeadersHeightSizeMode =
                DataGridViewColumnHeadersHeightSizeMode.DisableResizing;
            
            // @@ 這裡會塞滿DataGridView寬度 @@
            dataGridView1.AutoSizeColumnsMode =
                DataGridViewAutoSizeColumnsMode.Fill;

            // Configure the top left header cell as a reset button.
            dataGridView1.TopLeftHeaderCell.Value = "reset";
            dataGridView1.TopLeftHeaderCell.Style.ForeColor =
                System.Drawing.Color.Blue;

            // Add handlers to DataGridView events.
            dataGridView1.CellClick +=
                new DataGridViewCellEventHandler(dataGridView1_CellClick);
            dataGridView1.ColumnWidthChanged += new
                DataGridViewColumnEventHandler(dataGridView1_ColumnWidthChanged);
            dataGridView1.CurrentCellDirtyStateChanged +=
                new EventHandler(dataGridView1_CurrentCellDirtyStateChanged);
            dataGridView1.DataError +=
                new DataGridViewDataErrorEventHandler(dataGridView1_DataError);
            dataGridView1.CellEndEdit +=
                new DataGridViewCellEventHandler(dataGridView1_CellEndEdit);
            dataGridView1.CellValueChanged +=
                new DataGridViewCellEventHandler(dataGridView1_CellValueChanged);
        }

        private void AddReadOnlyColumn(String dataPropertyName, String columnName)
        {
            AddColumn(typeof(DataGridViewColumn), dataPropertyName, true,
                columnName);
        }

        private void AddColumn(String dataPropertyName)
        {
            AddColumn(typeof(DataGridViewColumn), dataPropertyName, false,
                dataPropertyName);
        }

        // Adds a column to the DataGridView control, binding it to specified
        // property of the specified type and optionally making it read-only.
        private void AddColumn(
            Type type,
            String dataPropertyName,
            Boolean readOnly,
            String columnName)
        {
            // Retrieve information about the property through reflection.
            PropertyInfo property = type.GetProperty(dataPropertyName);

            // Confirm that the property exists and is accessible.
            if (property == null) throw new ArgumentException("No accessible " +
                dataPropertyName + " property was found in the " + type.Name + " type.");

            // Confirm that the property is browsable.
            BrowsableAttribute[] browsables = (BrowsableAttribute[])
                property.GetCustomAttributes(typeof(BrowsableAttribute), false);
            if (browsables.Length > 0 && !browsables[0].Browsable)
            {
                throw new ArgumentException("The " + dataPropertyName + " property has a " +
                "Browsable(false) attribute, and therefore cannot be bound.");
            }

            // Create and initialize a column, using a combo box column for
            // enumeration properties, a check box column for Boolean properties,
            // and a text box column otherwise.
            DataGridViewColumn column;
            Type valueType = property.PropertyType;
            if (valueType.IsEnum)
            {
                column = new DataGridViewComboBoxColumn();

                // Populate the drop-down list with the enumeration values.
                ((DataGridViewComboBoxColumn)column).DataSource
                    = Enum.GetValues(valueType);
            }
            else if (valueType.Equals(typeof(Boolean)))
            {
                column = new DataGridViewCheckBoxColumn();
            }
            else
            {
                column = new DataGridViewTextBoxColumn();
            }

            // Initialize and bind the column.
            column.ValueType = valueType;
            column.Name = columnName;
            column.DataPropertyName = dataPropertyName;
            column.ReadOnly = readOnly;

            // Add the column to the control.
            dataGridView1.Columns.Add(column);
        }

        private void ResetDataGridView()
        {
            dataGridView1.CancelEdit();
            dataGridView1.Columns.Clear();
            dataGridView1.DataSource = null;
            InitializeDataGridView();
        }

        private void dataGridView1_CellClick(
            object sender, DataGridViewCellEventArgs e)
        {
            if (e.ColumnIndex == -1 && e.RowIndex == -1)
            {
                ResetDataGridView();
            }
        }

        private void dataGridView1_ColumnWidthChanged(
            object sender, DataGridViewColumnEventArgs e)
        {
            // Invalidate the row corresponding to the column that changed
            // to ensure that the FillWeight and Width entries are updated.
            dataGridView1.InvalidateRow(e.Column.Index);
        }

        private void dataGridView1_CurrentCellDirtyStateChanged(
            object sender, EventArgs e)
        {
            // For combo box and check box cells, commit any value change as soon
            // as it is made rather than waiting for the focus to leave the cell.
            if (!dataGridView1.CurrentCell.OwningColumn.GetType()
                .Equals(typeof(DataGridViewTextBoxColumn)))
            {
                dataGridView1.CommitEdit(DataGridViewDataErrorContexts.Commit);
            }
        }

        private void dataGridView1_DataError(
            object sender, DataGridViewDataErrorEventArgs e)
        {
            if (e.Exception == null) return;

            // If the user-specified value is invalid, cancel the change
            // and display the error icon in the row header.
            if ((e.Context & DataGridViewDataErrorContexts.Commit) != 0 &&
                (typeof(FormatException).IsAssignableFrom(e.Exception.GetType()) ||
                typeof(ArgumentException).IsAssignableFrom(e.Exception.GetType())))
            {
                dataGridView1.Rows[e.RowIndex].ErrorText =
                    "The specified value is invalid.";
                e.Cancel = true;
            }
            else
            {
                // Rethrow any exceptions that aren't related to the user input.
                e.ThrowException = true;
            }
        }

        private void dataGridView1_CellEndEdit(
            object sender, DataGridViewCellEventArgs e)
        {
            // Ensure that the error icon in the row header is hidden.
            dataGridView1.Rows[e.RowIndex].ErrorText = "";
        }

        private void dataGridView1_CellValueChanged(
            object sender, DataGridViewCellEventArgs e)
        {
            // Retrieve the property to change.
            String nameOfPropertyToChange =
                dataGridView1.Columns[e.ColumnIndex].Name;
            PropertyInfo propertyToChange =
                typeof(DataGridViewColumn).GetProperty(nameOfPropertyToChange);

            // Retrieve the column to change.
            String nameOfColumnToChange =
                (String)dataGridView1["Column", e.RowIndex].Value;
            DataGridViewColumn columnToChange =
                dataGridView1.Columns[nameOfColumnToChange];

            // Use reflection to update the value of the column property.
            propertyToChange.SetValue(columnToChange,
                dataGridView1[nameOfPropertyToChange, e.RowIndex].Value, null);
        }
    }

  <@ (超實用)How to Query / Get Table Schema @> <== 所有DB的 Schema Information 都能查 ==>
    
    "SQL Server Schema Collections", 提供的集合項目, 請參閱: https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql-server-schema-collections

    //===查詢Table Schema使用範例===//
      connection.Open();
      DataTable dtSchema = connection.GetSchema("IndexColumns"); //取得 "IndexColumns" 集合
      DataRow[] rows = dtSchema.Select(String.Format("table_name  = '{0}' and index_name like '{1}' ", queryTable, "PK%")); //只抓PK開頭的INDEX
      List<string> listPKColumnsName = new List<string>();
      foreach (DataRow row in rows)
      {
          listPKColumnsName.Add(row["column_name"].ToString());
      }

      List<DataColumn> PKColumns = new List<DataColumn>(); //加入限制條件(資料表) 
      if (listPKColumnsName.Count > 0)
      {
          foreach (string colName in listPKColumnsName)
          {
              PKColumns.Add(dtResult.Columns[colName]);
          }
          dtResult.PrimaryKey = PKColumns.ToArray();
      }

  DataRowState
    Modified => 如果沒換行, 不會判為Modified(很奇怪)

  <How to use DataGridView DataError事件 & DataSet Table Schema Constraint(限制條件) , DataError事件 它只在程式前端作檢查, 還未送至DB後端>
    
    註. DataError事件在DataGridView內執行, 並不會送到後端DB.
    (VIP)DataTable 限制條件(例: PrimaryKey) 要先設定, 否則不會觸發 DataError事件
    
    1.	dataAdapter.Fill(DataSet)  => 把DataTable 放入 DataSet, <VIP>自己設定限制條件 table.PrimaryKey = PrimaryKeyColumns; <VIP>
    2.	dataAdapter.FillSchema(DataSet)可以把Table Constraint放入DataSet. (但是沒有Primary Key的限制條件, 所以改用 <如何查詢 Table Schema> 方式, 抓PK)
    3.	The DataError event of DataGridView enables you to handle exceptions thrown in code that is called by the control during data processing operations.
    4.	Finally, User input follow table constraint, then use dataAdapter.Update(DataSet) <-- Update data back to DB

  <DataGridViewV自動調整欄位寬度(拉開)>
    (<VIP>如果有自訂DataGridView Style, 請關閉否則會相互干擾...)
    //dvTHICKMS.AutoResizeColumns(DataGridViewAutoSizeColumnsMode.AllCells);

  <DataGridView 常用的事件順序>
    DataGridView1.CellValidating += new
        DataGridViewCellValidatingEventHandler(
        DataGridView1_CellValidating);
    DataGridView1.CellValidated += new DataGridViewCellEventHandler(
        DataGridView1_CellValidated);
    DataGridView1.CellValueChanged += new DataGridViewCellEventHandler(
        DataGridView1_CellValueChanged);
    DataGridView1.RowsRemoved += new DataGridViewRowsRemovedEventHandler(
        DataGridView1_RowsRemoved);
    DataGridView1.SelectionChanged += new EventHandler(
        DataGridView1_SelectionChanged);
    DataGridView1.UserAddedRow += new DataGridViewRowEventHandler(
        DataGridView1_UserAddedRow);
    DataGridView1.UserDeletingRow += new
        DataGridViewRowCancelEventHandler(DataGridView1_UserDeletingRow);

    DataGridView1_CellBeginEdit 可抓到編輯前的舊值 oldValue, 有 "e.Cancel" 可取消使用者行為
    DataGridView1_CellEndEdit 可抓到編輯後的新值 newValue, 沒有 "e.Cancel" 無法返回

  <How to 檢查 "類別檔" 是否已被參考 "主檔" 參考, "不得刪除" 及 "不得更新">
    0. 前提是: 資料表已建立之間的關聯性, 放在交易中試著刪除, 如果出現異常表示已被參考, 最後記得要回復.

    1. 不得刪除: 
      <How to use DataGridView.UserDeletingRow 事件, 頁面資料列刪除 觸發> https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.datagridview.userdeletingrow?view=windowsdesktop-6.0
    2. 不得更新:
      DataGridView1_CellBeginEdit 可抓到編輯前的舊值 oldValue
  
  <DataGridView 指定新增列預設值 DefaultValue 事件: DefaultValuesNeeded>
    this.dvFABRIC.DefaultValuesNeeded += dvFABRIC_DefaultValuesNeeded;

    void dvFABRIC_DefaultValuesNeeded(object sender, DataGridViewRowEventArgs e)
    {
        //不須指定欄位名稱就能抓到.
        //e.Row.Cells[3].Value = "BGX";
        //e.Row.Cells[4].Value = 0.0m;

        //須指定欄位名稱才抓的到.
        e.Row.Cells["BASE_FABRIC"].Value = "BGX";
        e.Row.Cells["DIFF"].Value = 0.0m;

        //(註)須指定欄位名稱才抓的到.
        //DataGridViewTextBoxColumn colBASE_FABRIC = new DataGridViewTextBoxColumn();
        //colBASE_FABRIC.HeaderText = "厚度基準布種";
        //colBASE_FABRIC.Name = "BASE_FABRIC";
    }

  <DataGridView.SelectionChanged 事件, 小心使用, 經常報錯ERROR, 觸發時點> 
    0. DataGridView.SelectionChanged & DataGridView1.CellValidating 很容易混淆,
      如果重點在驗證資料, 放在 DataGridView1.CellValidating 事件比較適用.

    0. [When Data Rebinding] 2022/01/26
      而且是每次都會跑, 如果查無資料, 這時使用 dvWIDEMS.CurrentCell 會報錯.(因為物件不存在)
      記得要作檢查

    1. [When CurrentCell Property changed] 
      https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.datagridview.selectionchanged?view=windowsdesktop-6.0#examples => "CurrentCellChanged", 可抓到變更前的值. 
      When you change the value of the CurrentCell property, the SelectionChanged event occurs before the CurrentCellChanged event. 
      Any SelectionChanged event handler accessing the CurrentCell property at this time will get its previous value.

      //抓到頁面上的USER修改最新值(作檢查會用這個)
      decimal current = Convert.ToDecimal(dvWIDEMS.CurrentCell.Value)
            , start = Convert.ToDecimal(dvWIDEMS.CurrentRow.Cells["THICK_START"].Value)
            , end = Convert.ToDecimal(dvWIDEMS.CurrentRow.Cells["THICK_END"].Value);

      //抓到資料來源繫結的初始值
      decimal start = Convert.ToDecimal(dvWIDEMS.Rows[i].Cells["THICK_START"].Value)
            , end = Convert.ToDecimal(dvWIDEMS.Rows[i].Cells["THICK_END"].Value);

  <How to use DataGridViewComboBoxColumn 用法, 手動新增欄位>

    參考資料(完整範例): https://docs.microsoft.com/zh-tw/dotnet/api/system.windows.forms.datagridviewcomboboxcolumn?view=windowsdesktop-6.0
    
    1. 設定 Value 屬性
      DataPropertyName 要設定, 如果ComboxValue必須對應外部資料來源值 (例: database column)
      ValueMember 要設定, ComboBoxColumn的內部資料值
      DisplayMember 要設定, ComboBoxColumn的外顯資料值

      DataGridViewComboBoxColumn combo = new DataGridViewComboBoxColumn();
      combo.DataSource = Enum.GetValues(typeof(Title)); //塞入ComboBox的資料來源, 可以是 DataTable, Enum, String Array(如果 DataSource 設定為 String Array, If the DataSource property is set to a string array, then ValueMember and DisplayMember do not need to be set because each string in the array will be used for both value and display.)
      combo.ValueMember = ColumnName.TitleOfCourtesy.ToString(); //(放入CELL的值)指定資料來源中對應欄位名稱, 
      combo.DisplayMember = comboboxColumn.ValueMember; //(資料顯示用)
      combo.Name = "Title";

    /^派上用場(真開心), 使用 String Array 繫結 ComboBox, DisplayMember & ValueMember 都不用設定^/
    * 固定值直接寫在 App.config
    * 使用

      <appSettings>
        <!--布片料種, 共9種-->
        <add key="FOAM_TYPE" value="All,A,I,L,N,P,T,X,Q,S"/>      
      </appSettings>

      /// <summary>
      /// 布片料種, 共9種
      /// </summary>
      private static string[] aryFOAM_TYPE
      {
          get { return ConfigurationManager.AppSettings.Get("FOAM_TYPE").ToString().Split(',');  }
      }

      void formWIDEMS_Load(object sender, EventArgs e)
      {
          
        this.cobFOAM.DataSource = aryFOAM_TYPE; //方法1: Bind String Array
        
        //this.cobFOAM.DataSource = GetComboBoxData(ComboBoxType.FOAM); //方法2: Bind Data Table
        //this.cobFOAM.DisplayMember = ComboBoxType.FOAM.ToString();
        //this.cobFOAM.ValueMember = ComboBoxType.FOAM.ToString();
        
        //this.cobFOAM.DataSource = Enum.GetValues(typeof(FoamType)); //方法3: Bind Enum
        
      }

    參考資料(範例): https://docs.microsoft.com/zh-tw/dotnet/api/system.windows.forms.datagridviewcolumn.datapropertyname?view=windowsdesktop-6.0#system-windows-forms-datagridviewcolumn-datapropertyname

    2. 手動產生欄位範例 (bindingSource1 & dataGridView1.AutoGenerateColumns = false)

      // Populate the data source.
      bindingSource1.Add(new Knight(Title.King, "Uther", true));
      bindingSource1.Add(new Knight(Title.King, "Arthur", true));
      bindingSource1.Add(new Knight(Title.Sir, "Mordred", false));
      bindingSource1.Add(new Knight(Title.Sir, "Gawain", true));
      bindingSource1.Add(new Knight(Title.Sir, "Galahad", true));

      // Initialize the DataGridView.
      dataGridView1.AutoGenerateColumns = false;
      dataGridView1.AutoSize = true;
      dataGridView1.DataSource = bindingSource1;

      // 加入ComboBox欄位
      dataGridView1.Columns.Add(CreateComboBoxWithEnums());

      //=============
      DataGridViewComboBoxColumn CreateComboBoxWithEnums()
      {
        DataGridViewComboBoxColumn combo = new DataGridViewComboBoxColumn();
        combo.DataSource = Enum.GetValues(typeof(Title)); //重點1: ComboBox自己的資料來源
        
        combo.DataPropertyName = "Title"; //VIP2: bindingSource1內的屬性名稱, 這樣子就能把 combox value 與 外部datasource 自動對應
        
        combo.Name = "Title";
        return combo;
      }

      public enum Title
      {
          King,
          Sir
      };

      When the AutoGenerateColumns property is set to true, each column automatically sets its "DataPropertyName" property 
      to the name of a property or database column in the data source specified by the DataSource property. 
      
      This binding can also be performed manually, which is useful when you want to display only a subset of the properties or database columns available in the data source. 
      In such cases, "set the AutoGenerateColumns property to false", 
      and then manually add each DataGridViewColumn, setting the value of each DataPropertyName property to the properties or database columns in the data source 
      that you want to display.

    參考資料: https://docs.microsoft.com/en-us/dotnet/desktop/winforms/controls/access-objects-in-a-wf-datagridviewcomboboxcell-drop-down-list?view=netframeworkdesktop-4.8
    
    3. 商務物件範例
      DataGridViewComboBoxColumn assignedToColumn = new DataGridViewComboBoxColumn();

      // Populate the combo box drop-down list with Employee objects.
      foreach (Employee e in employees) assignedToColumn.Items.Add(e);

      // Add "unassigned" to the drop-down list and display it for
      // empty AssignedTo values or when the user presses CTRL+0.
      assignedToColumn.Items.Add("unassigned");
      assignedToColumn.DefaultCellStyle.NullValue = "unassigned";

      assignedToColumn.Name = "Assigned To";
      assignedToColumn.DataPropertyName = "AssignedTo";
      assignedToColumn.AutoComplete = true;
      assignedToColumn.DisplayMember = "Name";
      assignedToColumn.ValueMember = "Self";

      dataGridView1.Columns.Add(assignedToColumn);

      // Add a CellClick handler to handle clicks in the button column.
      dataGridView1.CellClick +=
          new DataGridViewCellEventHandler(dataGridView1_CellClick);

      // Calls the Employee.RequestStatus method.
      void dataGridView1_CellClick(object sender, DataGridViewCellEventArgs e)
      {
          // Ignore clicks that are not on button cells.
          if (e.RowIndex < 0 || e.ColumnIndex !=
              dataGridView1.Columns["Status Request"].Index) return;

          // Retrieve the task ID.
          Int32 taskID = (Int32)dataGridView1[0, e.RowIndex].Value;

          // Retrieve the Employee object from the "Assigned To" cell.
          Employee assignedTo = dataGridView1.Rows[e.RowIndex]
              .Cells["Assigned To"].Value as Employee;

          // Request status through the Employee object if present.
          if (assignedTo != null)
          {
              assignedTo.RequestStatus(taskID);
          }
          else
          {
              MessageBox.Show(String.Format(
                  "Task {0} is unassigned.", taskID), "Status Request");
          }
      }

  <存放 TableSchema 用, 作為輸入前資料檢查依據>
    dsTableSchema = new DataSet(); //必須先產生新的DataSet, 否則FillSchema會把新的TableSchema塞在後面, 檢查時會抓錯.
    dataAdapter.FillSchema(dsTableSchema, SchemaType.Mapped); //再塞1次

  <抓取 DataRow 正確欄位 DataColumn的值, 不要用 ColumnIndex, 容易看不懂>
      listParameters.Add(new SqlParameter("@" + col.ColumnName 
    , row.ItemArray[dt_InsertUpdate.Columns.IndexOf(col.ColumnName)])); //Assign New Values

    //要明確知道 "ColumnName"

  <C# DataType & SQL Server DataType是不同的, 必須作轉換, 取得主鍵名稱, 主鍵資料類型用>
    /// <summary>
    /// 取得資料表PK欄位陣列
    /// </summary>
    /// <param name="tableName"></param>
    /// <returns></returns>
    private DataColumn[] getPKColumns(string tableName)
    {
        List<DataColumn> pkColumns = new List<DataColumn>();

        using (SqlConnection connection = new SqlConnection(connString))
        {
            try
            {
                connection.Open();

                DataTable dtSchema_PK = connection.GetSchema("IndexColumns");
                DataTable dtSchema_Columns = connection.GetSchema("Columns");

                DataRow[] PKColumns = dtSchema_PK.Select(String.Format("table_name  = '{0}' and index_name like '{1}' ", tableName, "PK%"));
                //DataRow[] ColumnInfos = dtSchema_Columns.Select(String.Format("table_name  = '{0}' ", tableName));

                int indexOfColumnName = dtSchema_PK.Columns.IndexOf("column_name");
                int indexOfColumnDataType = dtSchema_Columns.Columns.IndexOf("DATA_TYPE");

                //抓取 ColumnName & ColumnType From Two Tables
                foreach (DataRow item in PKColumns)
                {
                    //get ColumnName
                    var colName = item.ItemArray[indexOfColumnName].ToString();
                    
                    //get ColumnType
                    var rowInfo = dtSchema_Columns.Select(String.Format("table_name  = '{0}' and column_name = '{1}' ", tableName, colName)).First();
                    string dotNetType = "", sqlType = rowInfo.ItemArray[indexOfColumnDataType].ToString();
                    switch (sqlType)
                    {
                        case "decimal":
                            dotNetType = "Decimal";
                            break;
                        case "char":
                            dotNetType = "String";
                            break;
                        case "int":
                            dotNetType = "Int32";
                            break;
                    }
                    Type colType = Type.GetType(String.Format("System.{0}", dotNetType));

                    DataColumn newColumn = new DataColumn(colName, colType);
                    pkColumns.Add(newColumn);
                }
            }
            catch (Exception)
            {
                //throw;
            }
        }
        return pkColumns.ToArray();
    }

  <熟悉 BindingSource 使用方式>
    DB <-查詢/更新-> SqlDataAdapter + BindingSource <-查詢/異動-> DataGridView
    BindingSource 會記錄異動項目, 再透過SqlDataAdapter.Update, 更新回DB
    BindingSource 作為中介資料來源, 它會暫存初始資料, 比對異動.

  <SqlParameter.Size 屬性> => Size屬性用於(二進位)和(字串類型), 其他類型一律不適用..
    如果是類型的參數 SqlType.String ，則會 Size 以 Unicode 字元表示長度。 
    ==
    如果是類型的參數 SqlType.Xml ， Size 則會忽略。
    如果是類型的參數 SqlType.Int(數值), Size 一樣會忽略. <== 自行測試結果 2022/02/18
    如果是類型的參數 SqlType.Date(日期), Size 一樣會忽略. <== 自行測試結果 2022/02/18
    ==

    https://docs.microsoft.com/zh-tw/dotnet/api/system.data.sqlclient.sqlparameter.size?view=dotnet-plat-ext-6.0

  <CSC 手動編輯程式放在哪裡>
    C:\Windows\Microsoft.NET\Framework\v3.5\csc.exe

  =匿名類型(annoymous type)=
    1. 一組{唯讀屬性}封裝成一個物件，而不需要事先明確定義類型.
    2. 也可利用 new + 物件初始化運算式, 產生 匿名型別.
        範例:
          var sun = new { Temperater = 30, Message = "hot" };
    3. 最常見的用法: 使用其他類型的屬性, 來初始化匿名類型.
        範例:
          var productQuery = 
              from prod in products
              select new { prod.Color, prod.Price };

          foreach(var v in productQuery)
          {
            Console.WriteLine($"Color={v.Color}, Price={v.Price}");
          }
    4. 匿名類型項目的陣列
        範例:
          var annoyArray = new[] { new {name = "Apple", price = 10}, new {name="banana", price = 5} };

  =泛型(Generic)=
    1. 泛型 帶進 [型別參數] 的概念
    2. 在設計方法時, 延遲型別規格, 直到用戶碼程式碼實體/物件化為止.
    3. 使用泛型型別參數 T, 可供其他用戶程式使用 自訂類別, 而不會產生 {執行時間轉換} 或 {裝箱作業} 的成本及風險

    4. 泛型範例
      public class GenericList<T>
      {
        public void Add(T input){ }
      }
      class TestGenericList
      {
        private class ExampleClass {}

        static void Main()
        {
          GenericList<int> listInt = new GenericList<int>();
          listInt.Add(1);

          GenericList<string> listString = new GenericList<string>();
          listString.Add("hello");

          GenericList<ExampleClass> listClass = new GenericList<ExampleClass>();
          listClass.Add(new ExampleClass());
        }
      }
    5. 小結
      * 使用泛型型別以{最佳化程式碼重複使用}、{型別安全和效能}。(註: 使用泛型型別的好處有: 程式碼重複使用, 型別安全及效能)
      
      * 泛型的{最常見用法是建立集合類別}。(註: 常見用法, public class List<T> {}, 建立集合類別)
      
      * .NET 類別庫包含命名空間中的數個泛型集合類別 {System.Collections.Generic} 。 
        {應該盡可能使用泛型集合}，而不是 ArrayList 命名空間中的類別 System.Collections 。
      
      * 您可以建立自己的泛型介面、類別、方法、事件和委派。
      
      * 泛型類別可限制為允許存取特定資料類型上的方法。
      
      * 泛型資料類型中所使用的類型相關資訊，可在執行階段透過反映取得。

=ASP.NET Core 比較困難的, 放後面..=

  = 教學課程：ASP.NET Core 使用者入門(完整的在這裡..) = 
  https://docs.microsoft.com/zh-tw/aspnet/core/getting-started/?view=aspnetcore-6.0&tabs=windows

  = Module: Create a web API with ASP.NET Core Controllers =

  = Module: Create a full stack application by using React and minimal API for ASP.NET Core =

  = Module: Build a web API with minimal API, ASP.NET Core, and .NET 6 =

  = Module: Use a database with minimal API, Entity Framework Core, and ASP.NET Core =

  = Module: Publish a web app to Azure with Visual Studio =

  = Learning Path: Create web apps and services with ASP.NET Core, minimal API, and .NET 6 =

=常用指令 C# & .NET CORE=

  > (C#)
    * 利用 [CMD模式] 編譯並執行 C#程式
        Open a text editor and add the above-mentioned code.

        Save the file as helloworld.cs

        Open the command prompt tool and go to the directory where you saved the file.

        Type [csc helloworld.cs] and press enter to compile your code.

        If there are no errors in your code, the command prompt takes you to the next line and generates helloworld.exe executable file.

        Type helloworld to execute your program.

        You can see the output Hello World printed on the screen.

  > (.NET CORE)
    =指令:Create a new console app=
      dotnet new console

      dotnet new console -n <專案名稱> -o .
      dotnet new console -n files-module -o .

    =指令:run console app=
      dotnet run

    =指令:Create a new WebApi app=
      dotnet new webapi --no-https

    =指令:build web api=
      dotnet build

    =指令:build web api & run web api=
      dotnet run

    =指令:連接webapi by httprepl=
      httprepl http://xxxxx

/* 考題練習 */
  == 考前問答(問題有深度的) ==
    1. System.ApplicationException & System.SystemException 的差別 ?
      System.SystemException, 預先定義所有系統例外.
      System.ApplicationException, 預先定義應用程式例外, 程式員應該要先從這個類別衍生.
    
    2. 所有例外的基底類別(Base Class)是 ?
      System.Exception.

    3. 什麼是 preprocessor directives ?
      指示編譯器如何進行編譯.

    4. 什麼是 interface (介面) ?
      它像是一份契約, 定義標準結構或大綱. 繼承類別必須依循其定義結構, 進行設計.

    5. 什麼是 virtual function ?
      有一個方法希望在 繼承類別中被實作, 可以使用 virtual function.

    6. 什麼是 sealed class ?
      有一類別加上 sealed 修飾詞, 可防止其他類別繼承於該類別.
        例: class A {}
            sealed class B : A {} //B無法再被繼承.

    7. C# 如何支援 動態多形 (dynamic polymorphism)?
      透過 抽象類別(abstract class) & 虛擬函式(virtual function) 兩種方式進行實作.

    8. 什麼是 函式多載 (function overloading) ?
      同一個方法上有多種定義, 透過 {參數型態} 或 {參數個數} 等方式作區隔.

    9. 什麼是 early binding ?
      在編譯時, 就將函式與物件作連結, 又稱為 static binding.

    10. C# 如何支援 靜態多形 (static polymorphism)?
      透過 函式多載(function overloading) & 運算子多載(operator overloading) 兩種方式.

    11. 靜態多形 & 動態多形 的差別是 ?
      靜態多形: 編譯時, 就確定函式的回傳(response).
      動態多形: 執行時, 才能確定.

    12. 什麼是多形?
      一個介面, 有多種方法.

    13. C# 如何繼承/衍生?
      一個類別可由多個類別或介面衍生出來, 也就是說 它能 繼承 來自於多個基底類別(Base Class)/介面的 資料和函式.
    
    14. C# 支援多重繼承嗎?
      NO, 不支援多重繼承.

    15. class member 的預設存取修飾子?
      private (私有)

    16. class 的預設存取修飾子?
      internal (只開放給元件/組件間使用, 同一個DLL內使用)

    17. 什麼是列舉(Enumeration)? 
      它是1組被命名的數值常數, 視為 value data type.
      它只包含它本身的數值, 無法被繼承或繼承間傳遞.

    18. 類別(class)與結構(structure)間的差異?
      1. 類別是參考型別, 結構是值型別.
      2. 結構不支援繼承.
      3. 結構不能有預設建構子.

    19. 什麼是結構(structure) ?
      1. 結構是值型別.
      2. 讓你使用1個結構, 保留不同資料型態的相關資料.
      3. struct keyword
      4. 結構 通常用來 表示 1筆記錄(內有多個不同資料型態的值).

    20. 如何反序排列 陣列?
      1. 先用 Array.sort(array);
      2. 再用 Array.reverse(array);

    21. 如何正序排列 陣列?
      用 Array.sort(array);

    22. 所有 陣列的 基底類別(Base Class)是?
      Array.
      它被定義在 System 命名空間內.

    21. Can you pass additional type of parameters after using params in function definition?
      不行
    
    22. Can you create a function in C# which can accept varying number of arguments?
      可以, 利用 params 關鍵字, 可讓 1個參數傳入多個值.

    23. ?? 的用法?
      if (val1 ?? val2)
      if val1 is null , return val2.
      if val1 is not null , return val1.
    
    24. 什麼是 nullable type?
      除了原本資料型態值外, 亦能指定為 null
      例: Nullable<Int32> money, 可指定 null or -2,147,483,648 to 2,147,483,647.
      例: Nullable<bool> weather, 可指定 true or false or null.
    
    25. What is scope of a {Protected Internal} member variable of a C# class?
      相同組件內的 別的類別物件都 {無法存取}, 除了子類別(Child Class)可以外.

    26. What is scope of a {Internal} member variable of a C# class?
      相同組件內的 別的類別物件 都{能存取}

    27. What is scope of a {protected} member variable of a C# class?
      只有子類別(Child Class)能存取
    
    28. What is scope of a {private} member variable of a C# class?
      只有在同類別同函式內能存取.

    29. What is scope of a public member variable of a C# class?
      完全開放

    30. What is the purpose of an {access specifier} in C#?
      定義類別成員的範圍及可視性.

    31. C#內, 如何實作封裝(encapsulation) ?
      利用存取修飾子 (access specifier)

    32. 什麼是封裝(encapsulation)?
      避免被存取

    33. C#內, as 運算子的用法?
      轉型失敗時, 不會產生例外的作法.
      Object obj = new StringReader("Hello");
      StringReader r = obj as StringReader;

    34. C#內, is 運算子的用法?
      檢查物件是否為特定型態.
      if (Ford is Car)

    35. 什麼是 指標型態?
      type* identifier.
      char* cptr;

    36. dynamic type variable & object type variable的差異?
      object type variable, 編譯時確定.
      dynamic type variable, 執行時才確定.

    37. 什麼是 dynamic type variable?
      dynamic d = 20; //執行時才確定.

    38. unboxing 
      物件型態 轉為 值型態.

    39. boxing
      值型態 轉為 物件型態.

    40. 所有資料型態的基底類別(Base Class)?
      Object Type = reference type + value type +....
    
    41. What is the difference between ref and out parameters?
      ref 改變記憶體位置.
      out 把值傳出.

    42. 可否1次回傳多個值?
      可以, 利用 output parameter.
      return 只能回傳單1值.

    43. In how many ways you can pass parameters to a method?
      value parameter.
      reference parameter.
      output parameter.

  == MOCK Test(問題有深度的) == 
  資料來源 https://www.tutorialspoint.com/csharp/csharp_mock_test.htm?min=76&max=100

    1. C# Mock Test I (OK, 2021/12/07)

      D Q1. Which of the following is correct about C#?
        A. C# is a modern, general-purpose, object-oriented programming language developed by Microsoft.
        B. C# was developed by Anders Hejlsberg and his team during the development of .Net Framework.
        C. C# is designed for Common Language Infrastructure (CLI).
        D. All of the above. (O)

      D C Q2. Which of the following is correct about C#? (C# 的特性)
        A. It is component oriented. (O, 組件基礎)
        B. It can be compiled on a variety of computer platforms. (O, 可在不同的平台上編譯 & sure, it is through MONO. https://www.tutorialspoint.com/executing-chash-code-in-linux)
        C. It is a part of .Net Framework. (O)
        D. All of the above. (O)

      B Q3. Which of the following keyword is used for including the namespaces in the program in C#?
        A. imports
        B. using (O, 使用 using 關鍵字將其他命名空間納入運用)
        C. exports
        D. None of the above.

      C Q4. Which of the following is correct about variable naming conventions in C#?
        A. A name must begin with a letter that could be followed by a sequence of letters, digits (0. 9) or underscore. (O, 變數命名規則1: 以字母開頭, 後面可接數字或底線或其他字母)
        B. The first character in an identifier cannot be a digit. (O, 變數命名規則2: 不能以數值開頭)
        C. Both of the above. (O)
        D. None of the above. (X)

      C Q5. Which of the following is correct about variable naming conventions in C#?
        A. It should not be a C# keyword. (O, 變數命名規則3: 不能使用C#關鍵字)
        B. It must not contain any embedded space or symbol such as?. + ! @ # % ^ & * ( ) [ ] { } (O, 變數命名規則4: 不能使用特殊字元)
        C. Both of the above. (O)
        D. None of the above.

      D Q6. Which of the following is a reserved keyword in C#? (何者為保留關鍵字)
        A. abstract (O, abstract 修飾詞表示要修改的項目具有不完整的實作，通常用於Base Class. 被標示為 abstract 的函式必須在衍生類別中進行實作.)
        B. as (O, C# 提供模式比對陳述式，只有在成功時才會有條件地執行轉換。 C# 也提供 is 和 as 運算子，藉此測試值是否為特定類型。
                  as 運算子將運算式的結果明確地轉換成給定參考或可為 Null 的實值型別。 
                  如果無法轉換，則運算子會傳回 as null 。 
                  不同於 cast 運算式， as 運算子永遠不會擲回例外狀況。)
        C. foreach (O, )
        D. All of the above. (O)

        參考：【如何使用模式比對和 as 和 as 運算子，安全地進行轉換】
        https://docs.microsoft.com/zh-tw/dotnet/csharp/fundamentals/tutorials/safely-cast-using-pattern-matching-is-and-as-operators
        
      D Q7. Which of the following is a contextual keyword in C#? (內容關鍵字, 內容關鍵字可用來在程式碼中提供特定的意義，但它不是 C# 中的保留字。)
        A. get (O, property get {} or get => xxx; )
        B. set (O, property set {} or set => xxx; )
        C. add (O, 如果有自訂add 存取子, 也須一併 自訂 remove 存取子.)
        D. All of the above. (O)

        補充1：使用 add 內容關鍵字定義自訂事件存取子，以在用戶端程式碼訂閱事件時叫用。 如果提供自訂的 add 存取子，您也必須提供 remove 存取子。
        補充2：您通常不需要提供自己的自訂事件存取子。 宣告事件時編譯器自動產生的存取子，足以應付大部分的狀況。
        補充3：class Events : IDrawingObject
              {
                  event EventHandler PreDrawEvent;

                  event EventHandler IDrawingObject.OnDraw
                  {
                      add => PreDrawEvent += value;
                      remove => PreDrawEvent -= value;
                  }
              }

      B Q8. We can use reserved keywords as identifiers in C#? (不能將保留關鍵字, 作為識別項)
        A. true
        B. false (O)

      B Q9. We can use reserved keywords as identifiers in C# by prefixing them with @ character? (@ 特殊字元可用為逐字識別項, 讓C#關鍵字變為識別項, 作為識別項 or 變數名稱等..)
        A. true (O)
        B. false (X)

        參考：較深入的問題, 答案是 true. @ 特殊字元可用為逐字識別項
        https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/tokens/verbatim

        補充1：讓 C# 關鍵字用為識別項。 @ 字元將程式碼元素當成前置詞，編譯器要將此元素解譯為識別項，不是 C# 關鍵字。 例如：@for
        補充2：string[] @for = { "John", "James", "Joan", "Jamie" };
              for (int ctr = 0; ctr < @for.Length; ctr++)
              {
                Console.WriteLine($"Here is your gift, {@for[ctr]}!");
              }
              // The example displays the following output:
              //     Here is your gift, John!
              //     Here is your gift, James!
              //     Here is your gift, Joan!
              //     Here is your gift, Jamie!

      A Q10. Which of the following variable types can be assigned a value directly in C#? (可直接指定變數在 '實值型別')
        A. Value types (O, 可直接指定變數)
        B. Reference types (X, 先新增物件, 再指定變數)
        C. Pointer types (X, 先新增物件, 再指定變數)
        D. All of the above.

      A Q11. Value type variables in C# are derived from the class System.ValueType? (YES)
        A. true (O, 答案正確, Value type 是衍生自 System.ValueType)
        B. false

      D Q12. Which of the following is correct about value type variables in C#? (有關實值型別, 何者正確?)
        A. The value types directly contain data. (O)
        B. int, char, and float, which stores numbers, alphabets, and floating point numbers, respectively are value types. (O)
        C. When you declare an int type, the system allocates memory to store the value. (O)
        D. All of the above. (O)

      D Q13. Which of the following is correct about reference type variables in C#? (有關參考型別, 何者正確?)
        A. The reference types do not contain the actual data stored in a variable. (O)
        B. They contain a reference to the variables. (O)
        C. Example of built-in reference types are: object, dynamic, and string. (O)
        D. All of the above. (O)

      D Q14. Which of the following is correct about Object Type in C#? (有關物件型別, 何者正確?)
        A. The Object Type is the ultimate base class for all data types in C# Common Type System (CTS). (O)
        B. Object is an alias for System.Object class. (O)
        C. The object types can be assigned values of any other types, value types, reference types, predefined or user-defined types. (O)
        D. All of the above. (O)

      A Q15. Which of the following defines boxing correctly? (boxing = 實值轉參考)
        A. When a value type is converted to object type, it is called boxing. (O, 實值轉參考, 是 boxing)
        B. When an object type is converted to a value type, it is called boxing. (X, 參考轉實值, 是unboxing)
        C. Both of the above. (X)
        D. None of the above.

      B Q16. Which of the following defines unboxing correctly? (unboxing = 參考轉實值)
        A. When a value type is converted to object type, it is called unboxing. (X)
        B. When an object type is converted to a value type, it is called unboxing. (O, 參考轉實值, 是unboxing)
        C. Both of the above.
        D. None of the above.

      C Q17. Which of the following is correct about dynamic Type in C#? (有關動態型別, 何者正確)
        A. You can store any type of value in the dynamic data type variable. (O, 動態型別, 它能儲存任何型態的值)
        B. Type checking for these types of variables takes place at run-time. (O, 型別檢查發生於 執行階段)
        C. Both of the above. (O)
        D. None of the above.

        參考: 使用 dynamic 類型 (C# 程式設計手冊)
        https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/types/using-type-dynamic
        補充1: 在C# 4.0後引入 dynamic type in c#, 因為它能夠減少轉換所耗費的時間 for Excel, for IronPython, for IronRuby
        補充2: 程式碼如有錯誤通常在編譯階段會略過, 但執行階段仍會產生.

      A Q18. Which of the following converts a type to a Boolean value, where possible in C#? (Convert.ToBoolean)
        A. ToBoolean (O, 轉換為布林值)
        B. ToSingle
        C. ToChar
        D. ToDateTime

      B Q19. Which of the following converts a type to a byte value in C#? (Convert.ToByte)
        A. ToSingle
        B. ToByte (O, 轉換為Byte值)
        C. ToChar
        D. ToDateTime

      C Q20. Which of the following converts a type to a single Unicode character, where possible in C#? (Convert.ToChar)
        A. ToSingle
        B. ToByte
        C. ToChar (O, 轉換為 Unicode, 例: \U006A)
        D. ToDateTime

      D B Q21. Which of the following converts a type (integer or string type) to date-time structures in C#? (Convert.ToDateTime)
        A. ToString
        B. ToSingle (O, Convert.ToSingle(value, clutureInfo), 例: 台灣日期為2021/12/07, 美國日期為12/07/2021..)
        C. ToChar
        D. ToDateTime (O)

        註: 要將數值或字串型態轉為日期結構, 要使用 ToDateTime
          ex1. 
          string dateString = null;
          dateString = "2021/12/07";
          DateTime convertedDateTime = Convert.ToDateTime(dateString);
          Console.WriteLine(convertedDateTime);

        
        參考: 轉換有文化屬性/國家別資料, 使用指定之特定文化特性格式資訊
        https://docs.microsoft.com/zh-tw/dotnet/api/system.convert.tosingle?view=net-6.0#System_Convert_ToSingle_System_String_System_IFormatProvider_

      A Q22. Which of the following converts a floating point or integer type to a decimal type in C#? (Convert.ToDecimal)
        A. ToDecimal (O)
        B. ToDouble
        C. ToInt16
        D. ToInt32

      B Q23. Which of the following converts a type to a double type in C#? (Convert.ToDouble)
        A. ToDecimal

        B. ToDouble (O)

        C. ToInt16

        D. ToInt32

      C Q24. Which of the following converts a type to a 16-bit integer in C#? (Convert.ToInt16)
        A. ToDecimal

        B. ToDouble

        C. ToInt16 (O)

        D. ToInt32

      D Q25. Which of the following converts a type to a 32-bit integer in C#? (Convert.ToInt32)

        A. ToDecimal

        B. ToDouble

        C. ToInt16

        D. ToInt32 (O)

      Question Number 	Answer Key
        1 	D
        2 	D
        3 	B
        4 	C
        5 	C

        6 	D
        7 	D
        8 	B
        9 	A
        10 	A

        11 	A
        12 	D
        13 	D
        14 	D
        15 	A
        
        16 	B
        17 	C
        18 	A
        19 	B
        20 	C

        21 	D
        22 	A
        23 	B
        24 	C
        25 	D

    2. C# Mock Test II (OK, 2021/12/07)

      A Q1. Which of the following converts a type to a 64-bit integer in C#? (Convert.ToInt64, 將指定的值轉換為 64 位元帶正負號的整數)

        A. ToInt64

        B. ToSbyte

        C. ToSingle

        D. ToInt32

      B Q2. Which of the following converts a type to a signed byte type in C#? (Convert.ToSbyte, 將傳轉換為 8位元 正負號整數)

        A. ToInt64

        B. ToSbyte

        C. ToSingle

        D. ToInt32
      
      C D Q3. Which of the following converts a type to a small floating point number in C#? (O, Convert.ToSingle; 單精度浮點數 X, Convert.ToInt32)

        A. ToInt64

        B. ToSbyte

        C. ToSingle (O)

        D. ToInt32 (X, 答錯了)

      D Q4. Which of the following converts a type to a string in C#? (Convert.ToString)

        A. ToInt64

        B. ToSbyte

        C. ToSingle

        D. ToString (O)

      A Q5. Which of the following converts a type to a specified type in C#? (Convert.ToType(specified-type))

        A. ToType (O)

        B. ToSbyte

        C. ToSingle

        D. ToString

      B Q6. Which of the following converts a type to an unsigned int type in C#? (Convert.ToUInt16, 將傳轉換為 16位元 正整數)

        A. ToType

        B. ToUInt16 (O)

        C. ToSingle

        D. ToString

      C Q7. Which of the following converts a type to an unsigned long type in C#? (Convert.ToUInt32, 將傳轉換為 32位元 正整數)

        A. ToType

        B. ToUInt16

        C. ToUInt32 (O)

        D. ToString

      D Q8. Which of the following converts a type to an unsigned big type in C#? (Convert.ToUInt64, 將傳轉換為 64位元 正整數)

        A. ToType

        B. ToUInt16

        C. ToUInt32

        D. ToUInt64 (O)

      A Q9. Which of the following operator returns the size of a data type in C#? (sizeof, 回傳資料型態的大小, returns the size of a data type)

        A. sizeof (O)

        B. typeof

        C. &

        D. *

      B Q10. Which of the following operator returns the type of a class in C#? (typeof, 回傳類別型態, returns the type of a class)

        A. sizeof

        B. typeof (O)

        C. &

        D. *

      C Q11. Which of the following operator returns the address of an variable in C#? (&, 回傳變數記憶體位址, returns the address of an variable)

        A. sizeof

        B. typeof

        C. & (O)

        D. *

      D Q12. Which of the following operator creates a pointer to a variable in C#? (*, 新增指標指向變數, creates a pointer to a variable)

        A. sizeof

        B. typeof

        C. &

        D. * (O)

      A Q13. Which of the following operator represents a conditional operation in C#? (?:, 表示條件式判斷作業之運算子, represents a conditional operation)

        A. ?: (O)

        B. is

        C. as

        D. *

      B Q14. Which of the following operator determines whether an object is of a certain type in C#? (is, 可識別物件是否屬於某型態之運算子)

        A. ?:

        B. is (O)

        C. as

        D. *

      C Q15. Which of the following operator casts without raising an exception if the cast fails in C#? (as, 轉型用運算子, 若轉型失敗並不會丟出例外)

        A. ?:

        B. is

        C. as (O)

        D. *

      D Q16. Which of the following statements is correct about encapsulation? (關於封裝的定義)

        A. Encapsulation is defined as the process of enclosing one or more items within a physical or logical package. (O)

        B. Encapsulation, in object oriented programming methodology, prevents access to implementation details. (O)

        C. Abstraction allows making relevant information visible and encapsulation enables a programmer to implement the desired level of abstraction. (O)

        D. All of the above. (O)

      說明: 封裝實作時, 確實要指定存取範圍.
      C B Q17. Which of the following statements is correct about access specifiers in C#? (關於存取指定詞的定義, Public, private, protected)

        A. Encapsulation is implemented by using access specifiers. (X, 封裝實作時, 不須使用存取指定詞; O, 意思搞錯了, 封裝實作時 != 要執行封裝時, 封裝實作時, 確實要指定存取範圍)

        B. An access specifier defines the scope and visibility of a class member. (O)

        C. Both of the above. (O)

        D. None of the above.

      說明: 存取範圍子 [Public] - 開放類別內部成員變數及成員函式(最公開), 給其他函式及物件
      A Q18. Which of the following access specifier in C# 
          allows a class to expose its member variables and member functions to other functions and objects?

        A. Public (O)

        B. Private

        C. Protected

        D. Internal

      說明: 存取範圍子 [Private] - 隱藏類別內部成員變數及成員函式(最私密)
      B C Q19. Which of the following access specifier in C# 
          allows a class to hide its member variables and member functions from other functions and objects?

        A. Public

        B. Private (O)

        C. Protected (X, 觀念還不清楚)

        D. Internal

      說明: 存取範圍子 [Protected] - 開放子類別(Child Class)存取基底類別(Base Class)內部成員變數及成員函式
      C B Q20. Which of the following access specifier in C# 
          allows a child class to access the member variables and member functions of its base class?

        A. Public

        B. Private (X, 觀念還不清楚)

        C. Protected (O)

        D. Internal

      說明: 存取範圍子 [Internal] - 開放類別內部成員變數及成員函式, 給同一個組件(assembly)的其他函式或物件使用 
      D Q21. Which of the following access specifier in C# allows a class to 
        expose its member variables and member functions to other functions and objects in the current assembly?

        A. Public

        B. Private

        C. Protected

        D. Internal (O, 觀念還不清楚)
    
      說明: 存取範圍子 [Protected Internal] - 類別隱藏內部成員變數及成員函式, 但開放給同程式內的子類別(Child Class)存取
      A Q22. Which of the following access specifier in C# allows a class to 
        hide its member variables and member functions from other class objects and functions, except a child class within the same application?

        A. Protected Internal (O, 觀念還不清楚)

        B. Private

        C. Protected

        D. Internal

      A Q23. Which of the following method (copies the actual value of an argument) into the formal parameter of the function?

        A. Value parameters (O)

        B. Reference parameters

        C. Output parameters

        D. None of the above.

      B Q24. Which of the following method (copies the reference to the memory location of an argument) into the formal parameter?

        A. Value parameters

        B. Reference parameters (O)

        C. Output parameters

        D. None of the above.

      C Q25. Which of the following method helps in (returning more than one value)?

        A. Value parameters

        B. Reference parameters

        C. Output parameters (O)

        D. None of the above.

      Question Number 	Answer Key
        1 	A
        2 	B
        3 	C
        4 	D
        5 	A

        6 	B
        7 	C
        8 	D
        9 	A
        10 	B

        11 	C
        12 	D
        13 	A
        14 	B
        15 	C

        16 	D
        17 	C
        18 	A
        19 	B
        20 	C

        21 	D
        22 	A
        23 	A
        24 	B
        25 	C

    3. C# Mock Test III (OK, 2021/12/07)

      D Q1. Which of the following is correct about nullable types in C#? (關於 Nullable Type)

        A. C# provides a special data types, the nullable types, to which you can assign normal range of values as well as null values. 
          (O, Nullable Type可指定一般值以及NULL)

        B. You can assign true, false, or null in a Nullable<bool> variable. 
          (O, Nullable<bool>可指定 true, false  & NULL)

        C. You can store any value from -2,147,483,648 to 2,147,483,647 or null in a Nullable<Int32> variable. 
          (O, Nullable<Int32> 可指定-2,147,483,648 to 2,147,483,647 & NULL)

        D. All of the above. (O)


      補充1: The null-coalescing (??) operator is very simple and it can be very helpful in null checking scenarios.(在檢查NULL的情境時, ?? 十分有效)
      參考: Null Coalescing (??) Operator in C#的完整介紹(有程式範例) https://www.c-sharpcorner.com/UploadFile/ff2f08/null-coalescing-operator-in-C-Sharp16/

      補充2: 當您使用 可為 null 的實值型別，而且必須提供基礎實值型別的值時，請使用 ?? 運算子來指定要提供的值，以免可為 null 的型別值為 null
      參考: https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/null-coalescing-operator

      D Q2. Which of the following is correct about null coalescing operator in C#? (?? = Null- Coalescing Operator 在 C#內的用法)

        A. The null coalescing operator is used with the nullable value types and reference types. 
          (O, 從 C# 8.0 開始，您可以使用 null 聯合運算子搭配不受限制的型別參數)

        B. It is used for converting an operand to the type of another nullable (or not) value type operand, where an implicit conversion is possible. (O, )

        C. If the value of the first operand is null, then the operator returns the value of the second operand, otherwise it returns the value of the first operand. (O, 若第1個運算式為NULL, 則回傳第2個運算式, 否則回傳第1個運算式)

        D. All of the above. (O)

      補充: params (C# 參考)
      參考: https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/params
      D B Q3. Which of the following is correct about params in C#? (有關 使用 params 關鍵字，您可以指定方法參數，其採用可變數目的引數。 參數類型必須是一維陣列。) <== 困難 ==> <== 觀念不熟 ==>

        A. By using the params keyword, a method parameter can be specified which takes a variable number of arguments or even no argument. (O)
          註: 傳入方法參數, 可指定陣列元素型別的引數清單（以逗號分隔）、指定之類型的引數陣列、無引數。 如果不傳送任何引數，params 清單的長度為零。

        B. Additional parameters are not permitted after the params keyword in a method declaration. (O)
          註: 使用 params 關鍵字來傳入參數, 不允許再加入額外參數項目.

        C. Only one params keyword is allowed in a method declaration. (O)
          註: 在方法宣告中，params 關鍵字後面不允許任何其他參數，而且方法宣告中只允許一個 params 關鍵字。

        D. All of the above. (O)

        程式範例:
          public class MyClass
          {
              public static void UseParams(params int[] list)
              {
                  for (int i = 0; i < list.Length; i++)
                  {
                      Console.Write(list[i] + " ");
                  }
                  Console.WriteLine();
              }

              public static void UseParams2(params object[] list)
              {
                  for (int i = 0; i < list.Length; i++)
                  {
                      Console.Write(list[i] + " ");
                  }
                  Console.WriteLine();
              }

              static void Main()
              {
                  // You can send a comma-separated list of arguments of the
                  // specified type.
                  UseParams(1, 2, 3, 4);
                  UseParams2(1, 'a', "test");

                  // A params parameter accepts zero or more arguments.
                  // The following calling statement displays only a blank line.
                  UseParams2();

                  // An array argument can be passed, as long as the array
                  // type matches the parameter type of the method being called.
                  int[] myIntArray = { 5, 6, 7, 8, 9 };
                  UseParams(myIntArray);

                  object[] myObjArray = { 2, 'b', "test", "again" };
                  UseParams2(myObjArray);

                  // The following call causes a compiler error because the object
                  // array cannot be converted into an integer array.
                  //UseParams(myObjArray);

                  // The following call does not cause an error, but the entire
                  // integer array becomes the first element of the params array.
                  UseParams2(myIntArray);
              }
          }
          /*
          Output:
              1 2 3 4
              1 a test

              5 6 7 8 9
              2 b test again
              System.Int32[]
          */

      A Q4. Which of the following property of Array class in C# checks whether the Array has a fixed size? (檢查Array是否為固定長度之屬性, IsFixedSize)

        A. IsFixedSize (O)

        B. IsStatic

        C. Length

        D. None of the above.

      B Q5. Which of the following property of Array class in C# checks whether the Array is readonly? (檢查Array是否為唯讀, IsReadOnly)

        A. IsFixedSize

        B. IsReadOnly (O)

        C. Length

        D. None of the above.

      C Q6. Which of the following property of Array class in C# gets a 32-bit integer, the total number of elements in all the dimensions of the Array? (回傳Array所有維度的個數/32bit-int, Length)

        A. Rank

        B. LongLength

        C. Length (O)

        D. None of the above.

      B Q7. Which of the following property of Array class in C# gets a 64-bit integer, the total number of elements in all the dimensions of the Array? (回傳Array所有維度的個數/64bit-int, LongLength)

        A. Rank

        B. LongLength (O)

        C. Length

        D. None of the above.

      A Q8. Which of the following property of Array class in C# gets the rank (number of dimensions) of the Array? (回傳Array維度數量, Rank)

        A. Rank (O)

        B. LongLength

        C. Length

        D. None of the above.

      D A Q9. Which of the following is true about C# structures? (有關 C# 結構) <== 困難 ==>

        A. Structures can have methods, fields, indexers, properties, operator methods, and events. (O, C# 結構 該有的都有)

        B. Structures can have defined constructors, but not destructors. (O, C# 結構 可以有'定義建構子', 但沒有'預設建構子')

        C. You cannot define a default constructor for a structure. The default constructor is automatically defined and cannot be changed.
          (O, C# 結構 無法定義預設建構子, 因為 C# 結構的 '預設建構子' 由系統自動定義且無法變更)

        D. All of the above. (O)

      D Q10. Which of the following is true about C# structures? (有關 C# 結構) <== 困難 ==>

        A. Unlike classes, structures cannot inherit other structures or classes. (O, C# 結構 不支援繼承)

        B. Structure members cannot be specified as abstract, virtual, or protected. (O, C# 結構成員 無法被指定為抽象, 虛擬 及 保護)

        C. A structure can implement one or more interfaces. (O, C# 結構 可實作 1個或多個介面)

        D. All of the above. (O, 不確定)

      D Q11. Which of the following is true about C# structures vs C# classes? (有關 C# 結構 與 C# 類別 間的差異) <== 常考 ==> <== 困難 ==>

        A. Classes are reference types and structs are value types. (O, C# 類別 是參考型別, C# 結構 是實值型態)

        B. Structures do not support inheritance. (O, C# 結構 不支援繼承, C# 類別 支援繼承, 但不支援多重繼承)

        C. Structures cannot have default constructor (O, C# 結構 沒有預設建構子, C# 類別 有預設建構子)

        D. All of the above. (O)

      D Q12. Which of the following is true about C# enumeration? (有關 C# 列舉)

        A. An enumerated type is declared using the enum keyword. (O)

        B. C# enumerations are value data type. (O, 列舉是實值型別)

        C. Enumeration contains its own values and cannot inherit or cannot pass inheritance. (O, 列舉無法被繼承)

        D. All of the above. (O)

      D Q13. Which of the following is the default access specifier of a class? (C# 類別-預設存取範圍 = Internal, 可以給同一組件DLL內的函式呼叫) <== 常考 ==> <== 困難 ==>

        A. Private

        B. Public

        C. Protected

        D. Internal (O)

      A Q14. Which of the following is the default access specifier of a class member variable? (C# 類別內[成員變數]-預設存取範圍 = Private) <== 常考 ==>

        A. Private (O)

        B. Public

        C. Protected

        D. Internal

      A C Q15. Which of the following is the default access specifier of a class member function? (C# 類別內[成員函式]-預設存取範圍 = Private) <== 常考 ==>

        A. Private (O)

        B. Public (X, 答錯了)

        C. Protected

        D. Internal

      C Q16. Which of the following is the correct about class member functions? (有關於 C# 類別內[成員函式])

        A. A member function of a class is a function that has its definition or its prototype within the class definition similar to any other variable. (O)

        B. It operates on any object of the class of which it is a member, and has access to all the members of a class for that object. (O)

        C. Both of the above. (O)

        D. None of the above.

      C Q17. Which of the following is the correct about class member variables? (有關於 C# 類別內[成員變數])

        A. Member variables are the attributes of an object (from design perspective) and they are kept private to implement encapsulation. (O)

        B. These private variables can only be accessed using the public member functions. (O)

        C. Both of the above. (O)

        D. None of the above.

      C Q18. Which of the following is the correct about class constructor? (有關 C# 建構子, 建構子在新增類別物件時會執行, 沒有回傳值, 與類別同名)

        A. A class constructor is a special member function of a class that is executed whenever we create new objects of that class. (O)

        B. A constructor has exactly the same name as that of class and it does not have any return type. (O, 建構子沒有回傳值)

        C. Both of the above. (O)

        D. None of the above.

      C Q19. Which of the following is the correct about class destructor? (有關 C# 解構子, 解構子在類別物件超出有效範圍時會執行, 沒有回傳值, ~與類別同名, 無法傳入參數)

        A. A destructor is a special member function of a class that is executed whenever an object of its class goes out of scope.

        B. A destructor has exactly the same name as that of the class with a prefixed tilde (~) and it can neither return a value nor can it take any parameters.

        C. Both of the above. (O)

        D. None of the above.

      C Q20. Which of the following is the correct about static member variables of a class? (有關 類別內的static靜態變數) <== 困難 ==>

        A. We can define class members variables as static using the static keyword. (O, 可利用 static 將變數宣告為 靜態變數)

        B. When we declare a member of a class as static, it means no matter how many objects of the class are created, there is only one copy of the static member. 
          (O, 一旦將變數宣告為 靜態變數, 無論有幾個物件, 都只有一份靜態變數, 也就是大家共同使用該 靜態變數)

        C. Both of the above. (O)

        D. None of the above.

      D Q21. Which of the following is the correct about static member functions of a class? (有關 類別內的static靜態函式) <== 困難 ==>

        A. You can also declare a member function as static. (O, 可利用 static 將函式宣告為 靜態函式)

        B. Such functions can access only static variables. (O, 靜態函式 只能存取 靜態變數)

        C. The static functions exist even before the object is created. (O, 靜態函式 在物件產生前即存在了..)

        D. All of the above. (O)

      B A Q22. C# supports multiple inheritance. (C# 不支援多重繼承)

        A. true

        B. false (O)

      A B Q23. C# does not support multiple inheritance. (C# 不支援多重繼承)

        A. true 

        B. false (O)

      補充1: 函式多載 (function overloading) = 同一個方法上有多種定義, 透過 {參數型態} 或 {參數個數} 等方式作區隔.
      補充2: 靜態多形 = 編譯時, 就確定函式的回傳(response).
      補充3: C# 如何支援 靜態多形 (static polymorphism) => 透過 函式多載(function overloading) & 運算子多載(operator overloading) 兩種方式.
      補充4: C# 如何支援 動態多形 (dynamic polymorphism) => 透過 抽象類別(abstract class) & 虛擬函式(virtual function) 兩種方式進行實作.
      
      推論: 函式多載 == 靜態多形 的一種方式
    
      A Q24. Function overloading is a kind of static polymorphism. (X, 函式多載 是一種 靜態多形)

        A. true (O)

        B. false

      補充1: 靜態多形 & 動態多形 的差異在於 
      => 靜態多形: 編譯時, 就確定函式的回傳(response); 
      => 動態多形: 執行時, 才能確定.
      
      B A Q25. Operator overloading is a kind of dynamic polymorphism. (運算子多載 是一種 '靜態多形')

        A. true (O)

        B. false (O, 運算子多載 是一種 靜態多形)

      Question Number 	Answer Key
        1 	D
        2 	D
        3 	D
        4 	A
        5 	B

        6 	C
        7 	B
        8 	A
        9 	D
        10 	D

        11 	D
        12 	D
        13 	D
        14 	A
        15 	A

        16 	C
        17 	C
        18 	C
        19 	C
        20 	C

        21 	D
        22 	B
        23 	A
        24 	A
        25 	B

    4. C# Mock Test IV (OK, 2021/12/07)

      說明: 可多載的運算子
      參考: https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/operator-overloading#overloadable-operators

      註: 動態多形 透過 '抽象類別' & '虛擬函式' 方式實作
      A Q1. Dynamic polymorphism is implemented by abstract classes and virtual functions. <== 困難 ==> <== 觀念不熟 ==>
      
        A. true (O)

        B. false

      <== 困難 ==> <== 觀念不熟 ==>
      A Q2. The comparison operators can be overloaded. 註: 比較運算子(<=, >=, ==, !=, <, >)多載: OK, 但記得成對多載. 例: ==, != 須成對多載 

        A. true (O)

        B. false

      <== 困難 ==> <== 觀念不熟 ==>
      B Q3. The conditional logical operators can be overloaded. 註: 條件邏輯運算子(&&, ||)多載-不行啦

        A. true

        B. false (O)

      <== 困難 ==> <== 觀念不熟 ==>
      A Q4. The assignment operators cannot be overloaded. 註: 指定運算子(=)多載-不行啦

        A. true (O)

        B. false
      
      C Q5. Which of the following is the correct about interfaces in C#? (關於 C#介面)

        A. Interfaces are declared using the interface keyword. (O)

        B. Interface methods are public by default. (O)

        C. Both of the above. (O)

        D. None of the above.

      D Q6. Which of the following is the correct about namespaces in C#? (關於 C# 命名空間)

        A. A namespace is designed for providing a way to keep one set of names separate from another.

        B. The class names declared in one namespace does not conflict with the same class names declared in another.

        C. The using keyword states that the program is using the names in the given namespace.

        D. All of the above. (O)

      A B Q7. You can define one namespace inside another namespace. (關於 C# 命名空間, 可以在命名空間內再定義一個命名空間, 例: System.Text.Json)

        A. true (O)

        B. false (X, 答錯了)

      A Q8. Which of the following preprocessor directive (defines a sequence of characters) as symbol in C#? (關於 前置處理器指示詞 preprocessor directive)

        A. define (O)

        B. undef

        C. region

        D. endregion

      B Q9. Which of the following preprocessor directive allows you to (undefine a symbol) in C#?

        A. define

        B. undef (O)

        C. region

        D. endregion

      C Q10. Which of the following preprocessor directive allows (testing a symbol or symbols to see if they evaluate to true) in C#?

        A. define

        B. undef

        C. if (O)

        D. elif

      D B Q11. Which of the following preprocessor directive allows to (create a compound conditional directive, along with #if) in C#?

        A. define

        B. elif (X)

        C. if

        D. else (O)

      A D Q12. Which of the following preprocessor directive allows (creating a compound conditional directive) in C#?

        A. elif (O)

        B. define

        C. if

        D. else (X)

      B Q13. Which of the following preprocessor directive (specifies the end of a conditional directive) in C#?

        A. elif

        B. endif (O)

        C. if

        D. else

      C Q14. Which of the following preprocessor directive lets you (modify the compiler's line number and (optionally) the file name output for errors and warnings) in C#?

        A. elif

        B. endif

        C. line (O)

        D. region

      D Q15. Which of the following preprocessor directive allows (generating an error from a specific location in your code) in C#?

        A. define

        B. region

        C. line

        D. error (O)

      A Q16. Which of the following preprocessor directive allows (generating a level one warning from a specific location in your code) in C#?

        A. warning (O)

        B. region

        C. line

        D. error

      B Q17. Which of the following preprocessor directive lets you (specify a block of code that you can expand or collapse when using the outlining feature of the Visual Studio Code Editor) in C#?

        A. warning

        B. region (O)

        C. line

        D. error

      C Q18. Which of the following preprocessor directive (marks the end of a #region block) in C#?

        A. warning

        B. region

        C. endregion (O)

        D. error

      C Q19. Which of the following is true about try block in C#? (有關 try 區塊)

        A. A try block identifies a block of code for which particular exceptions is activated. (O)

        B. It is followed by one or more catch blocks. (O)

        C. Both of the above. (O)

        D. None of the above.

      C Q20. Which of the following is true about catch block in C#? (有關 catch 區塊)

        A. A program catches an exception with an exception handler at the place in a program where you want to handle the problem.

        B. The catch keyword indicates the catching of an exception.

        C. Both of the above.

        D. None of the above.

      A Q21. The finally block is used to execute a given set of statements, whether an exception is thrown or not thrown. (有關 finally 區塊)

        A. true (O)

        B. false

      C Q22. Which of the following is true about exceptions in C#? (有關 exceptions 例外)

        A. The exception classes in C# are mainly directly or indirectly derived from the System.Exception class. (O)

        B. C# exceptions are represented by classes. (O)

        C. Both of the above. (O)

        D. None of the above.

      C A Q23. Which of the following is true about System.ApplicationException class in C#? (有關 System.ApplicationException 類別)

        A. The System.ApplicationException class supports exceptions generated by application programs. (O, System.ApplicationException支援應用程式產生的例外)

        B. Exceptions defined by the programmers should derive from this class. (O, 程式員自訂例外都應該繼承自System.ApplicationException)

        C. Both of the above. (O)

        D. None of the above.

        補充: 設計「例外狀況」時的重要指南
        參考: https://docs.microsoft.com/zh-tw/dotnet/standard/design-guidelines/exceptions
          1. 例外狀況擲回
          2. 使用標準例外狀況類型
          3. 例外狀況和效能

      A B Q24. The System.SystemException class is the base class for all predefined system exception in C#?

        A. true (O, System.SystemException 是所有預先定義例外的基底類別)

        B. false (X, 答錯了)

      A B Q25. User-defined exception classes are derived from the ApplicationException class in C#?

        A. true (O, 程式員自訂例外都應該繼承自System.ApplicationException)

        B. false (X, 答錯了)

      Question Number 	Answer Key
        1 	A
        2 	A
        3 	B
        4 	A
        5 	C
        
        6 	D
        7 	A
        8 	A
        9 	B
        10 	C
        
        11 	D
        12 	A
        13 	B
        14 	C
        15 	D
        
        16 	A
        17 	B
        18 	C
        19 	C
        20 	C
        
        21 	A
        22 	C
        23 	C
        24 	A
        25 	A

/* WPF 次代windows form */
  2022/01/29 
    問題: 使用VS2022 新增 WPF專案, 竟然出 "專案不知道如何執行設定檔" 的錯誤訊息.
    原因: WPF應用程式 有兩種, (1)WPF應用程式 & (2)WPF應用程式(.NET Framework), 
          如果在Windows7上面執行要挑選第(2)種, 架構 based on .NET Framework 4.7.2
          如果挑第(1)種, 架構 based on .NET 5.0 or .NET 6.0 <= 這是微軟新架構, 由 .net core 發展而來的

    重點: 
      1. <如何配置UI>, 
            利用XAML檔設定 <Grid></Grid> 畫出最外面容器, 它就像個表格. 
            畫面內有幾個ROW & 幾個COLUMN, 邊界, ROW高度, COLUMN寬度..等屬性都在這設定.
            它會依據裝置大小自動調整, 概念像是CSS
      
      2. <加入控制項 & 位置>, 
            在新增控制項上設定位置屬性, 若省略不設定, 表示預設值為0, 控制項會放在第0個ROW, 第0個COLUMN裡面
            <Label>FirstName</Label> <!--控制項會放在 第0個ROW, 第0個COLUMN-->
            <Label Grid.Column="1">Name1</Label> <!--控制項會放在 第0個ROW, 第1個COLUMN-->
      
      3. <給定邊界屬性值>, 
            Margin="0,0,0,0", 順序是 {左、上、右、下}.
            Margin="0", 該值套用全部
  
  學習資源(WPF): 從這裡開始
    https://docs.microsoft.com/zh-tw/dotnet/desktop/wpf/windows/?view=netdesktop-6.0
  
    2022/01/30 
      視窗類別(使用者看到的UI)
        WPF的視窗分為兩個區域︰非工作區和工作區。
          視窗的 <非工作區> 是由 WPF 所執行，並且包含大部分視窗通用之視窗的部分，包括下列各項：

              標題列 (1-5) 。
              圖示 (1) 。
              標題 (2) 。
              最小化 (3) 、最大化 (4) ，以及關閉 (5) 按鈕。
              系統功能表 (6) 與功能表項目。 按一下圖示 (1) 時顯示。
              框線 (7) 。

          視窗的 <工作區> 是視窗非工作區內的區域，開發人員會使用此區域來新增應用程式特定的內容，例如功能表列、工具列和控制項。

              用戶端區域 (8) 。
              調整大小底框 (9) 。 這是新增至工作區 (8) 的控制項。 <==特別, 沒想到此控制項是在<工作區>控制

      實作視窗(程式員主要工作處, 寫程式碼或設定都在這裡)
        其中有XAML標記視窗, 它會和 "視窗類別(使用者看到的UI)" 內容同步
        另外有C#視窗, 稱之為後端程式碼

      視窗類別(使用者看到的UI) & 實作視窗(程式員主要工作處) 建立關聯
        結論: 利用VS開發工具產生的專案, 關聯性會由工具自動建立完成, 不用擔心.
        說明:
          1. XAML標記視窗, Window 元素必須包含 x:Class 屬性。 
              建立應用程式時，屬性的存在 x:Class 會導致 Microsoft build engine (MSBuild) 產生 partial 衍生自屬性所指定之名稱的類別 Windowx:Class 。 
              這需要加入 XAML 架構 () 的 XML 命名空間宣告 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 。 
              產生的 partial 類別會執行 InitializeComponent 方法，該方法會呼叫以註冊事件並設定在標記中所執行的屬性。
          2. C#視窗, 類別必須是 partial 標記中的屬性所指定之相同名稱的類別 x:Class ，而且必須衍生自 Window 。 
              這可讓程式碼後置檔案與 partial 建立應用程式時為標記檔案產生的類別相關聯。
          3. C#視窗, Window 類別必須執行呼叫方法的函式 InitializeComponent 。 
              InitializeComponent 由標記檔案的產生類別所執行， partial 以註冊事件並設定在標記中定義的屬性。
        程式碼範例:
          # XAML標記 #
            <Window x:Class="WindowsOverview.Window1" <!-- 重點1 -->
                    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" <!-- 重點2 -->
                    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
                    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
                    xmlns:local="clr-namespace:WindowsOverview"
                    >
                <!-- Client area containing the content of the window -->
                <Button Click="Button_Click">Click This Button</Button>            
            </Window>
          
          # C#程式碼 #
            using System.Windows;
            namespace WindowsOverview
            {
              public partial class Window1 : Window //重點1: 相同類別名稱, 必須衍生自 Window 後, 之間建立關聯
              {
                  public Window1()
                  {
                      InitializeComponent();
                  }

                  private void Button_Click(object sender, RoutedEventArgs e)
                  {
                      MessageBox.Show("Button was clicked.");
                  }
              }
            }

      設定MSBuild 視窗(MSBuild 是編譯工具, 會根據<你的專案設定檔>來產生應用程式)
        
        (規範)針對使用 XAML 標記和程式碼後端所定義的視窗：
          1. XAML 標記檔會設定為 MSBuild Page 專案。
          2. 程式碼後端檔案會設定為 MSBuild Compile 專案。

        1. (WPF專案)
        2. (MSBuild專案, 猜測可能是WinForm專案, 舊架構)

          <!--以下專案檔內必須有的設定, WPF專案會自動產生, MSBuild專案則自行宣告-->
          <Project>
              ...
              <Page Include="MarkupAndCodeBehindWindow.xaml" />
              <Compile Include=" MarkupAndCodeBehindWindow.xaml.cs" />
              ...
          </Project>
    2022/01/31
      視窗的生命週期
        [ShowActivated = true]
          1. SourceInitiated
          2. Activated (被啟用)
          3. Loaded (被載入)
          ---------------------
          4. ContentRendered (如果視窗有內容的話)
          5.0 Deactivated (非啟用, 如果視窗被使用者移至旁邊), 通常狀態會有 5.0 <--> 5.1 間不斷地切換
            5.1 Activated (被啟用, 如果視窗被使用者 '使用中')
          ---------------------
          6. Closing (被關閉, 如果視窗被使用者關閉, 注意: 這時還能詢問使用者是否取消關閉..)
          7. Deactivated (非啟用)
          8. Closed (關閉)

        [ShowActivated = false]
          1. SourceInitiated
          2. Activated (被啟用) <==此步驟沒有, 因為設定限制==>
          3. Loaded (被載入)
          ---------------------
          4. ContentRendered (如果視窗有內容的話)
          5.0 Deactivated (非啟用, 如果視窗被使用者移至旁邊), 通常狀態會有 5.0 <--> 5.1 間不斷地切換
            5.1 Activated (被啟用, 如果視窗被使用者 '使用中')
          ---------------------
          6. Closing (被關閉, 如果視窗被使用者關閉, 注意: 這時還能詢問使用者是否取消關閉..)
          7. Deactivated (非啟用)
          8. Closed (關閉)

      視窗位置
        1. 由 Left = X , Top = Y 決定桌面上的相對位置
        2. 視窗初始位置可利用 'WindowStartupLocation' 屬性作設定
          ex. WindowStartupLocation = CenterOwner(default) , CenterScreen, Manual
          註. 若設定為Manual, 但 X & Y 未設定, 則會詢問OS位置
        3. Topmost windows and z-order, 就是指視窗是否 Activated or Deactivated, 相對於其他視窗的上下位置
          3.1 z-order有兩種類型, (1)normal z-order & (2)topmost z-order
          3.2 topmost z-order值可以決定是 它現在是否為 Activated 視窗
      
    2022/02/01
      視窗尺寸(Window size)

/*== Visual Studio 開發工具  ==*/

  <Visual Studio, 如何決定程式專案使用的SDK版本>
    1. "加入新的專案時" 最上面可決定 ".NET Framework 4.5..."
    2. 如果要增加可用 "SDK版本", 須透過<其他 Framework> 另外安裝.
      https://dotnet.microsoft.com/en-us/download/visual-studio-sdks?utm_source=getdotnetsdk&utm_medium=referral

  <VisualStudio 變更程式名稱>
    1. 專案 > 屬性 > 應用程式 Tab > 修改 "組件名稱" & "預設命名空間" 即可.
    2. 建置 > 發行, 選擇儲存位置(CD/DVD), 自動輸出為安裝檔.
    註: 不用去改程式碼內的命名空間, namespace WindowsFormsApplication3

  <VisualStudio 啟始專案 屬性>
    0. 啟始專案 = 按下開始時, 會執行哪個專案程式.
    1. 如果同一方案內, 有多個專案時, 可以設定 "方案的預設啟始專案" 屬性 , 偵錯起來比較方便
    2. 方案 > 屬性 > 通用屬性 > 啟動專案 > 目前的選取範圍

  <VisualStudio 預設程式進入點> => Program.cs 程式檔內
    Program.cs //應用程式的預設主要進入點
      namespace WindowsFormsApplication2
      {
          static class Program
          {
              //<summary>
              //應用程式的主要進入點。
              //</summary>
              //[STAThread]
              //static void Main()
              //{
              //    Application.EnableVisualStyles();
              //    Application.SetCompatibleTextRenderingDefault(false);
              //    Application.Run(new Form1());
              //}
          }
      }

    Form1.cs //若要在Form1.cs另外產生程式進入點 & 並使用手動CSC編譯
      namespace WindowsFormsApplication2
      {
          public partial class Form1 : Form
          {
              public Form1()
              {
                  //這裡要註解起來..否則使用csc作手動編譯會出現, error CS0103: 名稱 'InitializeComponent' 不存在於目前內容中.
                  //InitializeComponent(); //頁面元件初始化
              }
          }
      }

      public class Form1 : Form
      {
          private DataGridView dataGridView1 = new DataGridView();
          private BindingSource bindingSource1 = new BindingSource();
          private SqlDataAdapter dataAdapter = new SqlDataAdapter();
          private Button reloadButton = new Button();
          private Button submitButton = new Button();

          //自行新增的程式進入點
          [STAThread]
          public static void Main()
          {
              Application.Run(new Form1());
          }

          // Initialize the form.
          public Form1()
          {              
              dataGridView1.Dock = DockStyle.Fill; //填滿父容器
          }
      }

  <VisualStudio 程式碼 - 快速自動排版>
    [Ctrl+K] + [Ctrl+D]

  <VisualStudio 程式碼 - 收合全部>
    [Ctrl+M] + [Ctrl+O]

  <VisualStudio 程式碼 - 收合單一函式>
    [Ctrl+M] + [Ctrl+M]

  <VisualStudio 程式碼 - 1次全開 / 全關>
    [Ctrl+A] => 全選 + [Ctrl+M] + [Ctrl+M]
  
  <VisualStudio 使用GIT 版本管理軟體>
    
    0. 建立Git倉儲, (VS2013)加入原始檔控制, 必須在<方案>上點右選, 無法在<專案>上加入.

    a. GIT記錄檔案快照, 而非差異. 有別於他類版本管理系統.
      b. 大部分的操作可在本地端完成. 因為所有歷史資料都在本機.
      c. Git能檢查檔案完整性 + 通常只增加資料
      d. 三種狀態(Modified, Staged, Committed)
        Modified => Working Folder
        Staged => Staging Area
        Committed => Git Directory(Repository)儲存庫 = Git目錄
        基本工作流程:
          1. 檔案簽出, 在 Working Folder 內修改檔案.
          2. 檔案預存, 將檔案快照存至 Staging Area.
          3. 檔案提交(Commit), 將Staging Area 內的檔案快照永久儲存至 Git目錄
      e. 設定GIT
        1. 下載 https://git-scm.com/downloads & 安裝
        
        2. 設定識別資料(姓名 & email)
          git config --global user.name "KL"
          git config --global user.email "oliver_cheng@sheico.com.tw"
          註: 針對特定專案指定不同名稱時, 請拿掉 --global, 並在專案目錄內執行.
        
        3. 指定編輯器(NotePad or VSCode)
          git config --global core.editor "'D:\VSCode\Code.exe' -multiInst -nosession"
        
        4. 檢查設定結果
          git config --list
          git config user.name
        
        5. 查詢說明文件
          git help <verb> ex. git help config
          git <verb> --help
