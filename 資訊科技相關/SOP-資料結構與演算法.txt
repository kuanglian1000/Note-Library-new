資料結構與演算法 for 2023-09-15 台北保發中心(2023-09-21 上午0930)面試前準備
(參考資料來源：https://ithelp.ithome.com.tw/users/20121027/ironman/4552?page=1
  2021鐵人賽-資料結構與演算法，使用JavaScript與Python) 


Day28:[演算法]-桶排序法Bucket Sort 
  (1)桶排序法(Bucket Sort)，與前面幾篇的排序法不一樣，
    前面都是經由兩兩互相比較而成的排序，稱為比較排序法，
    而桶排序是非比較排序，屬於「分配性」的排序。
  (2)原理是先準備幾個桶子，每個桶子都是有限的固定區間，再將待排序的資料分配到對應區間的桶子中，
    接著每個桶再個別排序（可以使用別的排序演算法），
  (3)最後再依序收集排序好的資料。
  (4)如果記憶體更大的話, 可以使用增加桶子的數量來降低區間，
    這樣將可以減少排序的次數，所以桶排序是一種可以用空間來換時間的排序法。
  (5)操作流程:
    1.設定定量的空桶子
    2.走訪原始資料並分配到對應桶子中
    3.對每個不是空的桶子進行排序
    4.依序從不是空的桶子中，把排序好資料收集回來

// 其餘參數(...)
  const array1 = [1, 3, 2];
  console.log(Math.max(...array1)); 
  //...如果函式的最後一個命名參數以 ... 開頭，它會被視為一個陣列。

  // Expected output: 3

  function f(a, b, ...theArgs) {
    // ...
  }
  // ... 其餘參數（rest parameter） 語法可以讓我們表示不確定數量的參數，
  // 並將其視為一個陣列。

//從類陣列物件（arguments）產生陣列: Array.from 
  // 使用箭頭函式作為 map 函式來
  // 操作元素
  Array.from([1, 2, 3], (x) => x + x);
  // [2, 4, 6]

  // 產生數值序列
  // 因為陣列中的每個位置都會被初始化為 `undefined`，
  // 下方 `v` 會是 `undefined`
  Array.from({ length: 5 }, (v, i) => i);
  // [0, 1, 2, 3, 4]


Day27:[演算法]-堆積排序法 Heap Sort 
  (1)堆積排序法(Heap Sort)原理是利用「堆積」的資料結構為基礎來完成排序。
  (2)操作流程(最大堆積為例):
    1.將陣列轉換最大堆積(Max Heap)
    2.將Root與最後一個節點交換
    3.將最後一個節點移除
    4.將剩餘為排序完的節點重複1~3步驟，直到所有節點被移除，即完成排序。
  (3)平均時間複雜度為: O(n log n) <== 效率極佳 ==>
    時間複雜度 = 建立堆積 + 移除堆積
    Ο(n log n) = Ο(n) + Ο(n log n) 

Day26:[演算法]-快速排序法Quick Sort 
  (1)快速排序法(Quick Sort)又稱分割交換排序法，
    是目前公認效率極佳的演算法，
    使用了分治法(Divide and Conquer)的概念。
  (2)原理是先從原始資料列中找一個基準值(Pivot)，
    接著逐一將資料與基準值比較，
    小於基準值的資料放在左邊，大於基準值的資料放在右邊，
    再將兩邊區塊分別再找出基準值，重複前面的步驟，直到排序完為止。
  (3)平均時間複雜度為: O(n log n) <== 效率極佳 ==>

  (4)實作方式: 
    a.遞迴版本
    b.原地交換版本(In-Place)-Lomuto partition scheme
      基於Lomuto partition scheme的原理，原始資料列使用一個指標與索引，當索引的資料小於Pivot時，索引的資料與指標位置資料交換。
      操作流程:
        1.資料列最後一筆設定為基準值(Pivot)
        2.設定一個指標指向資料列第一筆，用來記錄小於Pivot的資料位置
        3.逐一與Pivot比較
        4.若當前資料小於Pivot，就將該資料與指標位置的資料做交換，接著指標往下一個位置移動
        5.若當前資料大於等於Pivot，則跳過不做任何動作
        6.當所有資料比較過後，再將Pivot與指標位置的資料交換
        7.左右兩邊資料列分別重複1~6步驟，直到剩下1筆分割交換完成，不須合併

    c.原地交換版本(In-Place)-Hoare partition scheme
      基於Hoare partition scheme的原理，將原始資料列使用兩個指標，從資料列的兩端開始相互移動，直到它們相遇或反轉為止。
      操作流程:
        1.資料列中找出一個基準值(Pivot)
        2.最左邊有一個指標(Pointer) L，最右邊也有一個指標(Pointer) R
        3.L逐一往右移動直到找到大於Pivot停下來
        4.R逐一往左移動直到找到小於Pivot停下來
        5.L與R的資料互相交換，L與R繼續移動
        6.L與R重疊時，重疊位置的資料Pivot互相交換
        7.L與R反轉時，R位置的資料與Pivot互相交換
        8.基準值的左右兩邊資料分別重複1~7步驟，直到剩下1筆分割交換完成，不須合併

Day25:[演算法]-合併排序法Merge Sort 
  (1)合併排序法(Merge Sort)原理是會先將原始資料分割成兩個資料列，
  接著再將兩個資料繼續分割成兩個資料列，依此類推，
  直到無法再分割，也就是每組都只剩下一筆資料時，再兩兩合併各組資料，
  合併時也會進行該組排序，每次排序都是比較最左邊的資料，將較小的資料加到新的資料列中，依此類推，
  直到最後合併成一個排序好的資料列為止。
  (2)平均時間複雜度為: O(n log n) <== 效率極佳 ==>

Day24:[演算法]-希爾排序法Shell Sort 
  希爾排序法(Shell Sort)是插入排序(Insertion Sort)的改良版。
  可減少插入排序的資料搬移次數，加入了間距(Gap)的概念將資料分成多個小區塊，
  再將不同區塊資料進行插入排序，每一回合Gap會漸漸減少，最後一回Gap會是1。

  操作流程:
    (1)由大到小制定數個間距(Gap)，最後一次的Gap一定要是1
    (2)將資料依制定的間距(Gap)分組
    (3)每組進行插入排序
    (4)重複上述步驟，不斷減少Gap，直到最後一次Gap是1完成為止。

  間距(Gap)的選擇:
    發明人D.L Shell原先的Gap選擇為:N/2、N/4、...1(反覆除以2)

Day23: [演算法]-插入排序法Insertion Sort 
  (1)插入排序法(Insertion Sort)，原理是逐一將原始資料加入已排序好資料中，
    並逐一與已排序好的資料作比較，找到對的位置插入。
  (2)例如:已有2筆排序好資料，將第3筆資料與前面已排序好的2筆資料作比較，找到對的位置插入，
    接續從第4筆資料與前面已排序好的3筆資料作比較，找到對的位置插入，以此類推。
  (3)[注意]: 
      a.若交換(插入)成功, 比較值要更新為新值.(插入排序跟氣泡排序其實很像..)
      
Day22: [演算法]-選擇排序法Selection Sort 
  (1)選擇排序法(Selection Sort)，原理是反覆從未排序數列中找出最小值，將它與最左邊的數做交換。
  (2)可以有兩種方式排序，一為由大到小排序時，將最小值放到末端;若由小到大排序時，則將最小值放到前端。

  (3)[注意]: 
        最左邊的數會向右移動, 因為前端資料已排序完成, 就不再排序
  
  (4)例如:未排序的數列中找到最小值的資料，和第1筆資料交換位置，
      再從剩下未排序的資料列中找到最小值的資料，和第2筆資料交換位置，以此類推。

Day21: [演算法]-氣泡排序法(Bubble Sort)
  氣泡排序法(Bubble Sort)又稱交換排序法，
  (1)原理是從第一筆資料開始，逐一比較相鄰兩筆資料，如果兩筆大小順序有誤則做交換，反之則不動，接者再進行下一筆資料比較，
  (2)所有資料比較完第1回合後，可以確保最後一筆資料是正確的位置。
  (3)再進行下一回合
  (4)[注意]: 
        比較結束索引可以往前1位, 因為最後一筆資料是正確的, 不用再比較了.

  C:\Projects\Projects_NodeJS\DataStructure_Algorism\Algro_Bubblesort.js

Day8: [資料結構]-佇列Queue-實作 
  C:\Projects\Projects_NodeJS\DataTypeQueue.js
  
  佇列Queue建立的方法
    enqueue: 新增元素
    dequeue: 從(前端)移除元素
    peek: 查看頂端(top)元素
    size: 查看此堆疊的元素量

Day7: [資料結構]-佇列Queue
  # 佇列(Queue)也是一種排列結構，佇列在新增與刪除資料必須在不同端進行，
    > 前端(front)能夠刪除(dequeue)與查看(peek)資料，
    > 尾端(Rear)只能新增(enqueue)資料，(加資料)
    > 因此有「先進先出」(First In First Out)特性，縮寫為FIFO。
  # 應用場景:
    > 排隊
    > CPU的工作排程，印表機的工作排序，網路伺服器傳輸
  # 常見製作佇列(Queue)的方式
    (1) 使用陣列(Array)製作佇列
    (2) 使用鏈結串列(Linked List)製作佇列

Day6: [資料結構]-堆疊Stack-實作 
  C:\Projects\Projects_NodeJS\DataTypeStack.js

  堆疊(Stack)建立的方法
    push: 新增元素
    pop: 從頂端移除元素
    peek: 查看頂端(top)元素
    size: 查看此堆疊的元素量

Day5: [資料結構]-堆疊Stack 
  # 堆疊(Stack)是一種排列結構，不過是由下往上堆放，任何動作都必須從最頂端(top)進行，因此有「後進先出」(Last In First Out)特性，縮寫為LIFO。
  # 應用場景:
    > 回到上一頁: 最先瀏覽的頁面，會在點擊最後一次此按鈕時才出現。
    > 還原: 最先被記錄的動作，會在點擊最後一次此按鈕時才被還原。
  # 常見製作堆疊(Stack)的方式
    (1) 使用陣列(Array)製作堆疊
    (2) 使用鏈結串列(Linked List)製作堆疊

Day4: [資料結構]-鏈結串列Linked List-實作
  鏈結串列(Linked List)建立的方法
    append: 在尾部新增節點
    insertAt: 在特定位置插入節點
    removeAt: 刪除特定位置節點
    remove: 刪除特定資料節點
    indexOf: 回傳第一個出現指定資料的節點位置，空值則回傳-1
    isEmpty: 確認是否為空串列
    size: 串列的長度
    print: 印出串列所有資料

Day3: [資料結構]-鏈結串列Linked List 
  #不連續記憶體空間 #隨機儲存 # 較不會造成記憶體浪

  定義: 由許多節點組成，每個節點包含資料欄與指標欄，指標欄會指向下一個資料所在的記憶體位置。
  優: (追加或刪除資料 => 快)，因為只需要更動指標的指向，
  缺: (讀取資料 => 慢)，因為必須從串列的頭開始尋找。

  類型: 
    (0)單向鏈結串列Singly Linked List
    (1)雙向鏈結串列Doubly Linked List
    (2)環狀鏈結串列 Circular Linked List

Day2: [資料結構]-陣列(Array) 
  #連續記憶體空間 #固定記憶體空間 #存取快速 #異動耗時

  陣列(Array)是一種常見的資料結構，常用來(處理相同類型的有序資料)，並存放在(連續的記憶體空間)中。
  但由於會先宣告固定記憶體空間，(容易造成記憶體浪費)。

  優: (讀取與修改資料 => 快)，因為可以透過索引值index快速找到要的資料位置，
  缺: (追加或刪除資料 => 慢)。

  Python:
    NumPy是Python的一個套件，大部分人會使用它來運用Array資料型態，
    與內建的List相比，List在記憶體中儲存的方式有很大的差異。
    List的每個資料可以是不同的資料型別，
    因此這些資料在記憶體中的儲存位置是很難以預測的。
    而Array規定每一個資料都必須有相同的資料型別，它們在記憶體上的儲存位置會完全排在一起，因此Array的存取速度會比List快。

  JavaScript Code:
    C:\Projects\Projects_NodeJS\DataTypeArray.js

Day1: 資料結構 + 演算法 概論

  資料結構
    選擇適當的資料結構能夠提高演算法的效率。

  演算法
    演算法被定義為一個可以用來解決某一問題的方法或算法。
    Donald Ervin Knuth提出了演算法必須具備的五個特性:
      輸入(Input):0個或是1以上的輸入。
      輸出(Output):至少有一個輸出結果。
      明確性(Definiteness):每個步驟或指令必須是明確的而不含糊的。
      有限性(Finiteness):在有限的步驟後一定會結束，不會有無窮迴圈。
      有效性(Effectiveness):每個步驟清楚具有可行性，能用紙筆來表達。

  複雜度
    複雜度可以用來衡量演算法的效率，又分為時間複雜度(Time Complexity)與空間複雜度(Space Complexity)，通常會用Big O來表示。
      關於時間複雜度(Time Complexity)

      可以說電腦執行演算法所花費的時間成本。花費的時間並非以秒為單位計算，是以(執行的次數)來做計算。
      
      關於空間複雜度(Space Complexity)

      可以說是電腦執行演算法所(需要耗費的記憶體空間)。

    而時間複雜度和空間複雜度兩者是可以互相trade off的。
      例: 可以時間(多算幾次)換取空間(記憶體不足)

  常見的Big O又分為下面幾種

      O(1):常數時間，不管你輸入多少資料，執行時間不變。
      O(n):線性時間，執行時間會隨著輸入多少資料 n 等比例增加。
      O(n²):平方時間，執行時間會成二次方成長。
      O(2^n):指數時間，執行時間會成2的n次方成長，效能較差，盡可能避免。
      O(log n):對數時間，log 8 = 3，也就是8 = 2³，執行時間一開始增加，到一定程度後無明顯增加。
      O(n log n):線性對數時間，介於線性與平方之間。
