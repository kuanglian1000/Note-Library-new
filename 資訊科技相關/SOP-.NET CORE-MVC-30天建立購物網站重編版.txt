<從實作學習ASP.NET Core - 30天的購物網站>
參考來源：https://ithelp.ithome.com.tw/articles/10258872

專案路徑：C:\Projects\Projects_ASP.NET_Core\MvcShopping
Day1-Create the WebSite(建立網站雛形)

  dotnet new mvc -o MvcShopping # 新增MVC架構網站
  dotnet build  # 編譯測試

  dotnet dev-certs https #產生測試環境簽章(https用), message => The HTTPS developer certificate was generated successfully.
  dotnet dev-certs https --trust #信任測試環境簽章(https用) message => A valid HTTPS certificate is already present.

  dotnet run    # 啟動網站, http://localhost:5210

  本日完工

Day2-Mvc Structure(MVC架構簡介)

  (1)Model：負責資料存儲，處理資料與資料庫之間的操作
  (2)View：負責前端畫面與邏輯顯示，就是使用者會看到的介面
  (3)Controller：負責商業邏輯處理，管控流程和回應，並以路由傳遞資料
  
  順序: User -> (3) by 路由規則 -> (1) connect to DB -> DB -> (1) fetch data from DB -> (3) data processing & put to view -> (2) return Layout & Data to User -> User

  Project Directory - 專案資料夾結構
    (1)Controllers、Models、Views 資料夾：我們程式的主角
    (2)appsettings.json：儲存環境變數的地方，例如資料庫連接字串
    (3)Startup.cs：程式的組態檔，服務需要從這邊註冊  #.NET 6.0後被合併到 <Program.cs> #
    (4)Program.cs：程式的起始點

  本日完工

Day3-Mvc Controller(控制器-詳細說明)

  可參考官網說明(如何新增控制器) => https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/adding-controller?view=aspnetcore-5.0&tabs=visual-studio
  
  路由
    (1)網址規則定義, Default URL path => https://<Your HostName:port>/<Controller Name>/<Action Name>
    (2)預設 <Action Name = Index>, 即是不輸入 <Action Name>時, 則自動導向 控制器的Index()

  {完全手動} 新增控制器
    FilePath = /Controllers/HelloWorldController.cs
    可參考 HomeController.cs 的內容

  傳遞參數給控制器
    (1)在HelloWorldController內, 新增一個Action為(Welcome)
    (2)Action可接收參數為(Name), 並回傳接收的參數值.
        public string Welcome(string? Name)
        {
          return $"Your Name is {Name}";
        }
      
      在路由規則未新增的情況下, 要寫成這樣, 才會正常顯示
        (O)https://localhost:7231/Helloworld/Welcome?Name=KL
        (X)https://localhost:7231/Helloworld/Welcome?KL
        (X)https://localhost:7231/Helloworld/Welcome/KL

  本日完工

Day4-Mvc View(視圖-詳細說明)

  可參考官網說明(如何新增視圖) => https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/adding-view?view=aspnetcore-5.0&tabs=visual-studio

  {完全手動} 新增視圖
    (1)把HelloWorldController內, Index() Action 回傳型態 string 改為 IActionResult.
    (2)Index() Action方法內, 則回傳 View(). (註: MVC自己會去找 /Views/HelloWorld/Index.cshtml, 加入資料包好後回傳給User)
    (3)在路徑 /Views/HelloWorld 下, 新增 Index.cshtml
    (4)在檔案 Index.cshtml 中, 加入下列程式碼

      @{
        ViewData["Title"] = "Index";
      }

      <h2>Index</h2>
      <p>This is our Default View of HelloWorld Controller</p>
      <p>這是我們的HelloWorld控制器的預設檢視</p>
  
  ViewData & ViewBag(傳遞參數用的載具, 後端傳至前端)
    (1)適合在頁面有需要顯示後端資料的時候使用.
    (2)生命週期只有一個頁面，當前端把數值載入完後就會自動消失了.
    (3)前端取值時, @ 要特別加註上去, 這是RazorPage的寫法.
    
    (4)使用方式 (程式範例: C:\Projects\Projects_ASP.NET_Core\MvcShopping\Views\HelloWorld\Index.cshtml)

      # 特別注意: ViewData 和 ViewBag是互通的, 只是寫法不同 #
        ViewData["CategoryId"] = "ABC"; //可用 ViewData 存值
        Console.WriteLine(ViewBag.CategoryId); //再用 ViewBag 取值

      {後端給值}
        a. ViewData["data_Index"] = data_Value; // ViewData["XXX"]
        b. ViewBag.data_Index = data_Value; // ViewBag.XXX
      
      {前端取值}
        c. @{
            ViewData["Title"] = "Index"; //前端給值, 它要給共用外框標題名稱值
          }
          <h2>Index</h2>
          <p>This is our Default View !</p> 
          <p>@ViewData["mystring1"]</p> 
          <p>@ViewBag.mystring2</p>     

  本日完工

Day5-Mvc Model(模型-詳細說明)

  可參考官網說明(如何新增模型) => https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/adding-model?view=aspnetcore-5.0&tabs=visual-studio

  服用 " <命令列環境>下使用 <dotnet aspnet-codegenerator> 工具的前置作業 "

    (1) <dotnet aspnet-codegenerator> & <dotnet-ef> 兩種工具已安裝
    (2) 安裝套件至專案中
        # <程式碼自動產生> 套件 加入專案內 #
          dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 6.0.10
        # <資料庫結構(Schema)自動產生> 套件 加入專案內 #
          dotnet add package Microsoft.EntityFrameworkCore.Design
          dotnet add package Microsoft.EntityFrameworkCore.SQLite
          dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 6.0.10
          dotnet add package Microsoft.EntityFrameworkCore.Tools --version 6.0.10
  
  {Code First} 三步驟
    # 參考作法: C:\Users\p10154383\Documents\個人資料夾\筆記-圖書館-new\資訊科技相關\SOP-.NET CORE.txt
    # 範例1: 使用 資料模型(Data/Model)的超完整範例

      (1) 建立模型(Create Model by Hand)

        # 先來{簡易版} #
          * 資料模型(Data/Model): "Product.cs"
          
          using System;
          using System.Collections.Generic;

          namespace MvcShopping.Models;

          public class Product
          {
              public int Id {get;set;} //系統指定ID, 無法變更
              public string? ProductName {get;set;}
              public decimal Price {get;set;}
              public int Stock {get;set;}
          }

        # 再上{複雜版} #
          Product資料表(新增欄位 + 與Category建立關聯) => 程式路徑: Models\Product.cs
            
            using System;
            using System.Collections.Generic;

            namespace MvcShopping.Models;

            public class Product
            {
              public int Id { get; set; }

              public string? Name { get; set; }            //商品名稱
              public string? Description { get; set; }     //商品簡介
              public string? Content { get; set; }         //商品內容
              public int Price { get; set; }              //商品價格
              public int Stock { get; set; }              //商品庫存
              
              public byte[] Image { get; set; }           //商品圖片
              public int CategoryId { get; set; }         //類別 (Foreign Key)
              public Category Category { get; set; }
            }

          Category資料表(新增資料表 + 與Product建立關聯) => 程式路徑: Models\Category.cs
            
            using System;
            using System.Collections.Generic;

            namespace MvcShopping.Models;

            public class Category
            {
              public int Id { get; set; }
              public string? Name { get; set; }            //類別名稱
              public List<Product> Products { get; set; } 
            }
      
      (2) 用 <Scaffold> 工具, 建立商品 CRUD 頁面及相關程式碼
          利用 Model & <aspnet-codegenerator> 工具, 完成 Controller, View, DbContext, ConnectionString新增, Database服務註冊.
          dotnet aspnet-codegenerator controller 
            -m Product -name ProductsController  -dc StoreContext 
            -outDir Controllers -sqlite -scripts -udl

          # 兩個模型一起上{複雜版}  #
            (Test1: Product先執行, 再執行Category, 先開Product頁面, 後開Category頁面, 沒反應, 無法新增)
            
            $ 這種方式是可行的(先各自新增, 之後再串起關聯性.) $
            (Test2: 執行Product Scaffold {Product & Category關聯都先拿掉}, 再執行{第1次移轉}+{產生資料庫DB}, 
                      網站功能測試 => Product 新增OK;
                    執行Category Scaffold {Product & Category關聯都先拿掉}, 再執行{第2次移轉}+{異動資料庫DB}, 
                      網站功能測試 => Product 新增OK; Category 新增OK )

            dotnet aspnet-codegenerator controller -m Category -name CategoriesController  -dc StoreContext -outDir Controllers -sqlite -scripts -udl
            dotnet aspnet-codegenerator controller -m Product -name ProductsController  -dc StoreContext -outDir Controllers -sqlite -scripts -udl
        
      (3) 利用 <EntityFrameworkCore> 工具 + 新增 資料庫移轉記錄(Migrations) + 產生資料庫DB
          > drop and re-create(快速, 適用於開發環境, 直上Table Schema & 最新Data)
          * Delete the Migrations folder. 
          
            dotnet ef database drop --force
            dotnet ef migrations add InitialCreate (註: 依照慣例, 第1次移轉的取名為 InitialCreate; 之後可以改為 add Column_Desc..)
            dotnet ef database update (註: 使用最近1次移轉, 執行移轉內的 Up 方法, 來新增資料庫.)

            dotnet ef migrations add AddTable_Category
            dotnet ef database update

            dotnet ef migrations remove (註: 移除上一個移轉)
            dotnet ef migrations list (註: 列出所有移轉)
            (註: 重設所有移轉, 官方說直接把 /Migrations 資料夾 + DB刪除即可)

            # 出現 C:\Projects\Projects_ASP.NET_Core\MvcShopping\Models\Product.cs(9,29): warning CS8618: 
              退出建構函式時，不可為 Null 的 屬性 'Name' 必須包含非 Null 值。
              請考慮將 屬性 宣告為可為 Null。 [C:\Projects\Projects_ASP.NET_Core\MvcShopping\MvcShopping.csproj]

            # 配合調整 Model 內的 Name 屬性, 改為 string? (nullable的型別)
            # 再作一次資料庫更新
            dotnet ef migrations add modify_column_NameAndType
            dotnet ef database update

          dotnet tool uninstall --global dotnet-ef #已安裝不要再移除了#
          dotnet tool install --global dotnet-ef --version 7.0.10

          成功產生 Stores-Development.db, 
          # (appsettings.Development.json 內, "ConnectionStrings"值是我後來加上去的
            
            "ConnectionStrings": {
              "StoreContext": "Data Source=Stores-Develop.db"
            }

      (4) 測試執行(OK)

  本日完工

Day6-Mvc Action(控制器行為-詳細說明-看懂CRUD的Action)

  觀念介紹
    (1) Model <=> DB 的溝通橋梁, 利用 Entity Framework Core
    (2) Controller <=> View 間的表單傳值, 利用 HttpGet & HttpPost

    (1) Model <=> DB 的溝通橋梁, 利用 Entity Framework Core(EFCore)
      a.Entity Framework Core 是ORM框架
      b.當程式碼存取DB資源時, 統一對 DBContext 作操作.
      c.CRUD Entity(實體, 可想像一筆記錄), EFCore會自動處理RollBack & Commit
        > 程式碼片段 <
          _context.Add(product1);
          _context.Add(product2);
          _context.SaveChanges();

    (2) Controller <=> View 間的表單傳值, 利用 HttpGet & HttpPost
      a.HTTP協定中定義的方法，是用戶端和伺服器端處理傳值的方法.
        在實務上兩者都能達到傳值的效果
        但在本質上有所不同.
      b.HttpGet, 資源需求低, 安全性低(明信片) => 常用於 <Read查詢資料>
      c.HttpPost, 資源需求高, 安全性高(掛號) => 常用於 <C+U+D 表單>

  程式碼對應
    (1)開啟程式 Controllers\ProductsController.cs, 
        發現同一個新增動作, 對應兩個同名 Create Action
        差在 one for [HttpGet], the other for [HttpPost]

      // GET: Products/Create
      public IActionResult Create()
      {
          return View();
      }

      // POST: Products/Create
      // To protect from overposting attacks, enable the specific properties you want to bind to.
      // For more details, see http://go.microsoft.com/fwlink/?LinkId=317598.
      [HttpPost]
      [ValidateAntiForgeryToken]
      public async Task<IActionResult> Create([Bind("Id,Name,Price,Stock")] Product product)
      {
          if (ModelState.IsValid)
          {
              _context.Add(product);
              await _context.SaveChangesAsync();
              return RedirectToAction(nameof(Index));
          }
          return View(product);
      }

  本日完工

= 正式進入後台實作 BEGIN =

Day7-複雜的商品模型(後台)
  # Product資料表(新增欄位+與Category建立關聯) + Category資料表(新增資料表+與Product建立關聯)
  # 新增異動移轉(UpdateProduct_CreateCategory) + 重建資料庫

  Product資料表(新增欄位 + 與Category建立關聯)
    程式路徑: Models\Product.cs
    public class Product
    {
      public int Id { get; set; }

      public string? Name { get; set; }            //商品名稱
      public string? Description { get; set; }     //商品簡介
      public string? Content { get; set; }         //商品內容
      public int Price { get; set; }              //商品價格
      public int Stock { get; set; }              //商品庫存
      public byte[] Image { get; set; }           //商品圖片

      public int CategoryId { get; set; }         //類別 (Foreign Key)
      public Category Category { get; set; }
    }

  Category資料表(新增資料表 + 與Product建立關聯)
    程式路徑: Models\Category.cs
    public class Category
    {
      public int Id { get; set; }
      public string? Name { get; set; }            //類別名稱
      public List<Product> Products { get; set; }
    }

  新增異動移轉(UpdateProduct_CreateCategory) + 重建資料庫    
    dotnet ef migrations add UpdateDB_CreateRelation_Product_Category (註: 建立商品與類別間的模型關聯)
    dotnet ef database update
      (註: 出現Fatal Error, 因為FK建不起來, Product Table 已有資料, 
        解法: 刪掉現存資料 Product Table, 重新執行 dotnet ef database update)

    (Error)網站功能測試: 類別無法新增

  新增異動移轉(RollbackProduct_CreateCategory) + 重建資料庫(卡關) 
    dotnet ef migrations add RollbackRelation2_Product_Category (註: 再移除商品與類別間的模型關聯, 試圖救援)
    dotnet ef database update

    (OK)網站功能測試: 商品 & 類別都新增成功

  新增異動移轉(CreateRelation_ProductHasFKToCategory) + 重建資料庫(卡關) 
    (註: 再把商品與類別間的模型關聯建起來, 只有商品連類別, 類別未關聯回商品, 商品的Image欄位可為NULL)
    dotnet ef migrations add CreateRelation_ProductHasFKToCategory
    dotnet ef database update

    (OK)資料庫新增
    網站功能測試: 
      問題: 商品新增(Error) => 因為後端有新增欄位(Category), 但前端沒有給它, 所以會新增失敗.
      類別新增(OK)

      問題: 商品新增(Error) => 因為後端有新增欄位(Category), 但前端沒有給它, 所以會新增失敗.
      解法(50% 一樣儲存失敗??): 
        (1)後端準備(Category)欄位資料放在 HttpGet Create() Action @ProductsController.cs
            ViewData["Categories"] = new SelectList(_context.Set<Category>(), "Id", "Name");
        (2)前端接值顯示
            <div class="form-group">
                <label asp-for="CategoryId" class="control-label"></label>
                <select asp-for="CategoryId" class="form-control" asp-items="ViewBag.Categories" ></select>
                <span asp-validation-for="CategoryId" class="text-danger"></span>
            </div>
        (3)後端 HttpPost Create() Action 在Bind框框中, 也要接住前端回傳值 @ProductsController.cs
            public async Task<IActionResult> Create([Bind("Id,Name,Description,Content,Price,Stock,CategoryId")] Product product)

  新增異動移轉(CreateRelation_ProductHasFKToCategoryId) + 重建資料庫, 只有商品連類別[只連ID, 不連物件] (破關)
  <= 問題剖析: 果真是連物件, 造成失敗, 因為商品物件內只有類別ID, 沒有類別物件, 導致新增失敗. =>
    (註: 再把商品與類別間的模型關聯建起來, 只有商品連類別[只連ID, 不連物件], 類別未關聯回商品, 商品的Image欄位可為NULL)
    dotnet ef migrations add CreateRelation_ProductHasFKToCategoryId
    dotnet ef database update

  本日完工

Day8-新增商品類別(Controller, View, DbContext | Category Model在前一天已新增) + 調整產品頁面(加入類別欄位) => (後台)
  # 新增商品類別(Controller, View, DbContext)
  # 調整產品頁面(加入類別欄位)

  新增商品類別(商品已新增, 再新增類別, 網站會掛掉?? 先跳過..)
    dotnet aspnet-codegenerator controller -m Category -name CategoriesController  -dc StoreContext -outDir Controllers -sqlite -scripts -udl

    # 超強(但是直接掛掉, 連 <產品> 頁面都沒有反應???) #
      1.自動判斷StoreContext已存在. (註:只新增 public DbSet<MvcShopping.Models.Category>? Category { get; set; } )
      2.Controller, View也都新增成功.

      沒有反應的原因.(ModelState.IsValid = false, 所以留在原畫面)

  如果商品Model & 類別Model同時新增, 再先後執行下列 {scaffold} 指令 ?? 似乎又失效了...真奇怪 ??
    => (結果網站竟然正常, 而且還自動拉關聯, 太神奇了) 
    dotnet aspnet-codegenerator controller -m Category -name CategoriesController  -dc StoreContext -outDir Controllers -sqlite -scripts -udl
    dotnet aspnet-codegenerator controller -m Product -name ProductsController  -dc StoreContext -outDir Controllers -sqlite -scripts -udl          

  調整產品頁面(後端準備資料, 放入ViewBag/ViewData, 前端再顯示)

    # 注意: 後端會準備 "ViewBag.CategoryId" 給前端顯示用 #
    # 註: 如果你想把 {ID-Name} 一起在前端顯示的話, 可以在Model內對屬性動手腳, 再去Controller將屬性放入ViewBag內, 最後送至前端.

      //Model: 商品類別
      public class Category
      {
        public string Id_Name //前端顯示用(Id-Name)
        {
          get => $"{Id} - {CategoryName}";
        }
      }

      //Controller: Products
      public class ProductsController : Controller
      {
        public IActionResult Create()
        {
            ViewData["CategoryId"] = new SelectList(_context.Set<Category>(), "Id", "Id_Name");
            return View();
        }
      }

      SelectList: (前端用)表示可讓使用者選取一個項目的清單。
      # 注意: asp-items="ViewBag.CategoryId", 裡面放的就是 ProductsController 準備好的資料.
      
      //View: Views/Products/Create.cshtml
      <select asp-for="CategoryId" class ="form-control" asp-items="ViewBag.CategoryId"></select>

  本日完工

Day9-圖片上傳與預覽(後台)

  # 可同時服用 {在 ASP.NET Core 中上傳檔案}, 裡面有詳細解說與作法.
    https://learn.microsoft.com/zh-tw/aspnet/core/mvc/models/file-uploads?view=aspnetcore-7.0

  #網站呈現圖片的兩種方式
    (1)圖片存放在磁碟/網路空間, 資料庫只存放檔案路徑.
    (2)圖片以二進位型態(BLOB), 直接放入資料庫. => 本次實作方式 <=

  # asp-for(輸入標籤協助程式) <input asp-for="<Expression Name>">
    (1)會為 asp-for 屬性中指定的運算式名稱產生 id 和 name HTML 屬性
    (2)已指定 HTML type 屬性值時不會予以覆寫. ex. Bool => type="checkbox"
    (3)它會與Model作強型別檢查.

  # 圖片上傳(終於破關, 因為ModelState is false, 問題出在 IFormFile 值為NULL)
    (1)前端要作兩件事
      a. 以 <input type="file" id="myImage" name="myImage" class="form-control" /> 作為圖片檔案上傳的欄位
        * id & name 名稱要和後端 IFormFile 的參數名稱相同.
        * asp-for="Image" 會快速長出 id="Image" name="Image", 而且也會跟 Model屬性對應.
          
          <label asp-for="Image" class="control-label"></label>
          <input type="file" id="myImage" name="myImage" class="form-control" /> @* 正確寫法: 因為id跟後端Action有對應, 檢查成功 *@
          @* <input type="file" asp-for="myImage" class="form-control" />  錯誤寫法: 因為Product Model裡面沒有 myImage 屬性, 對應失敗 *@
          @* <input type="file" asp-for="Image" class="form-control" /> 錯誤寫法, 因為id跟後端Action沒有對應, 會檢查失敗 *@
      
      b. 如果是用表單<form>的話, 
         enctype="multipart/form-data" 一定要加上去, 不然後端接不到, 新增失敗. (註: 找了好久問題出在哪, 快瘋掉..)
        * 修改前 <form asp-action="Create" >
        * 修改後 <form asp-action="Create" enctype="multipart/form-data">

    (2)後端用 參數型態{IFormFile} 參數名稱{myimg} 來接收欄位的檔案，
      ( 用 MemoryStream.ToArray() 把檔案轉成位元組陣列, 塞入資料庫的 BLOB 欄位中.)

      public async Task<IActionResult> Create([Bind("Id,CategoryId,Name,Description,Content,Price,Stock")] Product product, IFormFile Image)
      {
        if (ModelState.IsValid)
        {
            if (Image != null)
            {
              using (var ms = new MemoryStream())
              {
                  Image.CopyTo(ms);
                  product.Image = ms.ToArray();
              }
            }  
            
          ..略...
        }
        ViewData["Categories"] = new SelectList(_context.Set<Category>(), "Id", "Name", product.CategoryId);
        return View(product);
      }

  # 圖片顯示(終於破關, 前端抓到Model值, SQLite BLOB欄位存的即是 Base64, 
    只要再加上前面 "data:image/png;base64," + Base64_Value, 指派給 img src 屬性, 它就會顯示出來)

    參考資料("data:image/png;base64,"): https://www.geeksforgeeks.org/how-to-display-base64-images-in-html/
    參考資料(可能之後會用到): https://ithelp.ithome.com.tw/articles/10212341

    實作功能：新增畫面, 預覽上傳圖片
    程式碼：Views\Products\Create.cshtml
    實作方式：
      (1)[VIP] MVC View中, JavaScript 及呼叫JQuery的正確位置. 在View的最下方, 再用<script>包起來
          @section Scripts {
              @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}

              <script>
                  $(document).ready(function() {
                      alert("Test");
                  });

                  $('#myImage').on('change', function (e) {
                      const file = this.files[0];
                      const objectURL = URL.createObjectURL(file);    // 使用 createObjectURL 產生圖片url
                      $('#preview').attr('src', objectURL);
                  });

              </script>
          }
      (2)放個預覽顯示用的 Image 物件
      (3)前端利用JS在 File 物件, 綁上 onChange 事件
      (4)檔案上傳後, Image 物件就會顯示圖片.

    實作功能：檢視畫面, 下載圖片
    程式碼：Views\Products\Details.cshtml
    實作方式：
      (1)把圖片陣列轉為Base64字串, 先藏在Hidden內, 再傳至前端.
      (2)前端利用JS抓出 Hidden 物件, 在 Hidden值前面加上 "data:image/png;base64,". (註: 不然Image會不認識)
      (3)前端利用JS抓出 Image 物件, 把上個步驟組好的值, 塞給 img 的 src 屬性, 圖片即可正常顯示.

  本日完工(終於破關)

Day10-登入功能
  

/*==從實作學習ASP.NET Core - 30天的購物網站系列 <.NET 6> [2023/04/05 ~ 未完成]==*/ 
  第1次沒有作完, 就去台半上班了. 2023/05/09從台半離職後, 再來把它作完
  資料來源: https://ithelp.ithome.com.tw/articles/10258872
  
  註:學習歷程相同, 採用<VSCode + Sqlite(測試環境) + Oracle XE 11g Express(正式環境)>, 
     非範例使用的右例工具 <VSCommunity 2019 + SQL Server 2019 Express with Management Studio>
      
  Day1: 新增asp.net core web app(MVC)
    ProjectName: OnlineShopCMS (我的專案名稱: NET6_MvcShopping)
    .Net Version: .NET 5.0 (我的.NET SDK 版本: .NET 6.0)

    * 新增方案資料夾 C:\Projects\Projects_ASP.NET_Core\NET6_MvcShopping
    * CMD路徑切換至方案資料夾
    * 新增MVC架構網站 => dotnet new mvc
    * 測試編譯 => dotnet build
    * 信任測試環境簽章(https用) => dotnet dev-certs https --trust
    * 測試執行 => dotnet run
      1. 第1次建置要花比較久的時間, 接下來產生<bin> & <obj> 兩個資料夾
      2. 產生兩個網址, 一個有https憑證, 另一個沒有
        info: Microsoft.Hosting.Lifetime[14]
              Now listening on: https://localhost:7254
        info: Microsoft.Hosting.Lifetime[14]
              Now listening on: http://localhost:5276
        info: Microsoft.Hosting.Lifetime[0]
              Application started. Press Ctrl+C to shut down.
        info: Microsoft.Hosting.Lifetime[0]
              Hosting environment: Development
        info: Microsoft.Hosting.Lifetime[0]
              Content root path: C:\Projects\Projects_ASP.NET_Core\NET6_MvcShopping\

  Day2: 說明MVC的架構
    https://imgur.com/xbA1MZq.jpg
    
    * 從作者引用的圖可以發現, 雖然使用者看到的是<View>的呈現結果
      但要求都會 "先送至" <Controller>, 
      再由<Controller>負責去<Model>取資料或交給<View>作呈現.

      > Controller：負責商業邏輯處理，管控流程和回應，並以路由傳遞資料
      > Model：負責資料存儲，處理資料與資料庫之間的操作
      > View：負責前端畫面與邏輯顯示，就是使用者會看到的介面

    * MVC網站專案目錄      
      > Controllers、Models、Views 資料夾：我們程式的主角
      > appsettings.json：儲存環境變數的地方，例如資料庫連接字串
      > Program.cs：程式的起始點
      > Startup.cs：程式的組態檔，服務需要從這邊註冊。(註: 從.NET 6開始已合併至Program.cs)

        註: 從.NET 6之後 <Startup.cs> 消失了, "服務註冊作業(DI)" 被合併至 <Program.cs>.
        詳細說明參閱連結, https://stackoverflow.com/questions/70952271/startup-cs-class-is-missing-in-net-6

  Day3: Controller 控制器
    https://imgur.com/CJXZGiK.jpg

    * 觀念介紹
      > 路由, 就是 <網址路徑> 的規則.
      > 使用者需要用<網址路徑>來向程式發出請求.
      > MVC預設網址路徑為: https://[你的網路位置:port]/[Controller名稱]/[Action名稱]
      > MVC預設網址路徑規則定義在: "Program.cs" 檔案內. 
        app.MapControllerRoute(
          name: "default",
          pattern: "{controller=Home}/{action=Index}/{id?}");

    * 手動新增控制器(Controller)

      > 新增 HelloWorldController by 自動產生程式碼工具<dotnet aspnet-codegenerator>

        dotnet aspnet-codegenerator controller -name HelloWorldController -outDir Controllers -scripts -udl

      > 透過 Welcome Action, 向 HomeController 傳遞參數, 再回傳值.

        # Program.cs檔案內, 預設<路由規則>-寫法1 #
          app.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");

        # Program.cs檔案內, 預設<路由規則>-寫法2 #
          app.MapDefaultControllerRoute(); //功能跟寫法1相同, 但更簡潔.(使用路由範本預設 Home 控制器和 Index 動作)

        # 增加另一個 "Welcome Action" , name 則是選擇性參數.
          https://localhost:7254/Home/Welcome/KL

        # 範例沒有問題, 它用的是 <?> 作為參數分隔符號, 要指定參數名稱(Name)非使用預設路由規則名稱(id)
        # 這不符合目前 <路由規則> 以 </> 作為分隔符號, 所以抓不到傳入值.
          https://localhost:7254/Home/Welcome?KL (X)
          https://localhost:7254/Home/Welcome/KL (O)

        public string Welcome(string? name){
            return "This is Welcome Action of Home Controller: 你好嗎? " + name;
        }
    
    * 利用工具 自動 新增控制器(Controller) & 檢視(View) & DbContext(ORM) & ConnectionStrings(連線字串) by 資料模型(Data/Model)
      
      > #! VIP: 使用 <dotnet aspnet-codegenerator> 
        快速 "新增控制器(Controller) & 檢視(View) by 資料模型(Data/Model)" 前, 
        一定要執行下列前置作業, 否則會出現錯誤.
        請服用 " <命令列環境>下使用 <dotnet aspnet-codegenerator> 工具的前置作業 "

      範例1: 使用 資料模型(Data/Model)的超完整範例 
      
        a.Step1: 先新增資料模型(Data/Model): "Product.cs"
        
          using System;
          using System.Collections.Generic;

          namespace NET6_MvcShopping.Models;

          public class Product
          {
              public int ProductID {get;set;} //系統指定ID, 無法變更
              public string? Name {get;set;}
              public decimal? Price {get;set;}
              public int? Stock {get;set;}
          }

        b.Step2: 執行 <dotnet aspnet-codegenerator> Scaffolding 程式碼產生工具
          dotnet aspnet-codegenerator controller -name ProductsController 
            -m Product -dc StoreContext -outDir Controllers 
            -sqlite -scripts -udl

          自動完成下列作業: <= 超強 =>
            1.自動新增控制器(\Controllers) & 
            2.新增檢視(\Views) & 
            3.新增DbContext(\Data) & 
            4.新增ConnectionStrings(@appsettings.json) &
              註1: 如果ConnectionStrings未新增, 工具會加在"appsettings.json"檔案內.
              註2: 如果ConnectionStrings已新增, 工具會保留ConnectionStrings原值不異動.
            5.註冊Database服務(@Program.cs)
          
      範例2: 只產生 控制器(Controller), 沒有 檢視(View).
          dotnet aspnet-codegenerator controller 
          -name HelloWorldController 
          -outDir Controllers (O, 指定相對輸出檔案夾路徑)
        
      範例3: 只產生 控制器(Controller), 沒有 檢視(View), 而且把 控制器(Controller)直接加在專案資料夾下.
          dotnet aspnet-codegenerator controller 
          -name HelloWorldController (X, 直接加在專案資料夾, 刪掉)

      > 新增控制器(Controller)指令用法 => "dotnet aspnet-codegenerator controller -h"
        Generator Options:
          --controllerName|-name [#!-必填欄位-#] : (控制器名稱)Name of the controller
          --useAsyncActions|-async            : (產生非同步actions)Switch to indicate whether to generate async controller actions
          --noViews|-nv                       : (產生CRUD檢視)Switch to indicate whether to generate CRUD views
          --restWithNoViews|-api              : (API專用控制器, 預設noViews & 忽略所有檢視設定)Specify this switch to generate a Controller with REST style API, noViews is assumed and any view related options are ignored
          --readWriteActions|-actions         : (產生讀/寫用actions)Specify this switch to generate Controller with read/write actions when a Model class is not used
          --model|-m                          : Model class to use
          --dataContext|-dc                   : DbContext class to use
          --referenceScriptLibraries|-scripts : Switch to specify whether to reference script libraries in the generated views
          --layout|-l                         : Custom Layout page to use
          --useDefaultLayout|-udl             : Switch to specify that default layout should be used for the views
          --force|-f                          : Use this option to overwrite existing files
          --relativeFolderPath|-outDir        : Specify the relative output folder path from project where the file needs to be generated, if not specified, file will be generated in the project folder
          --controllerNamespace|-namespace    : Specify the name of the namespace to use for the generated controller
          --useSqlite|-sqlite                 : Flag to specify if DbContext should use SQLite instead of SQL Server.

      > 新增視圖(View)指令用法 => "dotnet aspnet-codegenerator view -h"

        Generator Arguments:(這兩個參數一定要給)
          viewName     : Name of the view
          templateName : The view template to use, supported view templates: 'Empty|Create|Edit|Delete|Details|List'

        Generator Options:
          --model|-m                          : Model class to use
          --dataContext|-dc                   : DbContext class to use
          --referenceScriptLibraries|-scripts : Switch to specify whether to reference script libraries in the generated views
          --layout|-l                         : Custom Layout page to use
          --useDefaultLayout|-udl             : Switch to specify that default layout should be used for the views
          --force|-f                          : Use this option to overwrite existing files
          --relativeFolderPath|-outDir        : Specify the relative output folder path from project where the file needs to be generated, if not specified, file will be generated in the project folder
          --controllerNamespace|-namespace    : Specify the name of the namespace to use for the generated controller
          --partialView|-partial              : Generate a partial view, other layout options (-l and -udl) are ignored if this is specified
          --useSqlite|-sqlite                 : Flag to specify if DbContext should use SQLite instead of SQL Server.

  Day3.5(內容重覆): 如何使用 .NET CLI 快速產生 ASP․NET Core 的 Controllers 與 Views 程式碼

    資料來源: https://blog.miniasp.com/post/2020/09/09/Create-Controller-and-Views-with-dotnet-aspnet-codegenerator
    重點在於: 
      1.必須先有 <資料表結構> 的程式碼
        建立 Data 相關程式碼(C:\Projects\Projects_ASP.NET_Core\MvcMovie\Models\Movie.cs)
          using System.ComponentModel;
          using System.ComponentModel.DataAnnotations;
          using System.ComponentModel.DataAnnotations.Schema;

          namespace MvcMovie.Models
          {
            public class Movie
            {
              public int Id {get; set;}
              
              [DisplayName("片名"), StringLength(10, MinimumLength =3)]
              public string? Title {get; set;}

              [DisplayName("發售日期"), DataType(DataType.Date)]
              public DateTime ReleaseDate {get; set;}
              
              [DisplayName("類別"), StringLength(20, MinimumLength =3)]
              public string? Genre {get; set;}
              
              [DisplayName("售價"), DataType(DataType.Currency), Range(1,150), Column(TypeName = "decimal(18, 2)")]
              public decimal Price {get; set;}

              [DisplayName("評價"), StringLength(5), RegularExpression(@"^[A-Z]+[a-z]+[0-9]*$")]
              public string? Rating {get;set;}

            }
          }

      2. 參閱 <Dependency injection 關注點注入, 這就是DI> 章節內容 <= 觀念介紹 =>
        MVC中的 "Model" = 由1個實體類別(/Model/Movie.cs) + 1個Context Object(/Data/MvcMovieContext.cs)所組成的, 它代表資料庫中的一個Session.

      3. 快速建立 DepartmentsController 控制器（包含 Views 頁面與使用現有 Layout 版面）
          dotnet aspnet-codegenerator controller -name DepartmentsController 
          -async -scripts -udl 
          -m Department -dc ContosoUniversityContext -outDir Controllers

  Day4: View 視圖
    https://imgur.com/rqnct3l.jpg

    * 新增View



